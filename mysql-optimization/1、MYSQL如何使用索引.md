摘自官网=============================
MySQL使用索引进行以下操作：

To find the rows matching a WHERE clause quickly.
1、WHERE条件中，快速查找匹配的行。

To eliminate rows from consideration. If there is a choice between multiple indexes, MySQL normally uses the index that finds the smallest number of rows (the most selective index).
2、从准备查询的数据中消除多余行。如果可以在多个索引之间进行选择，则MySQL通常会使用查找最少行数的索引。
																		

3、如果表具有多列索引，那么优化器可以使用索引的任何最左前缀来查找行。
   举例来说，如果你有一个三列的索引 (col1, col2, col3)，你有索引的搜索功能(col1)， (col1, col2)以及(col1, col2, col3)。有关更多信息，请参见 第8.3.6节“多列索引”。

4、执行联接时从其他表中检索行。如果声明相同的类型和大小，MySQL可以更有效地在列上使用索引。
   在这种情况下， VARCHAR与 CHAR被认为是相同的，如果它们被声明为相同的大小。例如， VARCHAR(10)和 CHAR(10)是相同的大小，但是 VARCHAR(10)和 CHAR(15)不是。

   为了在非二进制字符串列之间进行比较，两个列应使用相同的字符集。例如，将一utf8列与一 latin1列进行比较会排除使用索引。

   如果无法通过转换直接比较值，则比较不同的列（例如，将字符串列与时间或数字列进行比较）可能会阻止使用索引。
   对于给定的值，如1 是数值，它可能与字符串列进行比较时，是相等的，例如 '1'，' 1'， '00001'，或'01.e1'。这排除了对字符串列使用任何索引的可能性。

5、查找指定索引列的MIN()或 MAX()值key_col。这由预处理器进行了优化，该预处理器检查您是否正在使用 索引中之前出现的所有关键部分。
   在这种情况下，MySQL为每个表达式或 表达式执行一次键查找，并将其替换为常量。如果所有表达式都用常量替换，查询将立即返回。
   例如： WHERE key_part_N = constant;

	SELECT MIN(key_part2),MAX(key_part2)
		FROM tbl_name WHERE key_part1=10;

6、如果排序或分组是在可用索引的最左前缀上完成的，则对表进行排序或分组（例如 ORDER BY key_part1, key_part2）。如果列是反过来的，则按相反顺序读取数据。
（或者，如果索引是降序索引，则按向前顺序读取键。）请参见 第8.2.1.16节“按优化排序”， 第8.2.1.17节“按优化分组”和 第8.3.13节“降序索引”。 ORDER BY key_part1, key_part2DESC

7、在某些情况下，可以优化查询以检索值而无需查询数据行。（为查询提供所有必要结果的索引称为 覆盖索引。）如果查询仅从表中使用某些索引中包含的列，则可以从索引树中检索所选值，以提高速度：

	SELECT key_part3 FROM tbl_name
	  WHERE key_part1=1

   好处：
		查询只要扫描索引，就能返回查询所需要的值，只扫描所引树。
		如果不是覆盖索引，需要回表查询。
8、对于报表查询处理大多数或所有行的小型表或大型表，索引的重要性不那么重要。当查询需要访问大多数行时，顺序读取要比处理索引快。顺序读取可以最大程度地减少磁盘查找，即使查询不需要所有行。有关详细信息，请参见第8.2.1.23节“避免全表扫描”。
	十几万到几千万。

个人理解====================================
1、快速查询数据
2、如果可以在多个索引之间进行选择，则MySQL通常会使用查找最少行数的索引。
3、多列索引/覆盖索引，满足最佳左前缀原则 
4、保证列的类型与输入参数的类型、字符集保持一致，减少隐式类型转换。
	小细节：当把一个VARCHAR列读取到内存中，会分配定义VARCHAR时指定的大小。
	例如，定义的字段为：`user_province` varchar(100) DEFAULT NULL COMMENT '用户所在省',则在内存中分配长度为100的空间，CHAR(100)也会分配100的空间，
	此时VARCHAR(100) 与 CHAR(100)是等同的。
5、MIN()、MAX()等函数，可以直接取索引的最左端或最右端，在SQL优化阶段，底层会转化为常数
6、第一，尽量使用多列索引/覆盖索引完成排序、分组
   第二，保持顺序一致，要么都是正序，要么都是倒序，不能一正一倒
   第三，尽量在关联查询时，在第一个表上面做排序分组

   反衬出索引的优势：避免使用临时表排序
7、覆盖索引：返回的参数，都在索引中，减少了回表操作。多列索引中包含了需要返回的数据，此时就成为覆盖索引。
8、对于全表扫描的业务，索引的意义不大

9、MySQL5.6中，ICP过滤掉了更多的数据行
	MRR使随机IO变顺序IO