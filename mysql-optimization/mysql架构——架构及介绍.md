# MySQL架构及组成介绍

## （一）数据库和数据库实例

​	在MySQL的学习研究中，存在两个非常容易混淆的概念，即数据库和数据库实例。在MySQL中，数据库和数据库实例定义如下：

- 数据库：存储数据的集合，他是**文件**；

- 数据库实例：操作数据库的集合，他是**程序**。

   **如上定义很清楚了，数据库是用来存储数据的，数据库实例是用来操作数据的，从操作系统的角度，数据库实例表现为一个进程，对应多个线程。**

在非集群数据库架构中，数据库与数据库实例存在一 一对应关系，在数据库集群中，可能存在多个数据库实例操作一个数据库情况，即多对一关系。

---

## （二） MySQL基架

首先看看MySQL架构图

![MySQL架构图](../mysql-image/1.0.1.MySQL架构图.jpg)

对于MySQL来说，虽然经历了多个版本迭代（MySQL5.5,MySQL 5.6,MySQL 5.7,MySQL 8）,但每次的迭代，都是基于MySQL

基架的，MySQL基架大致包括如下9大模块组件：

### （1）MySQL向外提供的交互接口（Connectors）

Connectors组件，是MySQL向外提供的交互组件，如java,.net,php等语言可以通过该组件来操作SQL语句，实现与SQL的交互。

### （2）管理服务组件和工具组件(Management Service & Utilities)

提供对MySQL的集成管理，如**备份(Backup)、恢复(Recovery)、安全管理(Security)、复制(Replication)、集群(Cluster)、管理(Administration)、配置(Configuration)、迁移(Migration)、元数据(Metadata)等**

### （3）连接池组件(Connection Pool)

负责监听对客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。**每个成功连接MySQL Server的客户请求都会被创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。**

功能包含：**身份验证(Authentication)、线程复用(Thread Reuse)、连接数限制(Connection Limits)、内存检查(Check Memory)、缓存(Caches)。**

### （4）SQL接口组件(SQL Interface)

 接收用户SQL命令，如**DML,DDL和存储过程、视图、触发器**等，并将最终结果返回给用户。

### （5）查询分析器组件(Parser)

首先分析SQL命令语法的合法性，并尝试将SQL命令分解成数据结构，若分解失败，则提示SQL语句不合理。**查询翻译(Query Translation)、对象特权(Object Privilege)**

### （6）优化器组件（Optimizer）

对SQL命令按照标准流程进行优化分析。

### （7）缓存主件（Caches & Buffers）

全局缓存、存储引擎特定缓存、缓冲组件。建议关闭缓存，而且默认是关闭的。8.0已被删除

#### 1️⃣. MySQL查询缓存简介

MySQL查询缓存是MySQL中比较独特的一个**缓存区域**，用来缓存特定Query的整个结果集信息，且共享给所有客户端。为了提高完全相同的Query语句的响应速度，MySQL Server会**对查询语句进行Hash计算后，把得到的hash值与Query查询的结果集对应存放在Query Cache中**。当MySQL Server打开Query Cache之后，MySQL Server会对接收到的每一个SELECT 语句通过特定的Hash算法计算该Query的Hash值，然后通过该hash值到Query Cache中去匹配。

如果没有匹配，将这个hash值存放在一个hash链表中，并将Query的结果集存放到cache中，存放hashi值链表的每个hash节点存放了相应Quey结果集在cache中的地址，以及该query所涉及到一些table相关信息；
如果通过hash值匹配到了一样的Query，则直接将cache中相应的Query结果集返回给客户端。
**目前MySQL Query Cache只会cache select语句，其他类似show ，use的语句不会被cache**。MySQL 的每个Query Cache都是以SQL文本作为key来存储的，在应用Query Cache之前，SQL文本不会做任何处理。也就是说，**两个SQL语句，只要相差哪怕一个字符(例如大小写不一样，多一个空格，多注释)，那么这两个SQL将使用不同的Cache地址**。如: 下面三条SQL将会被存储在三个不同的缓存里，虽然他们的结果都是一样的。select * FROM people where name='surfchen'; select * FROM people where /*hey~*/ name='surfchen'; SELECT * FROM people where name='surfchen';

#### 2️⃣. MySQL Query Cache优缺点

优点：Query Cache的查询，发生在MySQL接收到客户端的查询请求、查询权限验证之后和查询SQL解析之前。也就是说，当MySQL接收到客户端的查询SQL之后，仅仅只需要对其进行相应的权限验证之后，就会通过Query Cache来查找结果，甚至都不需要经过解析SQL、Optimizer模块进行执行计划的分析优化，更不需要发生任何存储引擎的交互。由于Query Cache是基于内存的，直接从内存中返回相应的查询结果，因此减少了大量的磁盘I/O和CPU计算，导致效率非常高。

缺点：Query Cache的优点很明显，但是也不能忽略它所带来的一些缺点：

1. hash计算影响性能问题。
   查询语句的hash计算和hash查找带来的资源消耗。如果将query_cache_type设置为1（也就是ON），那么MySQL会对每条接收到的SELECT类型的查询进行hash计算，然后查找这个查询的缓存结果是否存在。虽然hash计算和查找的效率已经足够高了，一条查询语句所带来的开销可以忽略，**但一旦涉及到高并发，有成千上万条查询语句时，hash计算和查找所带来的开销就必须重视了。**
2. Query Cache失效问题。**如果表的变更比较频繁，则会造成Query Cache的失效率非常高。表的变更不仅仅指表中的数据发生变化，还包括表结构或者索引的任何变化。**
3. 内存浪费问题。**查询语句不同，但查询结果相同的查询都会被缓存，这样便会造成内存资源的过度消耗**。查询语句的字符大小写、空格或者注释的不同，Query Cache都会认为是不同的查询（因为他们的hash值会不同）。
   相关系统变量设置不合理会造成大量的内存碎片，这样便会导致Query Cache频繁清理内存。

### （8）插件式存储引擎（Pluggable Storage Engines）

1. 什么是MySQL存储引擎

   ​    MySQL属于关系型数据库，而关系型数据库的存储是以表的形式进行的，对于表的创建，数据的存储，检索，更新等都是由MySQL存储引擎完成的，这也是MySQL存储引擎在MySQL中扮演的重要角色。
   

      研究过SQL Server和Oracle的读者可能很清楚，这两种数据库的存储引擎只有一个，而MySQL的存储引擎种类比较多，如MyISAM存储引擎，InnoDB存储引擎和Memory存储引擎等
   

   ​    MySQL之所以有多种存储引擎，是因为MySQL的开源性决定的。MySQL存储引擎，从种类上来说，大致可归结为官方存储引擎和第三方存储引起。MySQL的开源性，允许第三方基于MySQL骨架，开发适合自己业务需求的存储引擎。

2. MySQL存储引擎作用

   ​    MySQL存储引擎在MySQL中扮演重要角色，其作比较重要作用，大致归结为如下两方面：

   - 作用一：管理表创建，数据检索，索引创建等

   - 作用二：满足自定义存储引擎开发。

3. MySQL引擎种类

   ​    不同种类的存储引擎，在存储表时的存储引擎表机制也有所不同，从MySQL存储引擎种类上来说，可以分为官方存储引擎和第三方存储引擎。

   ​    当前，也存在多种MySQL存储引擎，如MyISAM存储引擎，InnoDB存储引擎，NDB存储引擎，Archive存储引擎，Federated存储引擎，Memory存储引擎，Merge存储引擎，Parter存储引擎，Community存储引擎，Custom存储引擎和其他存储引擎。

   ​    其中，比较常用的存储引擎包括**InnoDB存储引擎，MyISAM存储引擎和Momery存储引擎，MySQL8.0中新增TempTable存储引擎，监控MySQL时用的Performance_schema存储引擎，对MYISAM引擎的整合MRG_MYISAM**。

4. 几种典型MySQL存储引擎比较

![1.0.4.MySQL支持的存储引擎.jpg](../mysql-image/1.0.4.MySQL支持的存储引擎.jpg)

### （9）物理文件（File System）

实际存储MySQL 数据库文件和一些日志文件等的系统，如Linux，Unix,Windows等。

---

## （三）一条查询sql的大概执行流程

![1.0.5.查询sql大概执行流程](../mysql-image/1.0.5.查询sql大概执行流程.png)

### 1.客户端发送一条查询给服务器

MySQL客户端/服务端通信协议是**“半双工”**的：**在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生**。**一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。**

客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置`max_allowed_packet`参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。

与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。**因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用`SELECT *`以及加上LIMIT限制的原因之一。**

**数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个**

我们在数据库层执行SQL语句时，应用程序会连接到相应的数据库服务器，把SQL语句发送给服务器处理。对于一个MySQL连接，或者说一个线程，任何时刻都有一个状态，表示MySQL当前在做什么。我们使用最简单的`SHOW PROCESSLIST`命令（该命令返回结果中的Command列就表示当前的状态）来查询。下面将这些状态列出来，并做一个简单的解释：

![1.0.6.查看服务器正在执行的线程](../mysql-image/1.0.6.查看服务器正在执行的线程.jpg)

- Sleep：线程正在等待客户端发送新的请求。
- Query：线程正在执行查询或者正在将结果发送给客户端。
- Locked：在MySQL服务器层，该线程正在等待表锁。
- Analyzing and statistics : 线程正在收集存储引擎的统计信息，并生成查询的执行计划。
- Coping to tmp table [on disk]：线程正在执行查询，并且将其结果都复制到一个临时表中，这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，或者是UNION操作。如果这个状态后面还有"on disk"标记，那表示MySQL正在讲一个内存临时表放到磁盘上。
- Sorting result：线程正在对结果集进行排序。
- Sending data：这表示多种情况：线程可能在对多个状态之间传输数据，或者正在生成结果集，或者在向客户端返回数据。

### 2.服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段

服务器在解析一个查询语句之前，如果查询缓存是打开的（MySQL5.7默认关闭，8.0已删除，可以使用have_query_cache查看）。

如果缓存是开启状态，在接收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相对应的查询数据（某条给定的查询语句在第一次执行时，服务器会缓存这条查询语句和他返回的结果。）

- 如果存在，那么在返回查询结果之前**，**MySQL**会检查一次用户权限**。这仍然**无需解析**查询SQL语句，因为查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题，key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，**那么这个 value 就会被则直接从缓存中拿到结果返回给客户端**。这种情况下，**查询不会被解析，不用生成执行计划**，**不会被执行**。而其中**是否命中缓存**是将此**查询语句和缓存中的查询语句进行比对**，如果完全相同，那就认为它们是相同的，就认为**命中缓存了**。
- **如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中**



### 3.服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。

接下来服务器会将一个SQL转换成一个执行计划，MySQL再依照这个执行计划和存储引擎进行交互。包括多个子阶段：**解析SQL、预处理、优化SQL执行计划**，**其中任何一个阶段出错都会导致查询进行不下去**。

#### **(3.1) 解析SQL**

Mysql通过将SQL语句进行解析，并生成一棵对应的解析树。MySQL解析器将使用MySQL**语法分析(语法规则验证)**和解析查询，如将**验证**是否使用**错误的关键字**，或者**关键字的顺序**是否正确。

#### **(3.2) 预处理**

预处理器根据一些Mysql规则进一步检查解析树是否合法，如**数据表**和**数据列是否存在**，**解析列名**和**别名**，**是否有歧义**。接下来预处理器会**验证用户权限(precheck)。查看用户是否有相应的操作权限**。

#### **(3.3) 优化SQL**

优化器是在表里面有**多个索引**的时候，决定使用**哪个索引**；或者在一个语句有*多表关联（join）*的时候，决定各个表的**连接顺序**，将SQL语句转化成执行计划，**一条查询可以有很多种执行方式，最后都返回相同的结果，优化器的作用就是找到其中最好的执行计划（Mysql使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划的成本，选择其中成本最小的一个）。**

可以通过以下两种方式查看优化器执行SQL的最终成本，该成本值代表，**MySQL优化器认为需要2540成本的消耗才能找到最终结果。优化器评估成本时，不考虑任何层面的缓存，他假设都需要经历磁盘IO。**

```sql
# 1.通过查询 Last_query_cost
mysql> show status like 'Last_query_cost';
+-----------------+-------------+
| Variable_name   | Value       |
+-----------------+-------------+
| Last_query_cost | 2540.399000 |
+-----------------+-------------+
1 row in set (0.00 sec)

# 2.MySQL5.7以上，通过 <explain format=json + sql语句> 来查看执行计划 -> "query_cost"即为查询成本
mysql> explain format=json select * from user1 where user_age = 34;
+-----------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                         |
+-----------------------------------------------------------------------------------------------------------------+
| {																										|
| "query_block": {																					      |
|   "select_id": 1,   // 表的执行顺序，相当于 explain 的 id                                                         |
|   "cost_info": {                                                                                                |
|     "query_cost": "2540.40"      // 最终的查询成本                                                               |
|   },                                                                                                            |
|   "table": {                                                                                                    |
|     "table_name": "user1",  //表名                                                                              |
|     "access_type": "ref",   //查询方式 - ref非唯一索引扫描                                  	                    |
|     "possible_keys": [      //可能用到的索引                                                                     |
|       "idx_user_age"                                                                                            |
|     ],                                                                                                          |
|     "key": "idx_user_age",   //实际上使用的索引                                                                   |
|     "used_key_parts": [      //使用索引的字段                                                                    |
|       "user_age"                                                                                                |
|     ],                                                                                                          |
|     "key_length": "2",       //key比较的长度                                                                     |
|     "ref": [                                                                                                    |
|       "const"                //在选中的索引中，使用了常量                                                         |
|     ],                                                                                                          |
|     "rows_examined_per_scan": 2117,    // 查询一次user1表大致需要扫描9688条记录                                   |
|     "rows_produced_per_join": 2117,      // 驱动表user1的扇出是968                                               |
|     "filtered": "100.00",                // condition filtering代表的百分比                                      |
|     "cost_info": {                                                                                              |
|       "read_cost": "2117.00",            // IO成本 + 检测rows × (1 - filter)条记录的CPU成本                       |
|       "eval_cost": "423.40",           //  检测 rows × filter条记录的成本。                                       |
|       "prefix_cost": "2540.40",          // 单独查询 user1表的成本，同时 它等于 read_cost +  eval_cost             |
|       "data_read_per_join": "1M"                                                                                |
|     },                                                                                                          |
|     "used_columns": [               // 执行查询中涉及到的列     			                                     |
|       "user_id",                                                                                                |
|       "user_name",                                                                                              |
|       "user_age",                                                                                               |
|       "user_password",                                                                                          |
|       "user_sex",                                                                                               |
|       "user_province",                                                                                          |
|       "user_city",                                                                                              |
|       "user_area",                                                                                              |
|       "create_time",                                                                                            |
|       "modified_time"                                                                                           |
|     ]                                                                                                           |
|   }                                                                                                             |
| }                                                                                                               |
|}                                                                                                                |
+-----------------------------------------------------------------------------------------------------------------+
1 row in set, 1 warning (0.01 sec)
```

> 关于更多explain信息，可以查看[这里](https://cloud.tencent.com/developer/article/1655411)

**有很多中原因导致MySQL优化器选择错误的计划**，如下所示：

- **统计信息不准确**：MySQL依赖存储引擎提供的统计信息来评估成本，但是有的存储引擎提供的信息偏差有点大，例如InnoDB因为其MVCC的架构，并不能维护一个数据表的行数的精确统计信息；且InnoDB采用随机取8个数据页样本，进而计算整体数据。
- **执行计划中的成本估算不等于实际的操作成本。**优化器考虑的是真实的物理IO，但实际上，查询的页面可能在InnoDB的缓冲池中，可能实际上成本更低。
- **MySQL的最优可能和你想的最优不一样。**我们当然希望SQL执行地越快越好，但MySQL优化器只认cpu成本+IO成本，执行速度不一定是最快的！
- **MySQL从不考虑其他并发执行的查询**
- MySQL也并不是任何时候都是基于成本的优化，例如存在全文索引的MATCH()字句，则在有全文索引的情况下，使用全文索引。即使走其他索引会更快，成本更低
- **MySQL不会考虑不受其控制的操作成本**。例如执行存储过程或者用户自定义函数的成本
- **优化器有时候无法估算所有可能的执行计划，所以可能会错过最佳的执行计划**

MySQL的查询优化器使用很多策略来生成一个最优的执行计划。

**优化策略可以简单的分为两种**

- **静态优化**： 静态优化可以直接对解析树进行分析，并完成优化。例如优化器可以通过简单的代数变化将WHERE条件转换成另外一种等价形式，静态优化在第一次完成后就一直有效，即使使用不同的参数重复执行查询也不会变化。可以认为是一种”编译时优化“
- **动态优化**：和查询的上下文有关，也可能和其他因素有关，例如WHERE中取值、索引中条目对应的数据行数等。这需要在每次查询的时候重新评估，可以让那位u是”运行时优化“。

**MySQL能够处理的优化类型：**

- **重新定义关联表顺序**，例如 select * from A left join B on ... left join C on ...最终的执行顺序不一定是 A -> B -> C，有可能是 C -> B -> A
- **将外连接转化成内连接，并不是所有的 OUTER JOIN都以外连接方式执行。**当优化器认为外连接可以转化为内连接后，会重写sql，转为内连接。
- **使用等价变换规则。**例如，(5 = 5 and a > 5)，优化器会去掉恒等式 5 = 5，留下a > 5。
- **优化COUNT() 、MIN() 、 MAX()。**min可以通过查找索引树的最左端，max可以查询索引树的最右端。count(*)适用于MYISAM.
- **预估并转换为常数表达式。**当MySQL检测到表达式可以转化为常量的时候，就会一直把该表达式当做常量处理。例如用户自定义变量，只要不发生改变，就一直把他当做常量来处理。
- **覆盖索引扫描。**当索引中包含查询所需要的列时，不需要回表就能查询数据。
- **子查询优化。**MySQL子查询性能及其差，一般需要转为exists，或转为连接查询。
- **提前终止查询。**当发现已经满足查询的条件时，MySQL会立刻停止查询。典型的例子就是limit。
- **等值传播。**如果两个列通过等式关联，则其中一个列的where条件会传播到另一个列上。例如，select * from A left join B on A.age = B.age where A.age > 12;此时，MySQL会知道需要查询B表age > 12的数据。
- **列表IN()的比较。**MySQL将in列表中的值先排序，后通过二分查找的方式判断是否满足条件。

#### (3.4) 数据和索引的统计信息

在服务器层有查询优化器，却没有保存数据和索引的统计信息。统计信息由存储引擎实现，不同的存储引擎可能会存储不同的统计信息，有的引擎根本不存储任何统计信息，例如Archive引擎。

因为服务器层没有任何统计信息，所有MySQL查询优化器在生成查询的执行计划时，需要向存储引擎获取相应的统计信息，优化器根据这些信息来选择一个最优的执行计划。存储引擎向优化器提供的信息包括：每个表或索引有多少个页面、每个表或索引的基数是多少、数据行和索引长度、索引分布信息等。

#### (3.5) MySQL如何执行关联查询

MySQL中“关联”认为任何一个查询都是一次“关联”，并不仅仅是一个查询需要到两个表匹配才叫关联。素以在MySQL中，每一个查询，每一个片段（包括子查询，甚至于单表的SELECT）都可能是关联。

MySQL关联查询的策略很简单：MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在要给表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表的行，返回查询中需要的各个列。

#### (3.6) 执行计划

和很多其他关系数据库不同，MySQL并不会生成查询字节码来执行查询。MySQL生成查询的一颗指令树，然后通过存储引擎执行完成这颗树并返回结果。最终的执行计划包含了重构后查询的所有信息。可以通过show warnings;查看

#### (3.7) 关联查询优化器

MySQL优化器最重要的一部分就是关联查询优化，他决定了多个表关联查询的顺序。多表执行顺序不一定是写sql时的顺序，上边已有举例。

如果优化器给出的并不是最优的关联顺序，这时可以使用STRAIGHT_JOIN关键字重写查询，让优化器按照你认为最优的关联顺序执行——不过老实说，人的判断很难那么精准。绝大多数时候，优化器做出的选择都比普通人的判断更精准。

如果超过N个表的关联，那么需要检查N的阶乘种关联顺序。我们称之为所有可能的执行计划的“搜索空间‘，当搜索空间非常大的时候，优化器选择使用”贪婪“搜索方式查找”最优’的关联顺序。当关联的表超过optimizer_search_depth的限制的时候，就会选择“贪婪”搜索模式了。（贪婪算法）

#### (3.8) 排序优化

无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序。尽量通过索引进行排序。当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数量大则需要使用磁盘，不过MySQL将这个过程统一称为文件排序，即使完全是内存排序不需要任何磁盘文件时也是如此。

MySQL有如下两种排序算法：

a. 两次传输排序(旧版本使用)：读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。需要进行两次传输，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录。这回产生大量的随机IO。

b. 单次传输排序(新版本使用)：先读取查询所需要的所有列，然后在根据给定列进行排序，最后直接返回排序结果。效率更高，但占用内存更大。

如果查询中有LIMIT的话，LIMIT也会在排序之后应用的，所以即使需要返回较少的数据，临时表和需要排序的数据量仍然后非常大。5.6版本有所改进，会先抛弃不满足条件的记录，然后再进行排序。

#### (3.9) 案例

1.  `select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;`
   - 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
   - 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。

**这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。**

2. `select * from t1 order by t1.name`
   - 两次排序：先查询出name，再根据主键id回表查询出所有字段，并返回
   - 一次排序：直接查出所有数据，根据name排序，并返回

####  **(3.10) MySQL查询优化器的局限性：**

##### **(3.10.1) 关联子查询：MySQL的子查询实现非常糟糕**。最糟糕的一类查询是WHERE条件中包含IN()的子查询语句。

1. 因为使用IN()加子查询，性能经常会非常糟，所以通常建议使用EXISTS()等效的改写查询来获取更好的效率。

2. 一般建议使用左外连接(LEFT OUTER JOIN)代替子查询(?)。

##### **(3.10.2) UNION的限制：MySQL无法将限制条件从外层"下推"到内层，这使得原本能够限制部分返回结果的条件无法应用到内层查询的优化上。**

​     例如如果希望UNION的各个子句能够根据LIMIT只去部分结果集，或者希望能够先排好序再合并结果集的话，就需要在UNION的各个子句中分别使用这些语句。

​     (SELECT first_name,last_name FROM sakila.actor ORDER BY last_name) UNION ALL (SELECT first_name ,last_name FROM sakila.customer ORDER BY last_name) LIMIT 20;

​     优化后：

​     (SELECT first_name,last_name FROM sakila.actor ORDER BY last_name LIMIT 20) UNION ALL (SELECT first_name ,last_name FROM sakila.customer ORDER BY last_name LIMIT 20) LIMIT 20;

#####  (3.10.3) 当WHERE子句包含多个复杂条件的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行，有时候会导致性能变差。

##### (3.10.4) 等值查询：某些时候，等值查询会带来一些意想不到额外消耗。例如：有一个非常大的IN()列表，而MySQ优化器发现存在WHERE、ON或者USING的子句。

#####  **(3.10.5) 并行执行：MySQL无法利用多核特性来并行执行查询。**

#####  (3.10.6) 哈希关联：MySQL不支持哈希关联。

##### (3.10.7) 松散索引扫描：MySQL并不支持松散索引扫描，也就无法按照不连续的方式扫描一个索引。通常，MySQL的索引扫描需要先定义一个起点和终点，即使需要的数据只是这段索引中的很少几个，MySQL仍需扫描这段索引中的每一个条目。8.0开始支持松散索引扫描

##### (3.10.8) 最大值和最小值优化：对于MIN()和MAX()查询，MySQL的优化做的并不好。例如：

SELECT MIN(actor_id) FROM sakila.actor WHERE first_name='PENELOPE'

因为first_name上没有索引，所以会进行全表扫描。如果MySQL能够进行主键扫描，那么理论上，当MySQL读到第一个满足条件的记录的时候，就是我们需要的最小值，因为主键是严格按照actor_id大小字段排序的。

**一个曲线优化的办法是移除MIN(),然后使用LIMIT来将查询重写。**

### 4.MySQL根据优化器生成的执行计划，调用存储引擎的API执行查询

**Mysql根据执行计划给出的指令逐步执行**。在此过程中，**有大量的操作需要通过调用存储引擎实现的接口完成**，这些接口即为“handler API”接口。查询中的每一个表由一个handler的实例表示。（实际上，在优化阶段Mysql就为每一个表创建了一个handelr实例，优化器可以根据这些实例的接口获取表的相关信息，如表的所有列名、索引统计信息等）

**存储引擎接口完成例如：** 　　　　　

```sql
mysql> select * from T where ID=10;
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；

2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。

3. **执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。**

4. 至此，这个语句就执行完成了。

 **对于有索引的表**，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的

数据库的慢查询日志中看到一个 rows_examined 的字段 ，表示这个语句执行程序中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的



### 5.将结果返回给客户端

如果查询可以缓存，Mysql在这个阶段也会将结果放到查询缓存中。

mysql服务器处理完最后一个关联查询后，开始生成第一条数据后，就会向客户端不断地发送数据。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足①中所描述的通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送。

---

## （四）一条 UPDATE 语句的执行过程

以一条SQL为例：

```sql
update tb_student A set A.age='19' where A.name=' 张三 ';
```

我们来给张三修改下年龄。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候要记录日志，这就会引入日志模块。MySQL 自带的日志模块式 binlog（归档日志） ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 redo log（重做日志）和 undo log（回滚日志），我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：

- 先查询到张三这一条数据，如果有缓存，也是会用到缓存。
- 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据。InnoDB 引擎把数据保存在内存中，同时记录 redo log，undo log，待事务提交时， redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。
- 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。（二阶段提交）
- 更新完成。

这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?

这是因为最开始 MySQL 并没有 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log和undo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档，主从复制。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log和 undo log 来支持事务的，其中redo log 和 bin log高度相似。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？

- 先写 redo log 直接提交，然后写 binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bin log 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。
- 先写 binlog，然后写 redo log，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。

如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：

- 判断 redo log 是否完整，如果判断是完整的，就立即提交。
- 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。

这样就解决了数据一致性的问题。

---

## （五）总结

- MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。
- 引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。
- SQL 等执行过程分为两类，一类对于查询等过程如下：权限校验 —> 查询缓存 —> 分析器 —> 优化器 —> 权限校验 —> 执行器—> 引擎
- 对于更新等语句执行流程如下：分析器 ----> 权限校验 ----> 执行器 —> 引擎 —> redo log prepare —> binlog —> redo log commit



> 本文参考自：
>
> 1. [谈谈MySQL架构体系](https://www.cnblogs.com/wangjiming/p/10410904.html)
> 2. 《高性能MySQL第三版》
> 3. [[Mysql 一条sql查询语句是如何执行的](https://www.cnblogs.com/jw-yahui/articles/10769563.html)](https://www.cnblogs.com/jw-yahui/articles/10769563.html)
> 4. [MySQL优化原理](https://zhuanlan.zhihu.com/p/60761527)