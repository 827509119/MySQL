# 缓冲池

## 为什么会出现

InnoDB是基于**磁盘**存储的，并将其中的数据按**页的方式**进行管理。因此InnoDB可视为基于磁盘的数据库系统。由于CPU的速度和磁盘IO速度的巨大鸿沟，需要缓冲池来提高数据库的整体性能

## 是什么

缓冲池是主内存中的一个区域，在`InnoDB`访问表和索引数据时会在其中进行 高速缓存。缓冲池允许直接从内存中处理经常使用的数据，从而加快了处理速度。在专用服务器上，通常将多达80％的物理内存分配给缓冲池。

为了提高大容量读取操作的效率，缓冲池被分为多个[页面](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_page)，这些[页面](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_page)可能包含多个行。为了提高缓存管理的效率，缓冲池被实现为页面的链接列表。使用[LRU](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_lru)算法的变体将很少使用的数据从缓存中老化掉 。

知道如何利用缓冲池将经常访问的数据保留在内存中是MySQL优化的重要方面。

## 架构

简要架构图

![1.2.0.InnoDB缓冲池的简要结构.png](../..//mysql-image/1.2.0.InnoDB%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E7%AE%80%E8%A6%81%E7%BB%93%E6%9E%84.png)

## 怎么做的

- 第一次读取数据时，首先从磁盘中读取数据页，并放到(FIX)缓冲池中。
- 再次读取同样的数据时，先看缓冲池中是否有相同的数据页。有则命中，从缓冲池中读取。否则从磁盘读取

## 服务器的内存大小很重要

```
mysql> show variables like 'innodb_buffer_pool_size';
+-------------------------+---------+
| Variable_name           | Value   |
+-------------------------+---------+
| innodb_buffer_pool_size | 8388608 |
+-------------------------+---------+
1 row in set (0.02 sec)
```

## 缓冲池中缓存的数据页类型

- 索引页
- 数据页
- undo页
- 插入缓冲(Insert buffer)
- 自适应哈希索引
- 锁信息
- 数据字典信息(data dictionary)

## 缓冲池实例

### 概念

即缓冲池的个数。每页根据哈希值分配到不同缓冲池实例

###		好处

减少资源竞争、支持更大的并发处理，加快查询速度

### 查看缓冲池实例个数

查看缓冲池实例个数(默认为 1)

```
mysql> show variables like 'innodb_buffer_pool_instances';
+------------------------------+-------+
| Variable_name                | Value |
+------------------------------+-------+
| innodb_buffer_pool_instances | 1     |
+------------------------------+-------+
1 row in set (0.03 sec)
```

​	可通过配置文件修改实例个数

## LRU list

### 传统的LRU

按照英文的直接原义就是Least Recently Used,最近最久未使用。

#### 由来

它是按照一个非常著名的计算机操作系统基础理论得来的：**最近使用的页面数据会在未来一段时期内仍然被使用,已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用**。基于这个思想,会存在一种缓存淘汰机制，每次从内存中找到**最久未使用的数据然后置换出来**，从而存入新的数据！

#### 作用

它的主要衡量指标是**使用的时间**，

(附加指标是**使用的次数**)



在计算机中大量使用了这个机制，它的合理性在于**优先筛选热点数据**，所谓热点数据，就是**最近最多使用的数据**！

#### 特征

- **最新的数据会插入对列前面**
- **访问列表中旧的数据，会使它重新置于列表顶部**

### InnoDB中的LRU

缓冲池中，页的大小也是16KB

#### 与传统LRU特殊的地方

新增了midPoint位置。新读取到的页并没有直接放在LRU列的首部，而是放在距离尾部37%的位置。这个算法称之为**midpoint insertion stategy**。

- 即midPoint在整体列表的 5/8 处

- midpoint之前的是new区域（热数据）

- midpoint之后的数据是不活跃数据，old区域。
- midpoint处，是新子列表的尾部与旧子列表的头相交的边界
- 当InnoDB将页面读入缓冲池时，它首先将其插入中点(旧子列表的头部)。因为它是用户发起的操作(如SQL查询)所需的，或者是InnoDB自动执行的预读操作的一部分，所以这些页面可以被读取。
- 访问旧子列表中的页面会使其变得“年轻”，并将其移动到新子列表的头部。如果由于用户启动的操作需要该页而读取该页，则会立即进行第一次访问，并使该页变得年轻。如果该页是由于预读操作而被读取的，则第一次访问不会立即发生，并且在该页被逐出之前可能根本不会发生。
- 当数据库运行时，缓冲池中未被访问的页通过向列表的尾部移动来“老化”。新子列表和旧子列表中的页面都会随着其他页面变为新页面而老化。旧子列表中的页面也会随着页面插入到中点处而老化。最终，未使用的页面到达旧子列表的尾部并被逐出。

![1.2.1.InnoDB中的LRU](../..//mysql-image/1.2.1.InnoDB%E4%B8%AD%E7%9A%84LRU.png)

#### 查看midpoint

```
mysql> show variables like 'innodb_old_blocks_pct';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_old_blocks_pct | 37    |
+-----------------------+-------+
1 row in set (0.04 sec)
```

- 37：末尾处的37%的位置，即末尾 3/8 的位置

#### 为什么不把最新查到的数据放到首部

例如**索引扫描**或**数据扫描** / **全表扫描**，会使大量的缓冲池中大量的页被刷新出去。然而被扫描到的数据页只是本次操作所需要的，并非热点数据。而真正的热点数据还是从磁盘读取，影响了缓冲池效率。

控制最新数据页放到热点区域的时间，达到这个时间后，就可以把数据放到热点区域。

```
mysql> show variables like 'innodb_old_blocks_time';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| innodb_old_blocks_time | 1000  |
+------------------------+-------+
1 row in set (0.04 sec)
```

- 数据从old转到new，此操作称为page made young
- 数据未从old转到new，此操作称为page not made young

> 若还未理解，可参阅官方文档：[防止缓冲池扫描](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html)

#### 缓冲池可调整的配置

- 理想情况下，您可以将缓冲池的大小设置为尽可能大的值，从而为服务器上的其他进程留出足够的内存来运行，而不需要过多的分页。缓冲池越大，InnoDB就越像内存中的数据库，从磁盘读取数据一次，然后在后续读取期间访问内存中的数据。但并不是越大越好
- 在具有足够内存的64位系统上，您可以将缓冲池拆分为多个部分，以最大限度地减少并发操作之间对内存结构的争用。即增加缓冲池实例
- 您可以将频繁访问的数据保留在内存中，而不考虑会将大量不经常访问的数据引入缓冲池的操作的突然活动高峰。可以调整midpoint的位置。
- 您可以控制如何以及何时执行预读请求，以便在预期很快需要页面的情况下将页面异步预取到缓冲池中。
- 您可以控制何时发生后台刷新，以及是否根据工作负载动态调整刷新速率
- 您可以配置InnoDB如何保留当前的缓冲池状态，以避免服务器重启后过长的预热期

#### 使用InnoDB标准监视器监视缓冲池

`InnoDB`可以使用访问的标准监视器输出， [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/5.7/en/innodb-standard-monitor.html)提供有关缓冲池操作的度量。缓冲池度量标准位于`BUFFER POOL AND MEMORY`“ `InnoDB`标准监视器”输出中的部分，其输出类似于以下内容：

```shell
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 776332
Buffer pool size   131072
Free buffers       124908
Database pages     5720
Old database pages 2071
Modified db pages  910
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.10 youngs/s, 0.00 non-youngs/s
Pages read 197, created 5523, written 5060
0.00 reads/s, 190.89 creates/s, 244.94 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not
0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read
ahead 0.00/s
LRU len: 5720, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
```

下表描述了`InnoDB`标准监视器报告的缓冲池度量 标准

|             名称              | 描述                                                         |
| :---------------------------: | :----------------------------------------------------------- |
| ***Total memory allocated***  | ***为缓冲池分配的总内存（以字节为单位）***                   |
|  Dictionary memory allocated  | 为`InnoDB`数据字典分配的总内存，以字节为单位                 |
|    ***Buffer pool size***     | ***分配给缓冲池的页面总大小***                               |
|      ***Free buffers***       | ***缓冲池空闲列表的页面总大小***                             |
|     ***Database pages***      | ***缓冲池LRU列表的页面总大小***                              |
|   ***Old database pages***    | ***缓冲池旧LRU子列表的页面总大小***                          |
|    ***Modified db pages***    | ***缓冲池中当前修改的页面数***                               |
|         Pending reads         | 等待读入缓冲池的缓冲池页面数                                 |
|      Pending writes LRU       | 从LRU列表的底部开始写入的缓冲池中的旧脏页数                  |
|   Pending writes flush list   | 检查点期间要刷新的缓冲池页面数                               |
|  Pending writes single page   | 缓冲池中暂挂的独立页面写入数                                 |
|       Pages made young        | 缓冲池LRU列表中变年轻的页面总数（已移至“ new ”页面的子列表的开头） |
|     Pages made not young      | 缓冲池LRU列表中没有年轻的页面总数（保留在“ old ”子列表中但没有年轻的页面） |
|        ***youngs/s***         | ***每秒平均访问缓冲池LRU列表中的旧页面所导致的页面年轻***    |
|      ***non-youngs/s***       | ***每秒平均访问缓冲池LRU列表中的旧页面导致的页面不年轻***    |
|          Pages read           | 从缓冲池读取的页面总数                                       |
|         Pages created         | 在缓冲池中创建的页面总数                                     |
|         Pages written         | 从缓冲池写入的页面总数                                       |
|            reads/s            | 每秒平均每秒读取的缓冲池页面数                               |
|           creates/s           | 每秒平均创建的缓冲池页面的每秒数量                           |
|           writes/s            | 每秒平均缓冲池页面写入数                                     |
|  ***Buffer pool hit rate***   | ***从缓冲池内存与磁盘存储读取的页面的缓冲池页面命中率***     |
|    ***young-making rate***    | ***页面访问的平均命中率使页面更年轻***                       |
| ***not (young-making rate)*** | ***页面访问未使页面变年轻的平均命中率***                     |
|       Pages read ahead        | 预读操作的每秒平均数                                         |
| Pages evicted without access  | 每秒从缓冲池访问而未访问的页面的平均值                       |
|       Random read ahead       | 随机预读操作的每秒平均数                                     |
|            LRU len            | 缓冲池LRU列表的页面总大小                                    |
|         unzip_LRU len         | 缓冲池unzip_LRU列表的页面总大小                              |
|            I/O sum            | 最近50秒内访问的缓冲池LRU列表页面的总数                      |
|            I/O cur            | 已访问的缓冲池LRU列表页面的总数                              |
|         I/O unzip sum         | 已访问的缓冲池unzip_LRU列表页面的总数                        |
|         I/O unzip cur         | 已访问的缓冲池unzip_LRU列表页面的总数                        |

- ***youngs/s***
  仅适用于old页。它基于对页面的**访问次数**，而不是页面数量。可以对给定页面进行多次访问，所有这些访问都会被计算在内。如果在没有进行大型扫描的情况下看到非常低的Young/s值，则可能需要减少延迟时间或增加用于旧子列表的缓冲池的百分比。增加百分比会使旧子列表变大，因此该子列表中的页面需要更长时间才能移动到尾部，这会增加再次访问这些页面并使其年轻化的可能性。
- ***non-youngs/s***
  仅适用于旧页。它基于对页面的访问次数，而不是页面数量。可以对给定页面进行多次访问，所有这些访问都会被计算在内。如果在执行大型表格扫描时未看到更高的***non-youngs/s***值(以及更高的***youngs/s***值)，请增加延迟值。
- ***young-making rate***
  该值考虑了对所有缓冲池页面的访问，而不仅仅是对旧子列表中的页面的访问。young-making rate和not-young-making rate通常不等于总缓冲池命中率。旧子列表中的页面命中会导致页面移动到新子列表，而新子列表中的页面命中会导致页面仅在与头部有一定距离时才移动到列表的头部。
- ***not (young-making rate)***
  Not(Young-Making Rate)是由于未满足Innodb_old_block_time定义的延迟，或由于新子列表中的页面命中未导致页面移动到页头而导致页面访问未导致页面年轻的平均命中率。此速率考虑了对所有缓冲池页面的访问，而不仅仅是对旧子列表中的页面的访问。

>  缓冲池[服务器状态变量](https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html)和 [`INNODB_BUFFER_POOL_STATS`](https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-buffer-pool-stats-table.html)表提供了许多与`InnoDB`标准监视器输出中相同的缓冲池度量 标准

#### unzip_LRU

InnoDB从1.0.X开始支持页压缩技术。原本16k的页，可以压缩到2k、4k、8k。因此需要unzip_LRU列来管理，但是注意：LRU list中包含了unzip_LRU

如何给unzip_LRU分配内存：（假设需要从缓冲池中申请4KB大小的内存）

- 检查4KB的unzip_LRU列表，检查是否有可用的空闲页
- 若有，则直接使用
- 否则申请8KB的unzip_LRU页
- 若能申请到页，则拆分成两个4KB页，并存放到unzip_LRU列表
- 如果申请不到，则从LRU列表申请一个16K的页面，拆分成一个8K，两个4k，分别放到对应的unzip_LRU列表中

## Free list

数据库刚启动时，LRU list是空的。Free list是最大的。当需要从缓冲池中分页时，看Free list有空闲页：

- 有则删除Free list的页，加入到LRU list中。维持一个数量平衡
- 否则，根据LRU算法，淘汰LRU末尾的页，省出内存来，分配给新的页

## Flush list

### 脏页（dirty page）

LRU中的数据被修改后，称该页为脏页。因为缓冲池中的数据和磁盘不一致。通过checkPoint技术将脏页刷新到磁盘

- Flush list中的页，即为脏页
- 脏页既存在于LRU列表中，也存在于Flush list中（LRU列表用来管理缓冲池中页的可用性，Flush list脏页刷新到磁盘，两者互不影响）

# log buffer

## 重做日志缓冲(redo log buffer)

### 作用

InnoDB先将redo log刷新到内存中的log buffer中，然后按照一定频率刷新到磁盘中的redo log文件中

### 什么时候将log buffer中的文件刷新到磁盘的redo log中

- Master Thread每秒将redo log从log buffer中的信息刷新到磁盘的redo log中
- 每次事务提交，都会将log buffer刷新到磁盘的redo log
- 当log buffer中的剩余空间< 1/2 时，会刷新一次

## 回滚日志（undo log buffer）

存放undo log，用于事务回滚，保证原子性。

# change buffer

## 简介

更改缓冲区是一种特殊的数据结构，用于在二级索引页不在缓冲池中时缓存对这些页的更改。缓冲的更改可能由插入、更新或删除操作(DML)引起，稍后当其他读取操作将页面加载到缓冲池中时，这些更改会被合并。或满足一定条件时，合并成一次IO，刷新到磁盘上。

![1.2.2.innodb-change-buffer.png](../..//mysql-image/1.2.2.innodb-change-buffer.png)

## 什么时候合并到数据页

1. 数据加载到缓冲池中时：
   与聚集索引不同，**辅助索引通常不是唯一的**，插入到辅助索引的操作是以相对随机的顺序进行的。同样，删除和更新可能会影响不相邻位于索引树中的辅助索引页。稍后，当受影响的页被其他操作读入缓冲池时，合并缓存的更改可避免从磁盘将辅助索引页读入缓冲池所需的大量随机访问I/O。
2. 定期更新到磁盘中：
   在系统大部分空闲时或在缓慢关机期间运行的清除操作会定期将更新的索引页写入磁盘。与立即将每个值写入磁盘相比，清除操作可以更高效地写入一系列索引值的磁盘块。



当有许多受影响的行和大量辅助索引需要更新时，更改缓冲区合并可能需要几个小时。在此期间，磁盘I/O会增加，这可能会导致磁盘绑定查询的速度显著减慢。在提交事务之后，甚至在服务器关闭和重新启动之后，更改缓冲区合并也可能继续发生。

## 在架构中的位置

在内存中，更改缓冲区占用了缓冲池的一部分。在磁盘上，更改缓冲区是SYSTEM表空间的一部分，当数据库服务器关闭时，索引更改将在其中进行缓冲。

![1.2.3.change-buffer位置](../..//mysql-image/1.2.3.change-buffer%E4%BD%8D%E7%BD%AE.jpg)

## 作用

因为它可以减少磁盘读取和写入，所以更改缓冲区功能对于受I/O限制的工作负载最有价值，例如具有大量DML操作(如批量插入)的应用程序。

但是，更改缓冲区占用了缓冲池的一部分，从而减少了可用于缓存数据页的内存。如果工作集几乎可以放入缓冲池，或者如果您的表的辅助索引相对较少，那么禁用更改缓冲可能会很有用。如果工作数据集完全适合缓冲池，则更改缓冲不会带来额外开销，因为它只适用于不在缓冲池中的页。

## 组成部分

### insert buffer

前文以讨论，参见 []()

### delete buffer

将数据标记为删除

### purge buffer

将数据真正的删除

## 参数配置

- **Innodb_CHANGE_BUFFERING**

  您可以使用INNODB_CHANGE_BUFFING配置参数控制InnoDB执行更改缓冲的程度。您可以启用或禁用插入、删除操作(最初将索引记录标记为删除时)和清除操作(物理删除索引记录时)的缓冲。更新操作是INSERT和DELETE的组合。默认Innodb_CHANGE_BUFFERING值为ALL。

  |  参数   |                  含义                  |
  | :-----: | :------------------------------------: |
  |   all   | 默认值：缓冲区插入，删除标记操作和清除 |
  |  none   |            不要缓冲任何操作            |
  | inserts |             缓冲区插入操作             |
  | deletes |           缓冲区删除标记操作           |
  | changes |         缓冲插入和删除标记操作         |
  | purges  |      缓冲在后台发生的物理删除操作      |

  

  ​	您可以[`innodb_change_buffering`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffering)在MySQL选项文件（`my.cnf`或 `my.ini`）中设置 参数，或使用[`SET GLOBAL`](https://dev.mysql.com/doc/refman/5.7/en/set-variable.html) 语句动态更改参数，该 语句需要足够的权限来设置全局系统变量。请参见 [第5.1.8.1节“系统变量特权”](https://dev.mysql.com/doc/refman/5.7/en/system-variable-privileges.html)。更改设置会影响新操作的缓冲；现有缓冲条目的合并不受影响。

  ```mysql
  mysql> show variables like 'Innodb_CHANGE_BUFFERING';
  +-------------------------+-------+
  | Variable_name           | Value |
  +-------------------------+-------+
  | innodb_change_buffering | all   |
  +-------------------------+-------+
  1 row in set (0.03 sec)
  ```

  

- **innodb_change_buffer_max_size**
  允许将更改缓冲区的最大大小配置为缓冲池总大小的百分比，默认为25，最大为50

  ```sql
  mysql> show variables like 'innodb_change_buffer_max_size';
  +-------------------------------+-------+
  | Variable_name                 | Value |
  +-------------------------------+-------+
  | innodb_change_buffer_max_size | 25    |
  +-------------------------------+-------+
  1 row in set (0.03 sec)
  ```

  考虑在具有大量插入、更新和删除活动的MySQL服务器上增加Innodb_change_buffer_max_size，其中更改缓冲区合并没有跟上新的更改缓冲区条目的步伐，从而导致更改缓冲区达到其最大大小限制。

  考虑减少MySQL服务器上用于报告的静态数据的Innodb_change_buffer_max_size，或者如果更改缓冲区消耗了太多与缓冲池共享的内存空间，从而导致页面比预期更早地从缓冲池中过期。

  使用具有代表性的工作负载测试不同设置，以确定最佳配置。Innodb_change_buffer_max_size设置是动态的，它允许在不重新启动服务器的情况下修改设置。

## 监控变更缓冲区

- `InnoDB`标准监视器输出包括更改缓冲区状态信息。要查看监视器数据，请发出该`SHOW ENGINE INNODB STATUS`语句。

  > mysql> SHOW ENGINE INNODB STATUS\G

  更改缓冲区状态信息位于`INSERT BUFFER AND ADAPTIVE HASH INDEX` 标题下， 并显示类似以下内容：

  ```shell
  -------------------------------------
  INSERT BUFFER AND ADAPTIVE HASH INDEX
  -------------------------------------
  Ibuf: size 1, free list len 0, seg size 2, 0 merges
  merged operations:
   insert 0, delete mark 0, delete 0
  discarded operations:
   insert 0, delete mark 0, delete 0
  Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
  13577.57 hash searches/s, 202.47 non-hash searches/s
  ```

  有关更多信息，请参见 [第14.18.3节“ InnoDB标准监视器和锁定监视器输出”](https://dev.mysql.com/doc/refman/5.7/en/innodb-standard-monitor.html)。

-  [`INFORMATION_SCHEMA.INNODB_METRICS`](https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-metrics-table.html) 表提供了在`InnoDB`标准监视器输出中找到的大多数数据点 ，以及其他数据点。要查看更改缓冲区度量标准以及每个度量标准的描述，请发出以下查询：

  ```sql
  mysql> SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE '%ibuf%'\G
  ```

  有关[`INNODB_METRICS`](https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-metrics-table.html)表用法的信息，请参见 [第14.16.6节“ InnoDB INFORMATION_SCHEMA指标表”](https://dev.mysql.com/doc/refman/5.7/en/innodb-information-schema-metrics-table.html)。

-  [`INFORMATION_SCHEMA.INNODB_BUFFER_PAGE`](https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-buffer-page-table.html) 表提供有关缓冲池中每个页面的元数据，包括更改缓冲区索引和更改缓冲区位图页面。更改缓冲区页面由标识 `PAGE_TYPE`。`IBUF_INDEX`是更改缓冲区索引页面`IBUF_BITMAP`的页面类型，并且 是更改缓冲区位图页面的页面类型。

  > 警告
  >
  > 查询该[`INNODB_BUFFER_PAGE`](https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-buffer-page-table.html) 表可能会带来很大的性能开销。为避免影响性能，请重现要在测试实例上调查的问题，然后在测试实例上运行查询。

  

  例如，您可以查询该 [`INNODB_BUFFER_PAGE`](https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-buffer-page-table.html)表以确定缓冲池页面总数中所包含的`IBUF_INDEX`和 的大概数量 `IBUF_BITMAP`。

  ```sql
  mysql> SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
         WHERE PAGE_TYPE LIKE 'IBUF%') AS change_buffer_pages,
         (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) AS total_pages,
         (SELECT ((change_buffer_pages/total_pages)*100))
         AS change_buffer_page_percentage;
  +---------------------+-------------+-------------------------------+
  | change_buffer_pages | total_pages | change_buffer_page_percentage |
  +---------------------+-------------+-------------------------------+
  |                  25 |        8192 |                        0.3052 |
  +---------------------+-------------+-------------------------------+
  ```

  有关该[`INNODB_BUFFER_PAGE`](https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-buffer-page-table.html)表提供的其他数据的信息 ，请参见 [第24.32.1节“ INFORMATION_SCHEMA INNODB_BUFFER_PAGE表”](https://dev.mysql.com/doc/refman/5.7/en/information-schema-innodb-buffer-page-table.html)。有关相关用法信息，请参见 [第14.16.5节“ InnoDB INFORMATION_SCHEMA缓冲池表”](https://dev.mysql.com/doc/refman/5.7/en/innodb-information-schema-buffer-pool-tables.html)。

- [Performance Schema](https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html) 提供更改缓冲区互斥锁等待检测，以进行高级性能监视。要查看更改缓冲区检测，请发出以下查询：

  ```sql
  mysql> SELECT * FROM performance_schema.setup_instruments
         WHERE NAME LIKE '%wait/synch/mutex/innodb/ibuf%';
  +-------------------------------------------------------+---------+-------+
  | NAME                                                  | ENABLED | TIMED |
  +-------------------------------------------------------+---------+-------+
  | wait/synch/mutex/innodb/ibuf_bitmap_mutex             | YES     | YES   |
  | wait/synch/mutex/innodb/ibuf_mutex                    | YES     | YES   |
  | wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex | YES     | YES   |
  +-------------------------------------------------------+---------+-------+
  ```

  有关监视`InnoDB` 互斥锁等待的信息，请参见 [第14.17.2节“使用性能模式监视InnoDB Mutex等待”](https://dev.mysql.com/doc/refman/5.7/en/monitor-innodb-mutex-waits-performance-schema.html)。

## 其他信息

更改缓冲区中缓存的数据类型由INNODB_CHANGE_BUFFING变量控制。您还可以配置最大更改缓冲区大小。

如果索引包含降序索引列或主键包含降序索引列，则辅助索引不支持更改缓冲。

有关更改缓冲区的常见问题的解答，请参阅[第A.16节“ MySQL 5.7 FAQ：InnoDB更改缓冲区”](https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html)。

# 额外的内存池

对一些数据结构本身的存储，会在该池中申请，不够则从缓冲池申请

例如，分配了缓冲池（innodb_buffer_pool）,但是每个缓冲池中的帧缓冲frame buffer和对应缓冲控制的对象，这些对象记录了一些诸如LRU、锁、等待等信息。这个对象所占的内存，就需要从额外空间中申请。

