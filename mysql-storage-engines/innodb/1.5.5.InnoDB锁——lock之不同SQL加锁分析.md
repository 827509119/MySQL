## InnoDB中，由不同的SQL生成的锁

锁定读、更新或删除通常会在SQL语句处理过程中扫描的每个索引记录上设置记录锁。语句中是否有排除该行的条件并不重要。InnoDB不记得确切的位置条件，但只知道哪个索引范围被扫描。这些锁通常是 next-key 锁，它们也会阻塞插入到记录之前的“间隙”中。但是，可以显式禁用间隙锁定，这将导致不使用next-key锁定。事务隔离级别也会影响所设置的锁。

如果在搜索中使用了一个二级索引，并且要设置的索引记录锁是排他的，InnoDB也会检索相应的聚集索引记录并对它们设置锁。

如果没有适合语句的索引，MySQL必须扫描整个表来处理语句，那么**表的每一行都会被锁定**，从而阻塞其他用户对表的所有插入。**创建良好的索引很重要，这样您的查询就不会不必要地扫描很多行，并且减少锁定的行数**。

InnoDB设置的锁类型如下。

- `SELECT....FROM` 是一致读取，读取数据库的快照并且不设置锁，除非事务隔离级别设置为SERIALIZABLE。对于可序列化级别，搜索在遇到的索引记录上设置共享的next-key锁。但是，对于使用惟一索引来搜索惟一行来锁定行的语句，只需要一个索引记录锁。

- `SELECT ... FOR UPDATE` 或 `SELECT ... LOCK IN SHARE MODE`对扫描的行获取锁，对不符合结果集中包含条件的行释放锁(例如，如果它们不满足WHERE子句中给出的条件)。但是，在某些情况下，可能不会立即解锁行，因为在查询执行期间，结果行与其原始源之间的关系丢失了。例如,在一个  UNION 中,从表中扫描（并锁定）的行可能会在评估它们是否符合结果集之前插入到临时表中。在这种情况下，临时表中的行与原始表中的行之间的关系将丢失，并且直到查询执行结束后，行才被解锁。

- `SELECT ... LOCK IN SHARE MODE`在搜索遇到的所有索引记录上设置共享的下一键锁定。但是，对于使用唯一索引锁定行以搜索唯一行的语句，仅需要索引记录锁定。

- `SELECT ... FOR UPDATE`在搜索遇到的每条记录上设置排他的 next-key 锁定。但是，对于使用一些语句搜索唯一索引的固定行，仅需要锁定索引记录。

  `SELECT ... FOR UPDATE`阻止其他会话执行 `SELECT ... LOCK IN SHARE MODE`或读取某些事务隔离级别。一致的读取将忽略读取视图中存在的记录上设置的任何锁定。

- `UPDATE ... WHERE ...`在搜索遇到的每条记录上设置排他的下一键锁定。但是，对于使用一些语句搜索唯一索引的固定行，仅需要索引记录锁定。

- 当UPDATE修改聚集索引记录时，会对受影响的辅助索引记录执行隐式锁。在插入新的辅助索引记录之前和插入新的辅助索引记录之前执行重复的检查扫描时，更新操作还对受影响的辅助索引记录使用共享锁。

- `DELETE FROM ... WHERE ...`在搜索遇到的每条记录上设置排他的下一键锁定。但是，对于使用一些语句搜索唯一索引的固定行，仅需要索引记录锁定。

- `INSERT`在插入的行上设置排他锁。该锁是索引记录锁，不是下一个键锁（即没有间隙锁），并且不会阻止其他会话插入到插入行之前的间隙中。

- `INSERT...ON DUPLICATE KEY UPDATE`与简单`INSERT`的不同之处在于，当发生重复键错误时，将排他锁而不是共享锁放置在要更新的行上。对重复的主键值采用独占索引记录锁。对重复的唯一索引值采用独占NEXT-KEY锁。

- 如果唯一键上没有冲突，则`REPLACE`操作类似于`INSERT`操作。否则，将在要替换的行上放置排他的NEXT-KEY锁。

- INSERT INTO T SELECT...FROM S，在插入到T中的每一行上设置独占索引记录锁(没有间隙锁)。如果事务隔离级别是READ COMMITTED，或者INNODB_LOCKS_UNSAFE_FOR_BINLOG已启用，并且事务隔离级别不是SERIALIZABLE，则InnoDB会将S作为一致读取(无锁)进行搜索。否则，InnoDB会在来自S.InnoDB的行上设置共享的Next-key锁。InnoDB必须在后一种情况下设置锁：在使用基于语句的二进制日志进行前滚恢复期间，每条SQL语句都必须以与最初完全相同的方式执行。

  `CREATE TABLE ... SELECT ...`使用共享的NEXT键锁执行SELECT或作为一致读取执行，如INSERT...SELECT。

  `REPLACE INTO t SELECT ... FROM s WHERE ...`或 `UPDATE t ... WHERE col IN (SELECT ... FROM s ...)`,InnoDB在表s中的行上设置共享的Next-key锁。

- InnoDB在初始化表上指定的AUTO_INCREMENT列时，会在与AUTO_INCREMENT列关联的索引的末尾设置一个独占锁。

  

  innodb_autoinc_lock_mode=0时，InnoDB使用一种特殊的自动-inc表锁模式，当访问自动递增计数器时，锁定被获取并保持到当前SQL语句的末尾(而不是整个事务的末尾)。当AUTO-INC表锁被持有时，其他客户端无法插入到表中。innodb_autoinc_lock_mode=1的“批量插入”也会发生相同的行为。innodb_autoinc_lock_mode=2不使用表级自动锁定。(自增锁)

  

  InnoDB获取之前初始化的AUTO_INCREMENT列的值，而不设置任何锁。

- 如果在表上定义了外键约束，则需要检查约束条件的任何插入、更新或删除都会在检查约束时查看的记录上设置共享记录级锁。InnoDB也会在约束失败的情况下设置这些锁。

- **LOCK TABLE设置了表的锁，但是设置这些锁的是在InnoDB之上的更高层的MySQL层。InnoDB在innodb_table_locks = 1(默认值)和autocommit = 0时知道表锁，而InnoDB上面的MySQL层知道行锁。**

  

  否则，InnoDB的自动死锁检测无法检测到涉及到这些表锁的死锁。另外，因为在本例中较高的MySQL层不知道行级锁，所以有可能在另一个会话当前拥有行级锁的表上获得表锁。然而，这并不危及事务完整性，如14.7.5.2节“死锁检测”中所讨论的。

- 如果innodb_table_locks=1(默认)，那么LOCK TABLE 在每个表上获得两个锁。除了MySQL层上的表锁之外，它还需要InnoDB表锁。4.1.2之前的MySQL版本没有获得InnoDB表锁;旧的行为可以通过设置innodb_table_locks=0来选择。如果没有获得InnoDB表锁，即使表的一些记录被其他事务锁住，锁表也会完成。

- 当事务被提交或中止时，所有由事务持有的InnoDB锁都会被释放。因此，在InnoDB表上以autocommit=1模式调用锁表没有太大意义，因为获得的InnoDB表锁会立即被释放。

- 不能在事务中间锁定其他表，因为 `LOCK TABLES`执行隐式提交和解锁表。