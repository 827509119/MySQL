# latch - 线程锁

## 简介

latch是闩锁，一种轻量级锁。要求锁定的时间必须非常短。若时间长，则性能非常差。**其目的是为了保证并发线程操作临界资源的正确性。通常没有死锁检测**

**通常指的是server层、innodb层的互斥锁和读写锁。**

## **作用**

锁是数据库系统区别与文件系统的一个关键特性。**锁机制用于管理对共享资源的并发访问**。Innodb存储引擎在行级别上对表数据上锁，这固然不错。但是Innodb也会在多个地方使用锁，从而允许多种不同资源提供并发访问。例如，**操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，为了保证一致性，必须有锁的介入，这就是latch锁。**

## **举个例子**

- 例一：当我们在执行select 时，数据先查磁盘上的数据页，放到buffer pool中，多个线程并发访问或者修改这个数据必然需要一个并发控制机制，这个就是latch。
- 例二：
  1. 线程A以读的方式访问共享资源，此时共享资源加上了读锁，若读到数据，马上释放锁
     ![线程A加读锁](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.16.%E7%BA%BF%E7%A8%8BA%E5%8A%A0%E8%AF%BB%E9%94%81.png)
  2. 线程B过来，想要读取共享资源并发现资源被加上读锁，因为读锁共享，可以直接赋予线程B读锁，进而读取资源。
     ![线程B加读锁](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.17.%E7%BA%BF%E7%A8%8BB%E7%94%B3%E8%AF%B7%E5%8A%A0%E8%AF%BB%E9%94%81.jpg)
  3. 线程C过来，想要修改资源，舅要获取写锁，但读写锁冲突，所以获取写锁失败。然后线程C自旋，空占CPU资源（**因为他知道A 和 B很快**，所以执行一段空代码，loop，隔段时间看看 A 和 B 有没有释放锁。若不空占CPU资源，则CPU看这个线程闲着，就踢出CPU），若始终得不到锁，则进入sleep状态，退出CPU，等待唤醒。
     ![线程C加写锁](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.18.%E7%BA%BF%E7%A8%8BC%E7%94%B3%E8%AF%B7%E5%8A%A0%E5%86%99%E9%94%81.jpg)

数据库要访问的数据必须先存在缓存中，而缓存一般比磁盘空间要小，数据缓冲使用hash表来记录数据页是否在内存中。在MySQL中对应的RW-Latch在errlog中说的很清楚，该RW-Latch是在buf0sea.cc的658行创建的RW-Latch。

## 如何查看

```mysql
mysql> show engine innodb status;

----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 199098
OS WAIT ARRAY INFO: signal count 153659
RW-shared spins 0, rounds 205663, OS waits 94452
RW-excl spins 0, rounds 744093, OS waits 14037
RW-sx spins 13520, rounds 231541, OS waits 2348
Spin rounds per wait: 205663.00 RW-shared, 744093.00 RW-excl, 17.13 RW-sx
```

- rounds的意思是每次询问旋转的参数
- os waits：表示sleep，当突然增长比较快的时候，说明latch争用比较严重
- rw-shared spin 的次数
- rw-excl  spin的次数

## 分类

### (一) mutex

互斥量；有时候有些资源需要共享和并发，但是又不是分频繁，所以**向操作系统申请一个mutex**，mutex都是排他的。

Linux中提供一把**互斥锁mutex**（**也称之为互斥量**）。**遇到锁竞争，有的mutex会自旋，有的会直接阻塞。**

> **InnoDB中，不同场景需要的mutex 是不一样的, 比如buffer pool 上面的page 的mutex 希望的就是一直spin. 有些mutex 其实则是希望立刻就进入等待, 只用使用这些mutex 的使用者知道接下来哪一个策略更合适**，但目前为止在并未实现。可参考[InnoDB mutex 实现分析](http://mysql.taobao.org/monthly/2020/03/05/)

每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。

但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。

![1.5.2.mutex示意图](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.2.mutex%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

但，**应注意：同一时刻，只能有一个线程持有该锁**。

当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。**C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱**。

所以，**互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。**
**因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。**

#### **加锁与解锁**

> 注意：以下 lock 并非 “lock锁”，因为 latch 本身就是一个锁，所以会有加锁解锁机制。不要与 基于事务的Lock 混淆

- **lock与unlock：**

  lock尝试加锁，如果加锁不成功，**线程阻塞**，阻塞到持有该互斥量的其他线程解锁为止。

  unlock主动解锁函数，**同时将阻塞在该锁上的所有线程**，至于哪个线程先被唤醒，取决于优先级、调度。例如：T1 T2 T3 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2 T3 T4均被唤醒，并自动再次尝试加锁。

  可假想mutex锁 init成功初值为1。 lock 功能是将mutex--。 unlock将mutex++

- **lock与trylock：**

  lock加锁失败**会阻塞**，等待锁释放。

  trylock加锁失败直接返回错误号（如：EBUSY），**不阻塞，自旋**。

#### **1. mutex in Server**

除了win之外都采用了`glibc`中的`pthread_mutex_t`，如server层中`LOCK_status`, `LOCK_thd_remove`等

- 方法一：

  ```
  (gdb) p LOCK_status
  $11 = {m_mutex = {__data = {__lock = 2, __count = 0, __owner = 102188, __nusers = 1, __kind = 3, __spins = 85, __list = {__prev = 0x0, __next = 0x0}},
      __size = "\002\000\000\000\000\000\000\000,\217\001\000\001\000\000\000\003\000\000\000U", '\000' <repeats 18 times>, __align = 2}, m_psi = 0x0}
  ```

  这里的`__owner`为core中`LWP XXXX`后的值

  ![1.5.3._owner拥有者图示](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.3._owner%E6%8B%A5%E6%9C%89%E8%80%85%E5%9B%BE%E7%A4%BA.png)

- 方法二：
  切换到`__lll_lock_wait`这样`frame`上，对于64 bit系统：

  ```
  (gdb) p *(pthread_mutex_t*)$rdi
  $12 = {__data = {__lock = 2, __count = 0, __owner = 102188, __nusers = 1, __kind = 3, __spins = 85, __list = {__prev = 0x0, __next = 0x0}},
    __size = "\002\000\000\000\000\000\000\000,\217\001\000\001\000\000\000\003\000\000\000U", '\000' <repeats 18 times>, __align = 2}
  ```

  同样能找到`pthread_mutex`中的`owner`

#### **2. mutex in InnoDB**

***`innodb`层最常见的`mutex` `latch`为`PolicyMutex<TTASEventMutex<GenericPolicy>`，这种锁和`rw_lock_t`一样是spin锁，当拿不到锁时会尝试自旋一段时间:***

```
spin_and_try_lock(...)
{
  ...
  for (;;) {
    // 尝试自旋，自旋的时间同样由由`innodb_sync_spin_loops`、`innodb_spin_wait_delay`决定
    is_free(max_spins, max_delay, n_spins) {
      if (try_lock()) {
        break;
      } else {
        ...
      }
    } else {
      max_spins = n_spins + step;
    }
    os_thread_yield();
    ...
  }
  ...
}
```

这种锁一般持有时间很短，在`innodb`上采用`atomic`来实现，目前没有好的办法排查加这种锁的线程和位置，但是`core`文件仍然提供了许多有用的信息：

```
(gdb) p *this
$19 = {m_impl = {m_lock_word = 0, m_waiters = 0, m_event = 0x7f5faea51358, m_policy = {m_count = {m_spins = 0, m_waits = 0, m_calls = 0, m_enabled = false}, m_id = LATCH_ID_FLUSH_LIST}}, m_ptr = 0x0}
```

`m_lock_word`对应值的含义：

```
/** Mutex is free */
 MUTEX_STATE_UNLOCKED = 0
 
 /** Mutex is acquired by some thread. */
 MUTEX_STATE_LOCKED = 1
 
 /** Mutex is contended and there are threads waiting on the lock. */
 MUTEX_STATE_WAITERS = 2
```

另外`m_waiters = 0`并不意味着目前没有等锁的线程，如果拿该锁的线程都处于自旋状态，`m_waiters`仍然等于`0`

如果有线程持有该锁，想要排查，同样可以用`pt-pmp`排查：

1. 排除堆栈重复次数超过`1`次的所有线程
2. 排除阻塞在获取该锁的所有线程
3. 排除带有`poll()`、`epoll_wait`的堆栈
4. 带有`pthread_cond_wait`的堆栈持有该锁的可能性也比较低
5. 阻塞在`__lll_lock_wait`的线程持有该锁的可能性比较低，持有innodb层mutex锁的线程阻塞在server层锁的可能性比较低

持有该锁的堆栈只可能出现`1`次，排查持有者需要根据具体情况分析

###  (二)RW-LATCH

***读写锁。共享读写，排他写锁。***

#### 1. RW_lock in Server

除了`win`之外都采用了`glibc`中的`pthread_rwlock_t`

```
(gdb) frame 1
#1  0x0000000000ec2059 in native_rw_wrlock (rwp=0x7f5faf078298) at /home/admin/129_20200113173827294_121311408_code/rpm_workspace/include/thr_rwlock.h:101
101     /home/admin/129_20200113173827294_121311408_code/rpm_workspace/include/thr_rwlock.h: No such file or directory.
(gdb) p rwp
$13 = (native_rw_lock_t *) 0x7f5faf078298
(gdb) p *rwp
$14 = {__data = {__lock = 0, __nr_readers = 0, __readers_wakeup = 0, __writer_wakeup = 0, __nr_readers_queued = 0, __nr_writers_queued = 15, __writer = 61789, __shared = 0, __pad1 = 0, __pad2 = 0, __flags = 0},
  __size = '\000' <repeats 20 times>, "\017\000\000\000]\361", '\000' <repeats 29 times>, __align = 0}
```

- `__nr_readers`: 当前有多少个线程持有读锁
- `__nr_readers_queued`: 当前有多少个线程在等待获得读锁
- `__nr_writers_queued`: 当前有多少个线程在等待获得写锁，PS：写锁的优先级比读锁要高。即如果线程想获得读锁，当发现`__nr_writers_queued`不为`0`时，哪怕当前没有人获得写锁，也会将自己阻塞。目的是防止写锁饿死。
- `__writer`：写锁持有者的`LWP #`

如果有线程持有写锁，通过`__writer`很容易找到该线程；如果有线程持有了读锁，持有读锁的线程和位置可能有多个，则可以尝试通过下述方法进行排查：

```
$ gdb <binary> <coredump> -ex "thread apply all bt" -ex "quit" > core.bt
$ pt-pmp core.bt > pt-pmp.log
```

在`pt-pmp.log`中，排除：

1. 出现频次高于`__nr_readers`的堆栈
2. 阻塞在获取该锁的写锁的所有线程
3. 带有`poll()`、`epoll_wait`的堆栈
4. 带有`pthread_cond_wait`的堆栈持有该读锁的可能性也比较低

由于持有读锁的线程和位置可能有多个，排查读锁持有者需要根据具体情况分析。

#### 2. RW_lock in InnoDB

innodb层的读写锁，如`dict_operation_lock`、`btr_search_latches`，`checkpoint_lock`等

```
(gdb) p *dict_operation_lock
$16 = {lock_word = -2, waiters = 1, recursive = true, sx_recursive = 0, writer_is_wait_ex = false, writer_thread = 140042102085376, event = 0x7f5faf05aab8, wait_ex_event = 0x7f5faf05ab58,
  cfile_name = 0x162c6d8 "/home/admin/129_20200113173827294_121311408_code/rpm_workspace/storage/innobase/dict/dict0dict.cc",
  last_s_file_name = 0x1619240 "/home/admin/129_20200113173827294_121311408_code/rpm_workspace/storage/innobase/row/row0undo.cc",
  last_x_file_name = 0x1614968 "/home/admin/129_20200113173827294_121311408_code/rpm_workspace/storage/innobase/row/row0mysql.cc", cline = 1186, is_block_lock = 0, last_s_line = 322, last_x_line = 4290, count_os_wait = 20559,
  list = {prev = 0x7f5faea79150, next = 0x7f5faea87428}, pfs_psi = 0x0}
```

- 当`lock_word = X_LOCK_DECR`时，意味着当前锁没有被任何人持有
- 当`X_LOCK_HALF_DECR < lock_word < X_LOCK_DECR`，意味着当前有一个或多个线程持有读锁
- 当`0 < lock_word <= X_LOCK_HALF_DECR`时，意味着当前有一个线程持有`SX`锁，有0个（`lock_word = X_LOCK_HALF_DECR`）或多个线程（`lock_word < X_LOCK_HALF_DECR`）持有读锁
- 当`lock_word = 0`时表示没有线程持有读锁，下一个写锁已经加上（并已获得）
- 当`lock_word < 0`是表示有线程持有一个或多个读锁，下一个写锁已经预定（仍未获得，在等待读锁释放）

1. ***这里`SX`锁是一种介于`X`锁和`S`锁的锁，它阻塞`X`、`SX`锁，但不阻塞`S`锁，类似于 IS锁、IX锁***
2. 为了更好理解`lock_word`的含义，下面简单介绍`rw_lock_t`获取写锁的操作

```
// lock_word 的初始值，意味着最多允许0x20000000个读锁同时持有
#define X_LOCK_DECR     0x20000000
// 当上SX锁时，会尝试将lock_word减少X_LOCK_HALF_DECR
#define X_LOCK_HALF_DECR    0x10000000

rw_lock_x_lock_low(rw_lock_t*  lock, ulint pass, const char* file_name, ulint line) {

  // 如果lock_word>X_LOCK_HALF_DECR，尝试将lock_word减少X_LOCK_DECR
  // 如果成功，则至少预定自己为下一个写锁的持有者，返回true，否则返回false
  if (rw_lock_lock_word_decr(lock, X_LOCK_DECR, X_LOCK_HALF_DECR)) {
  
    // 预定自己为下一个写锁持有者，此时lock_word<=0，last_x_file_name:last_x_line 为上一个写锁持有者的上锁位置
    // 将自己的线程标识写入writer_thread，
    rw_lock_set_writer_id_and_recursion_flag(lock, !pass);)

    // 如果lock_word<0，说明有线程持有读锁，必须等待读锁释放
    // 阻塞直到 lock_word==0, 
    rw_lock_x_lock_wait(lock, pass, 0, file_name, line);

  } else {
    ......
  }
  
  // 成功获得写锁，last_x_file_name:last_x_line指向加锁的位置
  lock->last_x_file_name = file_name;
  lock->last_x_line = (unsigned int) line;

  return true;
}
```

再回到上述的例子：

- `lock_word=-2`，说明这里有两个线程持有了读锁，从`last_s_file_name` : `last_s_line` 可以看到加读锁的位置；
- 同时，下一个写锁已经预定，预定者由`writer_thread`指明；
- 但是，`last_x_file_name` : `last_x_line` 并不是预订者的位置，因为此时写锁还没有真正持有
- `writer_thread`指明了持有或即将持有写锁的线程id，将其转成16进制可以在堆栈中搜出：

![1.5.4.查看持有或即将持有写锁的线程id](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.4.%E6%9F%A5%E7%9C%8B%E6%8C%81%E6%9C%89%E6%88%96%E5%8D%B3%E5%B0%86%E6%8C%81%E6%9C%89%E5%86%99%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8Bid.png)

另外：

- ***如果拿不到锁，线程会尝试自旋一段时间，如果自旋后还是拿不到锁，则让出处理器***
- ***自旋的时间由`innodb`参数`innodb_sync_spin_loops`、`innodb_spin_wait_delay`决定***
- ***如果发现所有的拿锁的线程都处于自旋状态，则可以尝试减少`innodb_sync_spin_loops`、`innodb_spin_wait_delay`***

> 引自：
>
> 1. [互斥锁](https://blog.csdn.net/qq_39736982/article/details/82348672)
> 2. [[MYSQL中的LATCH(闩锁)详解)](https://www.cnblogs.com/data-zhang/p/6971718.html)
> 3. [阿里数据库内核月报——latch持有锁分析](http://mysql.taobao.org/monthly/2020/03/07/)

## **latch争用发生的原因**

1. 内存访问太频繁（不停地找）
2. 缓冲池太大。数据块太多（被持有的几率太大）

## **如何降低latch争用**

1. 优化sql，降低对内存读的数量——效果比较明显
2. 增加缓冲池instances的数量，分担压力
3. 适当缩小缓冲池大小，但一般不建议。

## InnoDB Buffer Pool并发控制加锁过程

> [InnoDB Buffer Pool并发控制加锁过程](http://mysql.taobao.org/monthly/2020/05/06/)

---

# Lock - 事务锁

## 与 latch 的区别

lock对象是事务，用来锁定的是数据库中的对象，如表、行、页。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。

## InnoDB中B+树的层次结构——对这些结构加事务锁

首先了解一下数据是怎么存放的，他的一个层次结构，方便理解



![1.5.8.InnoDB中B+树的层次结构](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.8.InnoDB%E4%B8%ADB%2B%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg)

## 加锁原则

二阶段加锁原则

- 加锁阶段
- 解锁阶段

加锁解锁互不相交，各司其职

![1.5.6.二阶段加锁原则.jpg](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.6.%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81%E5%8E%9F%E5%88%99.jpg)

## 锁的分类

### 表级锁

#### InnoDB什么时候对表加S锁？

5.6中在线DDL，已不再加S锁；以前的一些操作如add index、alter table等会加S锁

#### InnoDB不会对表加X锁

InnoDB不会对表加排他X锁，平常遇到的锁表，是把所有记录锁住，把所有间隙锁住，造成表锁的假象

#### 意向锁

InnoDB支持多粒度锁，允许行锁和表锁共存。

##### 分类

- **意向共享读锁 / IS锁**
  	表示事务打算对表中的各个行设置共享读锁。
    	select *** lock in share mode
- **意向排他写锁 / IX锁**
  	表示事务打算对表中的各个行设置排他写锁。
    	select *** for update

##### 意向锁协议
- 事务在获得表中某行上的共享锁之前，必须先获得表上的IS锁或更强的锁。
- 在事务可以获得表中某一行上的排他锁之前，它必须首先获得表上的IX锁。

##### 锁的兼容性

如果与现有锁兼容，则将锁授予请求事务，但如果与现有锁冲突，则不授予该事务。事务将一直等待，直到有冲突的现有锁被释放。如果一个锁请求与一个现有的锁冲突，并且不能被授予，因为这会导致死锁，那么就会发生错误。



![1.5.7.表级锁的兼容性](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.7.%E8%A1%A8%E7%BA%A7%E9%94%81%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7.png)

可以发现一些规律

- 写锁必排他
- 除写锁外，其他同类型的互相兼容
- 只要是意向锁就兼容
- 只要是读锁，就兼容

##### 怎么看加了意向锁

1. 开启Innodb监控器
2. SHOW ENGINE INNODB STATUS

```mysql
# 开启innodb监控器
mysql> SET GLOBAL innodb_status_output=ON;
1 row in set (0.01 sec)

# 开启innodb锁定监控器
mysql> SET GLOBAL innodb_status_output_locks=ON;
1 row in set (0.01 sec)

# 关闭自动提交 => 手动开启关闭事务
mysql> set autocommit = 0;
1 row in set (0.01 sec)

# 查询 user_age=11 的数据，并加写锁,其中，user_age 为单列辅助索引
mysql> select * from user2 where user_age = 11 for update;
。。。数据内容省略
2107 rows in set (0.01 sec)

mysql> show engine innodb status;
------------
TRANSACTIONS
------------
Trx id counter 1551642
Purge done for trxs n:o < 0 undo n:o < 0 state: running but idle
History list length 0
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 283571429645824, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 283571429644952, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 1551641, ACTIVE 14 sec
129 lock struct(s), heap size 24784, 4216 row lock(s)
MySQL thread id 2, OS thread handle 22756, query id 152 localhost ::1 root starting
show engine innodb status
TABLE LOCK table `testmybatis`.`user2` trx id 1551641 lock mode IX
RECORD LOCKS space id 379 page no 25 n bits 1480 index idx_user_age of table `testmybatis`.`user2` trx id 1551641 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 1; hex 8b; asc  ;;
 1: len 4; hex 800035b4; asc   5 ;;

Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 1; hex 8b; asc  ;;
 1: len 4; hex 800035b8; asc   5 ;;
```

- TABLE LOCK table `testmybatis`.`user2` trx id 1551641 lock mode IX，
  解释：`testmybatis`.`user2`被事务id为`1551641`的事务加上表锁——IX锁
- RECORD LOCKS space id 379 page no 25 n bits 1480 index idx_user_age of table `testmybatis`.`user2` trx id 1551641 lock_mode X
  解释：`testmybatis`.`user2`表中的索引 `idx_user_age`被事务id为`1551641`的事务加上记录锁——X锁。索引的space id为`379`，page no为`25`
- 此案例中，展示了 意向锁 IX，排他写锁 X，记录锁 Record lock

##### 意向锁的作用

>  mysql官网上对于意向锁的解释中有这么一句话
> “The main purpose of IX and IS locks is to show that someone is locking a row, or going to lock a row in the table.”
> 加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。
>
> 那么，意向锁的作用就是“表明”加锁的意图，可是为什么要表明这个 意图呢？
>
> 如果仅仅锁定一行仅仅需要加一个锁，那么就直接加锁就好了，这里要表明加锁意图的原因是因为要锁定一行不仅仅是要加一个锁，而是要做一系列操作吗？

> 引用其他地方的回答[意向锁的作用](https://www.zhihu.com/question/51513268)  
>
> 我最近也在看这个，我说一下我的理解
>
> 1. 在mysql中有表锁，LOCK TABLE my_tabl_name READ;  用读锁锁表，会阻塞其他事务修改表数据。LOCK TABLE my_table_name write; 用写锁锁表，会阻塞其他事务读和写。
> 2. Innodb引擎又支持行锁，行锁分为共享锁，一个事务对一行的共享只读锁。排它锁，一个事务对一行的排他读写锁。
> 3. 这两中类型的锁共存的问题考虑这个例子：
>    事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请表中全部数据的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。
>    数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。
>
> 数据库要怎么判断这个冲突呢？
>
> - step1：判断表是否已被其他事务用表锁锁表
> - step2：判断表中的每一行是否已被行锁锁住。
>
> 注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。
>
> 于是就有了意向锁。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。在意向锁存在的情况下，上面的判断可以改成
>
> - step1：不变
> - step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。
>
> 注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。
>
> 总结：为了实现多粒度锁机制（白话：为了表锁和行锁都能用）

#### 自增自动上锁 / AUTO-INC Locks

##### 作用在哪里

自增列 —— AUTO_INCREMENT

当一张表的某个字段是自增列时，innodb会在该索引的末位加一个排它锁。为了访问这个自增的数值，需要加一个表级锁，不过这个表级锁的持续时间只有当前sql，而不是整个事务，即当前sql执行完，该表级锁就释放了。其他session无法在这个表级锁持有时插入任何记录。

##### InnoDB中的AUTO_INCREMENT处理

InnoDB提供了一种可配置的锁定机制，可以显著提高SQL语句的可伸缩性和性能，这些SQL语句将行添加到具有AUTO_INCREMENT列的表中。要对InnoDB表使用AUTO_INCREMENT机制，必须将AUTO_INCREMENT列定义为索引的一部分，以便可以在表上执行与索引SELECT MAX(Ai_Coll)查找等效的操作，以获得最大列值。通常，这是通过使列成为某些表索引的第一列来实现的。

###### InnoDB自动增量锁定模式

本节介绍用于生成自动增量值的AUTO_INCREMENT锁定模式的行为，以及每个锁定模式如何影响复制。自动增量锁定模式在启动时使用Innodb_autoinc_lock_mode配置参数进行配置。

以下术语用于描述 innodb_autoinc_lock_mode设置：

- “类似插入”语句
  在表中生成新行的所有语句，包括INSERT, INSERT ... SELECT, REPLACE, REPLACE ... SELECT, 和 LOAD DATA。包括“简单插入”、“批量插入”和“混合模式”插入。

- “简单插入”
  可以预先确定要插入的行数的语句(最初处理语句时)。这包括单行和多行INSERT和REPLACE语句，这些语句没有嵌套子查询，但没有INSERT ... ON DUPLICATE KEY UPDATE 这类语句。

- “批量插入”
  预先不知道要插入的行数(以及所需的自动增量值的数量)的语句。这包括INSERT ... SELECT, REPLACE ... SELECT, and LOAD DATA 语句，但不是普通INSERT语句。InnoDB在处理每行时一次为AUTO_INCREMENT列分配一个新值。

- “混合模式”
  这些是“简单INSERT”语句，它们为部分(但不是全部)新行指定自动增量值。下面是一个示例，其中C1是表T1的AUTO_INCREMENT列：

  ```sql
  INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
  ```

  这种模式就是  INSERT ... ON DUPLICATE KEY UPDATE ，在最坏的情况下，实际上是先插入后更新，其中AUTO_INCREMENT列的分配值可能在更新阶段使用，也可能不使用。

  

  Innodb_autoinc_lock_mode配置参数有三种可能的设置。设置为0、1或2，分别表示“传统”、“连续”或“交错”锁定模式。

  - **`innodb_autoinc_lock_mode = 0` (“traditional” lock mode)——运行时分配自增值**

    传统的锁定模式提供的行为与MySQL5.1中引入Innodb_autoinc_lock_mode配置参数之前存在的行为相同。提供传统锁模式选项是为了实现向后兼容性、性能测试，以及解决“混合模式插入”的问题，因为语义可能存在差异。

    在这种锁模式下，所有“类似插入”的语句都会获得一个**特殊的表级AUTO-INC锁，用于插入到具有AUTO_INCREMENT列的表中。此锁通常保持在语句的末尾(而不是事务的末尾)**，以确保以可预测和可重复的顺序为给定的INSERT语句分配自动增量值，并确保由任何给定语句分配的自动增量值是连续的。

    **在基于语句的复制中，这意味着在副本服务器上复制SQL语句时，自动增量列使用的值与源服务器上的值相同。执行多个INSERT语句的结果是确定性的，并且副本复制的数据与源上的数据相同。如果由多个INSERT语句生成的自动增量值是交错的，则两个并发INSERT语句的结果将是不确定的，并且不能使用基于语句的复制可靠地传播到副本服务器。**
    例如：

    ```sql
    CREATE TABLE t1 (
      c1 INT(11) NOT NULL AUTO_INCREMENT,
      c2 VARCHAR(10) DEFAULT NULL,
      PRIMARY KEY (c1)
    ) ENGINE=InnoDB;
    ```

    假设有两个事务正在运行，每个事务都向具有AUTO_INCREMENT列的表中插入行。一个事务正在使用INSERT...SELECT插入1000行的语句，另一个是使用插入一行的简单INSERT语句：

    ```shell
    Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
    Tx2: INSERT INTO t1 (c2) VALUES ('xxx');	
    ```

    InnoDB不能预先知道从TX1的INSERT语句中的SELECT中检索了多少行，并且随着语句的执行，它一次分配一个自动增量值。使用表级锁(一直保持到语句末尾)，一次只能执行一条引用表T1的INSERT语句，并且不同语句生成的自动增量数字不会交错。**TX1生成的自动增量值在INSERT...SELECT语句中是连续的，并且Tx2中的INSERT语句使用的(单个)自动增量值小于或大于TX1使用的所有值，这取决于先执行哪条语句。**

    

    只要SQL语句在从二进制日志重放时(使用基于语句的复制或在恢复场景中)以相同的顺序执行，结果就会与tx1和tx2第一次运行时的结果相同。因此，**在语句结束之前一直持有的表级锁使得使用自动增量的INSERT语句可以安全地与基于语句的复制一起使用。但是，当多个事务同时执行INSERT语句时，这些表级锁会限制并发性和可伸缩性。**

    在前面的示例中，如果没有表级锁，则用于Tx2中INSERT的自动增量列的值**完全取决于语句执行的时间**。如果Tx2的插入在TX1的插入运行时执行(而不是在其开始之前或完成之后)，则由两个INSERT语句分配的特定自动增量值是不确定的，并且可能因运行而异。

    **在连续锁模式下，InnoDB可以避免对预先知道行数的“简单INSERT”语句使用表级AUTO-INC锁，并且仍然可以保证基于语句的复制的确定性执行和安全性。**

    **如果在恢复或复制过程中没有使用二进制日志来重放SQL语句，则可以使用交错锁模式消除所有表级AUTO-INC锁的使用，以获得更好的并发性和性能，代价是允许语句分配的自动增量编号之间存在差距，并且可能会使并发执行的语句分配的编号交错。**

  - **`innodb_autoinc_lock_mode = 1` (“consecutive” lock mode)——开始前就获得自增值**
    这是默认的锁定模式。在此模式下，“大容量插入”使用特殊的**AUTO-INC表级锁，并将其保持到语句末尾**。这适用于所有 INSERT ... SELECT, REPLACE ... SELECT, and LOAD DATA语句。一次只能执行一条持有AUTO-INC锁的语句。**如果大容量插入操作的源表与目标表不同，则在从源表选择的第一行上获得共享锁之后，将对目标表执行AUTO-INC锁。如果大容量插入操作的源和目标是同一个表，则在对所有选定行进行共享锁定之后，将采用AUTO-INC锁定。**

    

    **“简单插入”(预先知道要插入的行数)通过在互斥锁(轻量级锁)的控制下获得所需数量的自动增量值来避免表级AUTO-INC锁，该互斥锁仅在分配过程期间(而不是在语句完成之前)保持。**除非另一个事务持有AUTO-INC锁，否则不使用表级AUTO-INC锁。如果另一个事务持有AUTO-INC锁，则“简单插入”将等待AUTO-INC锁，就好像它是“大容量插入”一样。

    

    这种锁定模式确保在存在INSERT语句的情况下(其中行数事先不知道，并且在语句执行过程中分配自动增量编号)，由任何“类似INSERT”语句分配的所有自动增量值都是连续的，并且操作对于基于语句的复制是安全的。

    

    简而言之，这种锁定模式显著提高了可伸缩性，同时可以安全地用于基于语句的复制。此外，与“传统”锁定模式一样，任何给定语句分配的自动递增数字都是连续的。与“传统”模式相比，任何使用自动递增的语句在语义上都没有变化，只有一个重要的例外。

    例外情况是“混合模式插入”，在这种情况下，用户为多行“简单插入”中的某些行(但不是所有行)的AUTO_INCREMENT列提供显式值。对于此类插入，InnoDB分配的自动增量值多于要插入的行数。但是，自动分配的所有值都是连续生成的(因此高于最近执行的前一条语句生成的自动增量值)。“多余的”号码就会丢失。

  - **`innodb_autoinc_lock_mode = 2` (“interleaved” lock mode)——运行时交错生成自增值**
    在这种锁模式下，没有“类似插入”的语句使用表级AUTO-INC锁，并且可以同时执行多条语句。这是最快和最具伸缩性的锁定模式，但是当从二进制日志重放SQL语句时使用基于语句的复制或恢复方案时，这是不安全的。

    

    在此锁定模式下，保证自动增量值在所有并发执行的“类似插入”语句中唯一且单调递增。但是，因为多个语句可以同时生成数字(即，跨语句交错分配数字)，所以任何给定语句为插入的行生成的值可能不是连续的。

    

    如果执行的唯一语句是“简单插入”，其中预先知道要插入的行数，则除了“混合模式插入”之外，为单个语句生成的行数没有差距。但是，当执行“大容量插入”时，由任何给定语句分配的自动增量值中可能存在间隙。

  ```sql
  mysql> show variables like 'innodb_autoinc_lock_mode';
  +--------------------------+-------+
  | Variable_name            | Value |
  +--------------------------+-------+
  | innodb_autoinc_lock_mode | 1     |
  +--------------------------+-------+
  1 row in set (0.06 sec)
  ```

  下边会详细解释，并有案例。

###### InnoDB AUTO_INCREMENT锁定模式用法含义

- 在复制中使用自动增量
  如果使用的是基于语句的复制，请设置 [`innodb_autoinc_lock_mode`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode)为0或1，并在源及其副本上使用相同的值。如果您使用[`innodb_autoinc_lock_mode`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode)= 2（“ interleaved ”）或源和副本不使用相同锁定模式的配置，则不能确保副本上的自动增量值 与源上的相同。

  如果使用基于行的复制或混合格式的复制，则所有自动增量锁模式都是安全的，因为基于行的复制对SQL语句的执行顺序不敏感(并且混合格式对基于语句的复制不安全的任何语句都使用基于行的复制)。

- “ 丢失 ”的自动增量值和序列间隔
  在所有锁定模式（0、1和2）下，如果生成自动增量值的事务回滚，则这些自动增量值将“ 丢失 ”。为自动增量列生成值后，将无法回滚该值，无论是否 完成“ 类似INSERT ”语句以及是否回滚包含的事务。这种丢失的值不会重复使用。因此，在`AUTO_INCREMENT`表的列中存储的值中可能存在间隙 。

- 为`AUTO_INCREMENT`列 指定NULL或0
  在所有锁定模式（0、1和2）中，如果用户为中的`AUTO_INCREMENT`列 指定NULL或0，InnoDB视为未指定值，并为其生成新值

- 为该`AUTO_INCREMENT`列 分配一个负值
  在所有锁定模式（0、1和2）中，如果为`AUTO_INCREMENT` 列分配负值，则不会定义自动增量机制的行为

- 如果该`AUTO_INCREMENT`值变得大于指定整数类型的最大整数
  在所有锁定模式（0、1和2）中，如果该值变得大于可以以指定整数类型存储的最大整数，则不会定义自动递增机制的行为。会报错

- “ 批量插入 ”的 自动增量值的缺口当Innodb_autoinc_lock_mode设置为0(“传统”)或1(“连续”)时，任何给定语句生成的自动增量值都是连续的，没有间隙，因为表级AUTO-INC锁一直保持到语句结束，一次只能执行一条这样的语句。

  当Innodb_autoinc_lock_mode设置为2(“交错”)时，“批量插入”生成的自动增量值中可能存在间隙，但只有在并发执行“类插入”语句的情况下。

  **对于锁定模式1或2，连续语句之间可能会出现间隙，因为对于批量插入，可能不知道每个语句所需的自动增量值的确切数量，并且可能高估。**

- 由“ 混合模式插入 ”分配的自动增量值
  考虑一个“ 混合模式插入 ”，其中 “ 简单插入 ”指定一些（但不是全部）结果行的自动增量值。这样的语句在锁定模式0、1和2下的行为不同。例如，假定`c1`为`AUTO_INCREMENT`table 的 列 `t1`，并且最近自动生成的序列号为100。

  ```sql
  mysql> CREATE TABLE t1 (
      -> c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, 
      -> c2 CHAR(1)
      -> ) ENGINE = INNODB;
  ```

  现在，考虑以下“ 混合模式插入 ” 语句：

  ```sql
  mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
  ```

  随着 [`innodb_autoinc_lock_mode`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode) 设置为0（“ 传统 ”），这四个新的行是：

  ```sql
  mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
  +-----+------+
  | c1  | c2   |
  +-----+------+
  |   1 | a    |
  | 101 | b    |
  |   5 | c    |
  | 102 | d    |
  +-----+------+
  ```

  下一个可用的自动递增值是103，因为自动递增值加一次分配一次，而不是在语句执行开始时一次分配一次。无论是否存在 “类似INSERT”语句，该结果都是正确的 。

  随着 [`innodb_autoinc_lock_mode`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode) 设置为1（“ 连续 ”），这四个新行：

  ```sql
  mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
  +-----+------+
  | c1  | c2   |
  +-----+------+
  |   1 | a    |
  | 101 | b    |
  |   5 | c    |
  | 102 | d    |
  +-----+------+
  ```

  但是，在这种情况下，下一个可用的自动递增值**是105，而不是103**，**因为在处理语句时分配了四个自动递增值，但只使用了两个。**无论是否存在 “ 类似INSERT”语句，该结果都是正确的 。

  与 [`innodb_autoinc_lock_mode`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode) 设定为模式2（“ 交织 ”），四个新的行是：

  ```SQL
  mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
  +-----+------+
  | c1  | c2   |
  +-----+------+
  |   1 | a    |
  |   x | b    |
  |   5 | c    |
  |   y | d    |
  +-----+------+
  ```

  *`x`*和 *`y`*是独一无二的，比任何先前产生的行都大。然而，具体的数值 *`x`*和*`y`*依赖于并行执行语句生成自动递增值的数量。

  最后，考虑以下语句，该语句是在最近生成的序列号为100时发出的：

  ```sql
  mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (101,'c'), (NULL,'d');
  ```

  使用任何 `innodb_autoinc_lock_mode`设置，此语句都会生成重复键错误23000（`Can't write; duplicate key in table`），因为为该行分配了101，并且该行的 `(NULL, 'b')`插入 `(101, 'c')`失败。

- `AUTO_INCREMENT`在[`INSERT`](https://dev.mysql.com/doc/refman/5.7/en/insert.html)语句 序列的中间 修改列值
  在所有锁定模式（0、1和2）下，`AUTO_INCREMENT`在[`INSERT`](https://dev.mysql.com/doc/refman/5.7/en/insert.html) 语句序列中间修改 列值都可能导致“ 重复输入 ” 错误。例如，如果执行将 列值[`UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/update.html)更改为`AUTO_INCREMENT`大于当前最大自动增量值的值的[`INSERT`](https://dev.mysql.com/doc/refman/5.7/en/insert.html)操作，则未指定未使用的自动增量值的后续操作可能会遇到“ 重复输入 ”错误。在下面的示例中演示了此行为。

  ```sql
  mysql> CREATE TABLE t1 (
      -> c1 INT NOT NULL AUTO_INCREMENT,
      -> PRIMARY KEY (c1)
      ->  ) ENGINE = InnoDB;
  
  mysql> INSERT INTO t1 VALUES(0), (0), (3);
  
  mysql> SELECT c1 FROM t1;
  +----+
  | c1 |
  +----+
  |  1 |
  |  2 |
  |  3 |
  +----+
  
  mysql> UPDATE t1 SET c1 = 4 WHERE c1 = 1;
  
  mysql> SELECT c1 FROM t1;
  +----+
  | c1 |
  +----+
  |  2 |
  |  3 |
  |  4 |
  +----+
  
  mysql> INSERT INTO t1 VALUES(0);
  ERROR 1062 (23000): Duplicate entry '4' for key 'PRIMARY'
  ```

  

###### InnoDB自动递增计数器初始化

如果`AUTO_INCREMENT`为`InnoDB`表指定列，则`InnoDB`数据字典中的表句柄 包含一个称为自动增量计数器的特殊计数器，该计数器用于为该列分配新值。该计数器仅存储在主存储器中，而不存储在磁盘上。

要在服务器重新启动后初始化自动增量计数器，请在 `InnoDB`包含`AUTO_INCREMENT`列的表中的第一次插入时执行以下语句的等效项.

为了在服务器重启后初始化一个自动增量计数器，InnoDB在第一次插入包含AUTO_INCREMENT列的表时执行与下面语句等价的语句。

```sql
SELECT MAX(ai_col) FROM table_name FOR UPDATE;
```

InnoDB递增语句检索到的值，并将其分配给列和表的自动递增计数器。默认情况下，该值递增1。可以通过AUTO_INCREMENT_INCREMENT配置设置覆盖此默认值。

如果该表为空，InnoDB将使用值1。AUTO_INCREMENT_OFFSET配置设置可以覆盖此默认值。

如果SHOW TABLE STATUS语句在自动递增计数器初始化之前检查表，InnoDB会初始化该值，但不会递增。该值将被存储，以供以后的插入使用。此初始化在表上使用正常的独占锁定读取，并且锁将持续到事务结束。InnoDB遵循为新创建的表初始化自动递增计数器的相同过程。

在初始化自动递增计数器之后，如果您没有显式指定AUTO_INCREMENT列的值，InnoDB会递增计数器并将新值分配给该列。如果插入显式指定列值的行，并且该值大于当前计数器值，则计数器将设置为指定的列值。

只要服务器运行，InnoDB就会使用内存中的自动递增计数器。当服务器停止并重新启动时，InnoDB为第一次插入到表中的每个表重新初始化计数器，如前所述。

重新启动服务器还会取消CREATE TABLE和ALTER TABLE语句中AUTO_INCREMENT=N TABLE选项的影响，您可以将其与InnoDB表一起使用来设置初始计数器值或更改当前计数器值。

###### 注意事项

- 当AUTO_INCREMENT整数列用完值时，后续的INSERT操作将返回重复键错误（duplicate-key ）这是基本的的MySQL行为。

- 当您重新启动MySQL服务器时，InnoDB可能会重用为AUTO_INCREMENT列生成但从未存储的旧值(即，在回滚的旧事务期间生成的值)。

### 行级锁

#### 1. 共享读锁/s锁

##### 特征

- 共享锁允许持有该锁的事务读取一行。

- 多个事务可以持有同一行的s锁

- 只要有一个事务对某一行持有s锁，则其他事务不能对该行申请X锁，直到其他所有S锁释放

- 在获取S锁之前，先获取IS锁或更高级别的锁

#### 2. 排他写锁/x锁

##### 特征

- 独占(X)锁允许持有该锁的事务读取/更新或删除一行。
- 一个事务只要某一行加上了X锁，其他事务不能对该行加锁
- 当事务需要对表加X锁时，先看有没有获得IX锁，其他事务对该表有没有加IX锁
- 获取X锁之前，先获取IX锁

##### 演示

同 怎么看加了意向锁

#### 3. 记录锁/RECORD LOCK

##### 特征

- 锁住的是索引记录——可以理解为索引锁

- 在单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是**这个隐藏的聚集主键索引**。

所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加**X锁**，这个类似于表锁，但原理上和表锁应该是完全不同的。

#### 4. 间隙锁 / GAP LOCK

##### 起作用的隔离级别

RR隔离级别，意味着RC隔离级别不存在间隙锁

##### 在哪里加锁

作用于索引树，聚簇索引和非聚簇索引中，在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。

##### 加GAP锁条件

1. 非唯一索引等值查询，会在该值两侧空隙加GAP锁
2. 不论时非唯一索引 还是 唯一索引 或 主键索引。走索引，且是范围查询时，对空隙加GAP 锁

##### 细分类

- 共享间隙锁 / gap S-lock
- 独占间隙锁 / gap X-lock

两者可以共存，互相兼容。即当被加上间隙S锁后，仍然可以被加上间隙S锁。

##### 唯一作用

防止幻读——阻止特定行数据插入。

##### 开启关闭

- 回退到 RC 隔离级别
- innodb_locks_unsafe_for_binlog=1 可关闭(已被废弃)。默认为0，开启状态

#### 5. next-key 锁

##### 起作用的隔离级别

RR隔离级别，意味着RC隔离级别不存在间隙锁

##### 他是什么

GAP LOCK和RECORD LOCK的结合。例如，非唯一索引等值查询，会在该值两侧空隙加GAP锁 + 该值加record  锁

##### 唯一作用

防止幻读——阻止特定行数据插入。

#### 6. 插入意向锁

##### 概念

插入意向锁是Innodb gap锁的一种类型，这种锁表示要以这样一种方式插入:如果多个事务插入到相同的索引间隙中，如果它们不在间隙中的相同位置插入，则无需等待其他事务。比如说有索引记录4和7，有两个事务想要分别插入5，6，在获取插入行上的独占锁之前，每个锁都使用插入意图锁锁定4和7之间的间隙，但是不要互相阻塞，因为行是不冲突的，意向锁的设计是为了插入的正确和高效。

##### 特征

- 往一个空隙中插入数据，需要先获得插入意向锁
- 插入意向锁与GAP锁不兼容

如果出现重复键错误，则会在重复索引记录上设置一个共享锁。如果另一个会话已经具有互斥锁，则如果有多个会话试图插入同一行，则使用共享锁可能会导致死锁。如果另一个会话删除该行，则会发生这种情况。

假设一个`InnoDB`表 `t1`具有以下结构：

```sql
CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;
```

现在，假设三个会话按顺序执行以下操作：

```sql
# Session 1:						Session 2:					    Session 3:	
START TRANSACTION;
INSERT INTO t1 VALUES(1);
								   START TRANSACTION;				START TRANSACTION;
								   INSERT INTO t1 VALUES(1); 		 INSERT INTO t1 VALUES(1);

ROLLBACK;
```

会话1的第一个操作为该行获取排他锁。会话2和会话3的操作会导致重复键错误，并且它们都请求该行的共享锁。当会话1回滚时，它释放该行上的独占锁，并授予会话2和3的排队共享锁请求。此时，**会话2和3死锁**：由于另一方持有共享锁，这两个会话都不能获得该行的排他锁。

如果表中已经包含键值为1的行，并且三个会话按顺序执行以下操作，则会出现类似的情况:

```sql
# Session 1:						Session 2:					    Session 3:	
START TRANSACTION;
DELETE FROM t1 WHERE i = 1;
								   START TRANSACTION;				START TRANSACTION;
								   INSERT INTO t1 VALUES(1); 		 INSERT INTO t1 VALUES(1);

COMMIT;
```

会话1的第一个操作为该行获取排他锁。会话2和会话3的操作都会导致重复键错误，并且它们都请求该行的共享锁。当会话1提交时，它释放该行上的独占锁，并授予会话2和3的排队共享锁请求。此时，会话2和3死锁:由于另一方持有共享锁，这两个会话都不能获得该行的排他锁。

#### 7. 空间索引的谓词锁（空间索引，暂不做研究）

##### 8. 外键导致的加锁

如果存在外键约束，任何的insert，update，delete将会检测约束条件，将会在相应的记录上加共享的record lock，无论是否存在外键冲突。

### 页级锁

对数据页进行加锁

## ***加锁案例分析***

### 案例一：以下两条sql从各个角度分析加锁情况。

> 引自：[InnoDB锁分析](https://www.cnblogs.com/crazylqy/p/7611069.html)

```mysql
select * from t1 where id = 10;
delete from t1 where id = 10;
```

光看sql，无法确定加的什么锁，需要考虑一些条件。涉及到哪些前提条件？

- **前提一：**id列是不是主键？

- **前提二：**当前系统的隔离级别是什么？

- **前提三：**id列如果不是主键，那么id列上有索引吗？

- **前提四：**id列上如果有二级索引，那么这个索引是唯一索引吗？

- **前提五：**两个SQL的执行计划是什么？索引扫描？全表扫描？

没有这些前提，直接就给定一条SQL，然后问这个SQL会加什么锁，都是很业余的表现。而当这些问题有了明确的答案之后，给定的SQL会加什么锁，也就一目了然。下面，我将这些问题的答案进行组合，然后按照从易到难的顺序，逐个分析每种组合下，对应的SQL会加哪些锁？

**注：**下面的这些组合，我做了一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准。

- **组合一：**id列是主键，RC隔离级别
- **组合二：**id列是二级唯一索引，RC隔离级别
- **组合三：**id列是二级非唯一索引，RC隔离级别
- **组合四：**id列上没有索引，RC隔离级别
- **组合五：**id列是主键，RR隔离级别
- **组合六：**id列是二级唯一索引，RR隔离级别
- **组合七：**id列是二级非唯一索引，RR隔离级别
- **组合八：**id列上没有索引，RR隔离级别
- **组合九：**Serializable隔离级别

排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来，就让我们来逐个分析这9种组合下的SQL加锁策略。

注：在前面八种组合下，也就是RC，RR隔离级别下**，SQL1：select操作均不加锁，采用的是快照读，因此在下面的讨论中就忽略了**，主要讨论SQL2：delete操作的加锁。

#### **组合一：id主键+RC**

　　这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id = 10; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示：

![1.5.9.组合一：id主键+RC](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.9.%E7%BB%84%E5%90%88%E4%B8%80%EF%BC%9Aid%E4%B8%BB%E9%94%AE%2BRC.jpg)

**结论：id是主键时，此SQL只需要在id=10这条记录上加X锁即可。**

#### **组合二：id唯一索引+RC**

　　这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id = 10; 需要加什么锁呢？见下图：

![1.5.10.组合二：id唯一索引+RC](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.10.%E7%BB%84%E5%90%88%E4%BA%8C%EF%BC%9Aid%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%2BRC.jpg)

此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。*为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。*

**结论：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name='d',id=10]的记录。**

#### **组合三：id非唯一索引+RC**

　　**相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id = 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：**

![1.5.11.组合三：id非唯一索引+RC](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.11.%E7%BB%84%E5%90%88%E4%B8%89%EF%BC%9Aid%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%2BRC.jpg)

根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。

**结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。**

#### **组合四：id无索引+RC**

　　**相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图：**

![1.5.12.组合四：id无索引+RC](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.12.%E7%BB%84%E5%90%88%E5%9B%9B%EF%BC%9Aid%E6%97%A0%E7%B4%A2%E5%BC%95%2BRC.jpg)

*由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。*从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。

有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。

注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。

**结论：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。**

#### **组合五：id主键+RR**

　　上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。

　　组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：id主键，Read Committed一致。

 #### **组合六：id唯一索引+RR**

　　**与组合五类似，组合六的加锁，与组合二：id唯一索引+RC一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。**

 #### **组合七：id非唯一索引+RR**

　　还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，

**如何防止幻读呢？问题的答案，就在组合七中揭晓。**

组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：

![1.5.13.组合七：id非唯一索引+RR](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.13.%E7%BB%84%E5%90%88%E4%B8%83%EF%BC%9Aid%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%2BRR.jpg)

此图，相对于组合三：id非唯一索引+RC看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？

其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。

如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交为了实现这个功能，GAP锁应运而生。

如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。

Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。

有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？

首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？此问题留给大家思考。

 

**结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。**

 

 **什么时候会取得gap lock或nextkey lock 这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。**

 

#### **组合八：id无索引+RR**

　　**组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id = 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：**

![1.5.14.组合八：id无索引+RR](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.14.%E7%BB%84%E5%90%88%E5%85%AB%EF%BC%9Aid%E6%97%A0%E7%B4%A2%E5%BC%95%2BRR.jpg)

如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？

 

　　在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。

 

　　当然，跟组合四：id无索引+RC类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了[innodb_locks_unsafe_for_binlog](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html) 参数。更详细的关于semi-consistent read的介绍，可参考之前的一篇博客：[MySQL+InnoDB semi-consitent read原理及实现分析](http://hedengcheng.com/?p=220) 。

 

**结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。**

 

### **组合九：Serializable**

　　针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。

　　Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。

**结论：在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。**

### 案例二：以下sql从各个角度分析加锁情况

![1.5.15.复杂sql加锁分析](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.15.%E5%A4%8D%E6%9D%82sql%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90.jpg)

从图中可以看出，在Repeatable Read隔离级别下，由Index Key所确定的范围，被加上了GAP锁；Index Filter锁给定的条件 (userid = ‘hdc’)何时过滤，视MySQL的版本而定，在MySQL 5.6版本之前，不支持[Index Condition Pushdown](http://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html)(ICP)，因此Index Filter在MySQL Server层过滤，在5.6后支持了Index Condition Pushdown，则在index上过滤。若不支持ICP，不满足Index Filter的记录，也需要加上记录X锁，若支持ICP，则不满足Index Filter的记录，无需加记录X锁 (图中，用红色箭头标出的X锁，是否要加，视是否支持ICP而定)；而Table Filter对应的过滤条件，则在聚簇索引中读取后，在MySQL Server层面过滤，因此聚簇索引上也需要X锁。最后，选取出了一条满足条件的记录[8,hdc,d,5,good]，但是加锁的数量，要远远大于满足条件的记录数量。

 

**结论：在Repeatable Read隔离级别下，针对一个复杂的SQL，首先需要提取其where条件。Index Key确定的范围，需要加上GAP锁；Index Filter过滤条件，视MySQL版本是否支持ICP，若支持ICP，则不满足Index Filter的记录，不加X锁，否则需要X锁；Table Filter过滤条件，无论是否满足，都需要加X锁。**



### 总结：加锁机制与什么有关？

1. 隔离级别
   	RC —— RC不会出现GAP LOCK和NEXT LOCK
      	RR —— RR中会出现GAP LOCK和NEXT LOCK一定程度上解决了幻读
2. 是否主键
   	如果是主键，则只需要锁住一行即可，那一行加X锁
3. 是否二级索引?是否唯一索引
   	唯一索引只需要锁住索引值record lock + 对应的主键行X lock
      	非唯一索引会锁住索引值 + 附近的空隙 (前面两个合起来 next-key lock) + 对应的主键行X lock  
4. 对多列索引来说，版本很重要(ICP)
   	5.6之后支持ICP，在索引中过滤不满足条件的数据，省去一些行的X锁 
5. 执行计划是什么？索引扫描还是全表扫描
   	若不走索引，则全表的所有行加锁 + GAP 锁



## InnoDB中，由不同的SQL生成的锁

锁定读、更新或删除通常会在SQL语句处理过程中扫描的每个索引记录上设置记录锁。语句中是否有排除该行的条件并不重要。InnoDB不记得确切的位置条件，但只知道哪个索引范围被扫描。这些锁通常是 next-key 锁，它们也会阻塞插入到记录之前的“间隙”中。但是，可以显式禁用间隙锁定，这将导致不使用next-key锁定。事务隔离级别也会影响所设置的锁。

如果在搜索中使用了一个二级索引，并且要设置的索引记录锁是排他的，InnoDB也会检索相应的聚集索引记录并对它们设置锁。

如果没有适合语句的索引，MySQL必须扫描整个表来处理语句，那么**表的每一行都会被锁定**，从而阻塞其他用户对表的所有插入。**创建良好的索引很重要，这样您的查询就不会不必要地扫描很多行，并且减少锁定的行数**。

InnoDB设置的锁类型如下。

- `SELECT....FROM` 是一致读取，读取数据库的快照并且不设置锁，除非事务隔离级别设置为SERIALIZABLE。对于可序列化级别，搜索在遇到的索引记录上设置共享的next-key锁。但是，对于使用惟一索引来搜索惟一行来锁定行的语句，只需要一个索引记录锁。

-  `SELECT ... FOR UPDATE` 或 `SELECT ... LOCK IN SHARE MODE`对扫描的行获取锁，对不符合结果集中包含条件的行释放锁(例如，如果它们不满足WHERE子句中给出的条件)。但是，在某些情况下，可能不会立即解锁行，因为在查询执行期间，结果行与其原始源之间的关系丢失了。例如,在一个  UNION 中,从表中扫描（并锁定）的行可能会在评估它们是否符合结果集之前插入到临时表中。在这种情况下，临时表中的行与原始表中的行之间的关系将丢失，并且直到查询执行结束后，行才被解锁。

- `SELECT ... LOCK IN SHARE MODE`在搜索遇到的所有索引记录上设置共享的下一键锁定。但是，对于使用唯一索引锁定行以搜索唯一行的语句，仅需要索引记录锁定。

- `SELECT ... FOR UPDATE`在搜索遇到的每条记录上设置排他的 next-key 锁定。但是，对于使用一些语句搜索唯一索引的固定行，仅需要锁定索引记录。

   `SELECT ... FOR UPDATE`阻止其他会话执行 `SELECT ... LOCK IN SHARE MODE`或读取某些事务隔离级别。一致的读取将忽略读取视图中存在的记录上设置的任何锁定。

- `UPDATE ... WHERE ...`在搜索遇到的每条记录上设置排他的下一键锁定。但是，对于使用一些语句搜索唯一索引的固定行，仅需要索引记录锁定。

- 当UPDATE修改聚集索引记录时，会对受影响的辅助索引记录执行隐式锁。在插入新的辅助索引记录之前和插入新的辅助索引记录之前执行重复的检查扫描时，更新操作还对受影响的辅助索引记录使用共享锁。

- `DELETE FROM ... WHERE ...`在搜索遇到的每条记录上设置排他的下一键锁定。但是，对于使用一些语句搜索唯一索引的固定行，仅需要索引记录锁定。

- `INSERT`在插入的行上设置排他锁。该锁是索引记录锁，不是下一个键锁（即没有间隙锁），并且不会阻止其他会话插入到插入行之前的间隙中。

- `INSERT...ON DUPLICATE KEY UPDATE`与简单`INSERT`的不同之处在于，当发生重复键错误时，将排他锁而不是共享锁放置在要更新的行上。对重复的主键值采用独占索引记录锁。对重复的唯一索引值采用独占NEXT-KEY锁。

- 如果唯一键上没有冲突，则`REPLACE`操作类似于`INSERT`操作。否则，将在要替换的行上放置排他的NEXT-KEY锁。

- INSERT INTO T SELECT...FROM S，在插入到T中的每一行上设置独占索引记录锁(没有间隙锁)。如果事务隔离级别是READ COMMITTED，或者INNODB_LOCKS_UNSAFE_FOR_BINLOG已启用，并且事务隔离级别不是SERIALIZABLE，则InnoDB会将S作为一致读取(无锁)进行搜索。否则，InnoDB会在来自S.InnoDB的行上设置共享的Next-key锁。InnoDB必须在后一种情况下设置锁：在使用基于语句的二进制日志进行前滚恢复期间，每条SQL语句都必须以与最初完全相同的方式执行。

  `CREATE TABLE ... SELECT ...`使用共享的NEXT键锁执行SELECT或作为一致读取执行，如INSERT...SELECT。

  `REPLACE INTO t SELECT ... FROM s WHERE ...`或 `UPDATE t ... WHERE col IN (SELECT ... FROM s ...)`,InnoDB在表s中的行上设置共享的Next-key锁。

- InnoDB在初始化表上指定的AUTO_INCREMENT列时，会在与AUTO_INCREMENT列关联的索引的末尾设置一个独占锁。

  

  innodb_autoinc_lock_mode=0时，InnoDB使用一种特殊的自动-inc表锁模式，当访问自动递增计数器时，锁定被获取并保持到当前SQL语句的末尾(而不是整个事务的末尾)。当AUTO-INC表锁被持有时，其他客户端无法插入到表中。innodb_autoinc_lock_mode=1的“批量插入”也会发生相同的行为。innodb_autoinc_lock_mode=2不使用表级自动锁定。(自增锁)

  

  InnoDB获取之前初始化的AUTO_INCREMENT列的值，而不设置任何锁。

- 如果在表上定义了外键约束，则需要检查约束条件的任何插入、更新或删除都会在检查约束时查看的记录上设置共享记录级锁。InnoDB也会在约束失败的情况下设置这些锁。

- **LOCK TABLE设置了表的锁，但是设置这些锁的是在InnoDB之上的更高层的MySQL层。InnoDB在innodb_table_locks = 1(默认值)和autocommit = 0时知道表锁，而InnoDB上面的MySQL层知道行锁。**

  

  否则，InnoDB的自动死锁检测无法检测到涉及到这些表锁的死锁。另外，因为在本例中较高的MySQL层不知道行级锁，所以有可能在另一个会话当前拥有行级锁的表上获得表锁。然而，这并不危及事务完整性，如14.7.5.2节“死锁检测”中所讨论的。

- 如果innodb_table_locks=1(默认)，那么LOCK TABLE 在每个表上获得两个锁。除了MySQL层上的表锁之外，它还需要InnoDB表锁。4.1.2之前的MySQL版本没有获得InnoDB表锁;旧的行为可以通过设置innodb_table_locks=0来选择。如果没有获得InnoDB表锁，即使表的一些记录被其他事务锁住，锁表也会完成。

- 当事务被提交或中止时，所有由事务持有的InnoDB锁都会被释放。因此，在InnoDB表上以autocommit=1模式调用锁表没有太大意义，因为获得的InnoDB表锁会立即被释放。

- 不能在事务中间锁定其他表，因为 `LOCK TABLES`执行隐式提交和解锁表。

## 死锁

### 死锁简单案例

会话A持有一行数据的锁，会话B持有另一行数据的锁。
			A申请获取B持有的那个锁，但是被B占用着，所以A等待。
			B申请获取A持有的那个锁，但是被A占用着，所以B等待。

### 死锁的本质

死锁是指由于每个事务都持有对方需要的锁而无法进行其他事务的情况，形成一个循环的依赖关系。因为这两个事务都在等待资源变得可用，所以两个都不会释放它持有的锁。

当事务锁定多个表中的行（通过诸如`UPDATE`或的 语句`SELECT ... FOR UPDATE`但顺序相反时，可能会发生死锁 。当此类语句锁定索引记录和间隙的范围时，由于时序问题，每个事务都获得了一些锁而没有获得其他锁，也会发生死锁。下边会有死锁的演示。

为了减少死锁的可能性，请使用不是`LOCK TABLES`的事务语句；保持插入或更新数据的事务足够小，不使其长时间保持打开状态；当不同的事务更新多个表或大范围的行时，使用`SELECT ... FOR UPDATE`锁定所有要操作的行，并在每个事务中使用相同的操作顺序；在`SELECT ... FOR UPDATE`和 `UPDATE ... WHERE`语句中使用的列上创建索引。死锁的可能性不受隔离级别的影响，因为隔离级别更改了读取操作的行为，而死锁则由于写入操作而发生。

启用死锁检测（默认设置）并且发生死锁后，将`InnoDB`检测条件并回滚其中一个事务（权重最低的）。如果使用`innodb_deadlock_detect`配置选项禁用了死锁检测，则 在死锁的情况下`InnoDB`依靠该 `innodb_lock_wait_timeout`设置回滚事务。因此，即使您的应用程序逻辑正确，您仍必须处理必须重试事务的情况。要查看`InnoDB`用户事务中的最后一个死锁，请使用 `SHOW ENGINE INNODB STATUS`命令。如果频繁出现死锁，说明事务结构或应用程序错误处理存在问题，请使用 `innodb_print_all_deadlocks` 启用此设置可将有关所有死锁的信息打印到 **mysqld**错误日志中。

### InnoDB死锁示例

1. 上边 插入意向锁 中两个死锁案例

2. 以下示例说明了锁定请求将导致死锁时如何发生错误。该示例涉及两个客户端A和B。

   首先，客户端A创建一个包含一行的表，然后开始事务。在事务中，A通过LOCK IN SHARE MODE来获得对行的读锁：

   ```sql
   mysql> CREATE TABLE t (i INT) ENGINE = InnoDB;
   Query OK, 0 rows affected (1.07 sec)
   
   mysql> INSERT INTO t (i) VALUES(1);
   Query OK, 1 row affected (0.09 sec)
   
   mysql> START TRANSACTION;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> SELECT * FROM t WHERE i = 1 LOCK IN SHARE MODE;
   +------+
   | i    |
   +------+
   | 1    |
   +------+
   ```

   接下来，客户端B开始事务并尝试从表中删除该行：

   ```sql
   mysql> START TRANSACTION;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> DELETE FROM t WHERE i = 1;
   ```

   删除操作需要一个`X`锁。无法授予该`S`锁，因为它与客户端A持有的锁不兼容 ，因此该请求进入针对行和客户端B块的锁请求队列中。

   最后，客户端A还尝试从表中删除该行：

   ```sql
   mysql> DELETE FROM t WHERE i = 1;
   ERROR 1213 (40001): Deadlock found when trying to get lock;
   try restarting transaction
   ```

   此处发生死锁，因为客户端A需要 `X`锁才能删除该行。但是，不能授予该锁定请求，因为客户端B已经有一个`X`锁定请求，并且正在等待客户端A释放其`S`锁定。由于B事先要求锁，因此`S`A持有的锁也不能 升级 `X`为`X`锁。结果， `InnoDB`为其中一个客户端生成错误并释放其锁。客户端返回此错误。

   届时，可以授予对另一个客户端的锁定请求，并从表中删除该行。

3. 在RR隔离级别下，数据库有两条数据id=1和id=10。 且id为普通索引   
   两个事务，事务 1: select * from table where id=3 for update。   insert (id=3)，他会在(1,3) (3,10)之间加间隙锁，在(3)这个位置申请插入意向锁。
   事务2:   select * from table where id=5 for update,  insert(id=5)。  它会在(1,5) (5,10)之间加间隙锁，由于间隙锁互相兼容，故该锁可以获取，另外在(5)这个地方申请插入意向锁。
   当事务1要获取插入意向锁时，发现(3)被事务2的间隙锁锁住了，故等待事务2释放锁；
   事务2要获取插入意向锁时，发现(5)被事务1的间隙锁锁住了，故等待事务1释放锁；——死锁形成\

4. 银行转账的例子

   ```sql
   create table money(id int primary key,price int);
   insert into money values(1,1000);
   insert into money values(2,1000);
   ```

   事务A: 更新表，id=1的记录

   ```sql
   mysql> start transaction;
   Query OK, 0 rows affected (0.01 sec)
    
   mysql> update money set price=2000 where id=1;
   Query OK, 1 row affected (0.03 sec)
   ```

   事务B: 更新表，id=2的记录

   ```sql
   mysql> start transaction;
   Query OK, 0 rows affected (0.01 sec)
    
   mysql> update money set price=2000 where id=2;
   Query OK, 1 row affected (0.00 sec)
   ```

   事务A: 更新表，id=2的记录，此时会卡住（因为这条记录被加上了X锁）

   ```sql
   mysql> update money set price=3000 where id=2;
   ```

   事务B: 更新表，id=1的记录，此时会报错事务进行回滚，并且事务1会执行更新id=2的记录

   ```sql
   mysql> update money set price=3000 where id=1;
   ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
   ```

   上述，事务抛出1213这个出错提示，即发生了死锁，上例中当两个事务都执行了第一条UPDATE语句，更新了一行数据，同时也锁定了该行数据，接着每个事务都尝试去执行第二条UPDATE语句，却发现该行已经被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。除非有外部因素接入才可能解除死锁。为了解决这种问题，数据库系统实现了各种**死锁检测**和死锁超时**机制**。
   ![1.5.19.死锁案例图](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.19.%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%9B%BE.png)

### 死锁的必要条件

1. 多个并发事务（2个或者以上）；
2. 每个事务都持有锁（或者是已经在等待锁）；
3. 每个事务都需要再继续持有锁（为了完成事务逻辑，还必须更新更多的行）；
4. 事务之间产生加锁的循环等待，形成死锁。

总结：当两个或多个事务相互持有对方需要的锁时，就会产生死锁。

### 死锁的检测

**当死锁检测启用时(默认)，InnoDB会自动检测事务死锁并回滚一个或多个事务来打破死锁。InnoDB尝试选择小事务进行回滚，其中事务的大小由插入、更新或删除的行数决定。**



InnoDB在innodb_table_locks = 1(默认值)和autocommit = 0时知道表锁，它上面的MySQL层知道行锁。否则，InnoDB无法检测到由MySQL锁表语句设置的表锁，或由InnoDB以外的存储引擎设置的锁。通过设置innodb_lock_wait_timeout系统变量的值来解决这些情况。



如果InnoDB监视器输出的最新检测到的死锁部分包含一条消息，“在锁表等待图中搜索太深或太长，我们将在事务之后回滚”，这表明等待列表中的事务数量已经达到了200的上限。**超过200个事务的等待列表被视为死锁，试图检查等待列表的事务被回滚。如果锁定线程必须查看等待列表中事务拥有的超过1,000,000个锁，也可能会发生同样的错误。**

### 死锁检测机制 - wait-for graph

核心就是数据库会把事务单元锁维持的锁和它所等待的锁都记录下来，Innodb提供了**wait**-**for** **graph**算法来主动进行**死锁检测**，每当加锁请求无法立即满足需要进入等待时，**wait**-**for** **graph**算法都会被触发。当数据库检测到两个事务不同方向地给同一个资源加锁（产生循序），它就认为发生了死锁，触发**wait**-**for** **graph**算法。比如，事务1给A加锁，事务2给B加锁，同时事务1给B加锁（等待），事务2给A加锁就发生了死锁。那么死锁解决办法就是终止一边事务的执行即可，这种效率一般来说是最高的，也是主流数据库采用的办法。

![1.5.22.简单死锁示意图]()

Innodb目前处理死锁的方法就是**将持有最少行级排他锁的事务进行回滚**。这也是相对比较简单的死锁回滚方式。死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型的系统，这是无法避免的，所以应用程序在设计必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。

**wait**-**for** **graph**原理

我们怎么知道图中四辆车是死锁的？

![1.5.20.死锁示意图2](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.20.%E6%AD%BB%E9%94%81%E7%A4%BA%E6%84%8F%E5%9B%BE2.jpg)

他们相互等待对方的资源，而且**形成环路**！我们将每辆车看为一个节点，当节点1需要等待节点2的资源时，就生成一条有向边指向节点2，最后形成一个有向图。我们只要检测这个有向图是否出现环路即可，出现环路就是死锁！这就是**wait**-**for** **graph**算法。

![1.5.21.死锁示意图3](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.21.%E6%AD%BB%E9%94%81%E7%A4%BA%E6%84%8F%E5%9B%BE3.jpg)

Innodb将各个事务看为一个个节点，资源就是各个事务占用的锁，当事务1需要等待事务2的锁时，就生成一条有向边从1指向2，最后行成一个有向图。

### 禁用死锁检测

在高并发性系统中，当多个线程等待同一锁时，死锁检测可能导致速度下降。有时，禁用死锁检测并依赖于innodb_lock_wait_timeout设置在发生死锁时执行事务回滚可能更有效。可以使用innodb_deadlock_detect配置选项禁用死锁检测。

### 避免死锁

死锁是事务性数据库中的一个典型问题，但它们并不危险，除非它们非常频繁以至于您根本无法运行某些事务。通常，您必须编写应用程序，以便在事务因死锁而回滚时，它们始终准备重新发出事务。

InnoDB使用自动行级锁定。即使在只插入或删除单行的事务中，也会出现死锁。这是因为这些操作并不是真正的“原子”操作;它们自动设置插入或删除行的索引记录(可能有几个)的锁。

你可以使用以下技巧来处理死锁，并降低发生死锁的可能性:

- 在任何时候，发出显示引擎INNODB状态命令来确定最近死锁的原因。这可以帮助您优化应用程序以避免死锁。

- 如果经常出现死锁警告，那么可以通过启用innodb_print_all_deadlocks配置选项来收集更多的调试信息。关于每个死锁的信息，而不仅仅是最近的死锁，都记录在MySQL错误日志中。完成调试后禁用此选项。

- 如果事务由于死锁而失败，请随时准备重新发出事务。死锁并不危险。再试一次。

- 保持事务较小且持续时间较短，以减少冲突的发生。

- 在进行一组相关更改之后立即提交事务，以减少冲突的发生。特别是，不要让一个交互式mysql会话长时间打开一个未提交的事务。

- 如果你使用锁读(SELECT ... FOR UPDATE 或 SELECT ... LOCK IN SHARE MODE)，尝试使用较低的隔离级别，如READ COMMITTED。

- 当修改一个事务中的多个表或同一表中的不同行集时，每次都要按照一致的顺序执行这些操作。这样，事务就形成了定义良好的队列，不会死锁。例如，将数据库操作组织成应用程序中的函数，或调用存储过程，而不是在不同的地方编写多个类似的INSERT、UPDATE和DELETE语句序列。

- 向表中添加精心选择的索引。这样，查询需要扫描的索引记录就更少，因此设置的锁就更少。使用EXPLAIN SELECT来确定MySQL服务器认为哪些索引最适合您的查询。

- 使用更少的锁定。如果允许SELECT从旧快照返回数据，则不要向其添加用于更新或锁定共享模式的子句。这里使用READ COMMITTED隔离级别很好，因为同一事务中的每次一致读取都是从它自己的新快照中读取的。

- 如果没有其他帮助，使用表级锁序列化事务。对于事务性表，比如InnoDB表，使用锁表的正确方法是在事务开始时设置autocommit = 0(不是启动事务)，然后是锁表，并且在显式提交事务之前不调用解锁表。例如，如果您需要写入表t1和读取表t2，您可以这样做:

  ```sql
  SET autocommit=0;
  LOCK TABLES t1 WRITE, t2 READ, ...;
  ... do something with tables t1 and t2 here ...
  COMMIT;
  UNLOCK TABLES;
  ```

  表级锁可以防止对表的并发更新，从而避免死锁，但对于繁忙的系统，响应能力会降低。

- 序列化事务的另一种方法是创建一个只包含一行的辅助“信号量”表。让每个事务在访问其他表之前更新该行。这样，所有的事务都以连续的方式发生。注意，InnoDB的即时死锁检测算法也适用于这种情况，因为序列化锁是行级锁。对于MySQL表级锁，必须使用超时方法来解决死锁。

- 优化表结构，优化schema，可在一定程度上避免死锁

---

# latch 和 lock 的区别

这里要区分锁中容易令人混淆的概念lock与latch。在数据库中，lock与latch都可以成为锁，但两者有截然不同的含义

latch 一般称为闩锁(轻量级的锁) 因为其要求锁定的时间非常短，若持续时间长，则应用性能非常差，在mysql中，latch有可以分为mutex(互斥锁)和rwlock(读写锁)其目的用来保证并发线程操作临界资源的正确性，并且没有死锁检测的机制

lock的对象是事务，用来锁定的是数据库中的UI想，如表、页、行。并且一般lock对象仅在事务commit或rollback后进行释放(不同事务隔离级别释放的时间可能不同)，此外lock正如大多数数据库中一样，是有死锁机制的。表显示了lock与latch的不同

![1.5.0.latch 和 lock 的区别](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.0.latch%20%E5%92%8C%20lock%20%E7%9A%84%E5%8C%BA%E5%88%AB.jpg)

可以粗略理解为：

![1.5.5.latch和lock锁范围](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.5.latch%E5%92%8Clock%E9%94%81%E8%8C%83%E5%9B%B4.png)

> 注意：
>
> InnoDB缓冲池属于InnoDB级别，其中也会有数据页，索引页，对这些页加的锁，采用lock事务锁。

# 命令总结

```shell
# 查看行锁信息
show status like 'innodb_row_lock_%';
# 查看表锁
show OPEN TABLES where In_use > 0;
# 开启innodb监控器
SET GLOBAL innodb_status_output=ON;
# 开启innodb锁定监控器
SET GLOBAL innodb_status_output_locks=ON;
# 设置死锁信息输出到错误日志：
set innodb_print_all_deadlocks = on;
# 查看锁等待超时时间：
show variables like 'innodb_lock_wait_timeout';
# 修改时间：
set @@innodb_lock_wait_timeout=20;
# 查看详细信息
show engine innodb status;
```

