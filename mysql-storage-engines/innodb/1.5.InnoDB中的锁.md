# latch - 线程锁

## 简介

latch是闩锁，一种轻量级锁。要求锁定的时间必须非常短。若时间长，则性能非常差。**其目的是为了保证并发线程操作临界资源的正确性。通常没有死锁检测**

**通常指的是server层、innodb层的互斥锁和读写锁。**

## **作用**

锁是数据库系统区别与文件系统的一个关键特性。**锁机制用于管理对共享资源的并发访问**。Innodb存储引擎在行级别上对表数据上锁，这固然不错。但是Innodb也会在多个地方使用锁，从而允许多种不同资源提供并发访问。例如，**操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，为了保证一致性，必须有锁的介入，这就是latch锁。**

## **举个例子**

- 例一：当我们在执行select 时，数据先查磁盘上的数据页，放到buffer pool中，多个线程并发访问或者修改这个数据必然需要一个并发控制机制，这个就是latch。
- 例二：
  1. 线程A以读的方式访问共享资源，此时共享资源加上了读锁，若读到数据，马上释放锁
     ![线程A加读锁](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.16.%E7%BA%BF%E7%A8%8BA%E5%8A%A0%E8%AF%BB%E9%94%81.png)
  2. 线程B过来，想要读取共享资源并发现资源被加上读锁，因为读锁共享，可以直接赋予线程B读锁，进而读取资源。
     ![线程B加读锁](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.17.%E7%BA%BF%E7%A8%8BB%E7%94%B3%E8%AF%B7%E5%8A%A0%E8%AF%BB%E9%94%81.jpg)
  3. 线程C过来，想要修改资源，舅要获取写锁，但读写锁冲突，所以获取写锁失败。然后线程C自旋，空占CPU资源（**因为他知道A 和 B很快**，所以执行一段空代码，loop，隔段时间看看 A 和 B 有没有释放锁。若不空占CPU资源，则CPU看这个线程闲着，就踢出CPU），若始终得不到锁，则进入sleep状态，退出CPU，等待唤醒。
     ![线程C加写锁](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.18.%E7%BA%BF%E7%A8%8BC%E7%94%B3%E8%AF%B7%E5%8A%A0%E5%86%99%E9%94%81.jpg)

数据库要访问的数据必须先存在缓存中，而缓存一般比磁盘空间要小，数据缓冲使用hash表来记录数据页是否在内存中。在MySQL中对应的RW-Latch在errlog中说的很清楚，该RW-Latch是在buf0sea.cc的658行创建的RW-Latch。

## 如何查看

```mysql
mysql> show engine innodb status;

----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 199098
OS WAIT ARRAY INFO: signal count 153659
RW-shared spins 0, rounds 205663, OS waits 94452
RW-excl spins 0, rounds 744093, OS waits 14037
RW-sx spins 13520, rounds 231541, OS waits 2348
Spin rounds per wait: 205663.00 RW-shared, 744093.00 RW-excl, 17.13 RW-sx
```

- rounds的意思是每次询问旋转的参数
- os waits：表示sleep，当突然增长比较快的时候，说明latch争用比较严重
- rw-shared spin 的次数
- rw-excl  spin的次数

## 分类

### (一) mutex

互斥量；有时候有些资源需要共享和并发，但是又不是分频繁，所以**向操作系统申请一个mutex**，mutex都是排他的。

Linux中提供一把**互斥锁mutex**（**也称之为互斥量**）。**遇到锁竞争，有的mutex会自旋，有的会直接阻塞。**

> **InnoDB中，不同场景需要的mutex 是不一样的, 比如buffer pool 上面的page 的mutex 希望的就是一直spin. 有些mutex 其实则是希望立刻就进入等待, 只用使用这些mutex 的使用者知道接下来哪一个策略更合适**，但目前为止在并未实现。可参考[InnoDB mutex 实现分析](http://mysql.taobao.org/monthly/2020/03/05/)

每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。

但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。

![1.5.2.mutex示意图](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.2.mutex%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

但，**应注意：同一时刻，只能有一个线程持有该锁**。

当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。**C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱**。

所以，**互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。**
**因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。**

#### **加锁与解锁**

> 注意：以下 lock 并非 “lock锁”，因为 latch 本身就是一个锁，所以会有加锁解锁机制。不要与 基于事务的Lock 混淆

- **lock与unlock：**

  lock尝试加锁，如果加锁不成功，**线程阻塞**，阻塞到持有该互斥量的其他线程解锁为止。

  unlock主动解锁函数，**同时将阻塞在该锁上的所有线程**，至于哪个线程先被唤醒，取决于优先级、调度。例如：T1 T2 T3 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2 T3 T4均被唤醒，并自动再次尝试加锁。

  可假想mutex锁 init成功初值为1。 lock 功能是将mutex--。 unlock将mutex++

- **lock与trylock：**

  lock加锁失败**会阻塞**，等待锁释放。

  trylock加锁失败直接返回错误号（如：EBUSY），**不阻塞，自旋**。

#### **1. mutex in Server**

除了win之外都采用了`glibc`中的`pthread_mutex_t`，如server层中`LOCK_status`, `LOCK_thd_remove`等

- 方法一：

  ```
  (gdb) p LOCK_status
  $11 = {m_mutex = {__data = {__lock = 2, __count = 0, __owner = 102188, __nusers = 1, __kind = 3, __spins = 85, __list = {__prev = 0x0, __next = 0x0}},
      __size = "\002\000\000\000\000\000\000\000,\217\001\000\001\000\000\000\003\000\000\000U", '\000' <repeats 18 times>, __align = 2}, m_psi = 0x0}
  ```

  这里的`__owner`为core中`LWP XXXX`后的值

  ![1.5.3._owner拥有者图示](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.3._owner%E6%8B%A5%E6%9C%89%E8%80%85%E5%9B%BE%E7%A4%BA.png)

- 方法二：
  切换到`__lll_lock_wait`这样`frame`上，对于64 bit系统：

  ```
  (gdb) p *(pthread_mutex_t*)$rdi
  $12 = {__data = {__lock = 2, __count = 0, __owner = 102188, __nusers = 1, __kind = 3, __spins = 85, __list = {__prev = 0x0, __next = 0x0}},
    __size = "\002\000\000\000\000\000\000\000,\217\001\000\001\000\000\000\003\000\000\000U", '\000' <repeats 18 times>, __align = 2}
  ```

  同样能找到`pthread_mutex`中的`owner`

#### **2. mutex in InnoDB**

***`innodb`层最常见的`mutex` `latch`为`PolicyMutex<TTASEventMutex<GenericPolicy>`，这种锁和`rw_lock_t`一样是spin锁，当拿不到锁时会尝试自旋一段时间:***

```
spin_and_try_lock(...)
{
  ...
  for (;;) {
    // 尝试自旋，自旋的时间同样由由`innodb_sync_spin_loops`、`innodb_spin_wait_delay`决定
    is_free(max_spins, max_delay, n_spins) {
      if (try_lock()) {
        break;
      } else {
        ...
      }
    } else {
      max_spins = n_spins + step;
    }
    os_thread_yield();
    ...
  }
  ...
}
```

这种锁一般持有时间很短，在`innodb`上采用`atomic`来实现，目前没有好的办法排查加这种锁的线程和位置，但是`core`文件仍然提供了许多有用的信息：

```
(gdb) p *this
$19 = {m_impl = {m_lock_word = 0, m_waiters = 0, m_event = 0x7f5faea51358, m_policy = {m_count = {m_spins = 0, m_waits = 0, m_calls = 0, m_enabled = false}, m_id = LATCH_ID_FLUSH_LIST}}, m_ptr = 0x0}
```

`m_lock_word`对应值的含义：

```
/** Mutex is free */
 MUTEX_STATE_UNLOCKED = 0
 
 /** Mutex is acquired by some thread. */
 MUTEX_STATE_LOCKED = 1
 
 /** Mutex is contended and there are threads waiting on the lock. */
 MUTEX_STATE_WAITERS = 2
```

另外`m_waiters = 0`并不意味着目前没有等锁的线程，如果拿该锁的线程都处于自旋状态，`m_waiters`仍然等于`0`

如果有线程持有该锁，想要排查，同样可以用`pt-pmp`排查：

1. 排除堆栈重复次数超过`1`次的所有线程
2. 排除阻塞在获取该锁的所有线程
3. 排除带有`poll()`、`epoll_wait`的堆栈
4. 带有`pthread_cond_wait`的堆栈持有该锁的可能性也比较低
5. 阻塞在`__lll_lock_wait`的线程持有该锁的可能性比较低，持有innodb层mutex锁的线程阻塞在server层锁的可能性比较低

持有该锁的堆栈只可能出现`1`次，排查持有者需要根据具体情况分析

###  (二)RW-LATCH

***读写锁。共享读写，排他写锁。***

#### 1. RW_lock in Server

除了`win`之外都采用了`glibc`中的`pthread_rwlock_t`

```
(gdb) frame 1
#1  0x0000000000ec2059 in native_rw_wrlock (rwp=0x7f5faf078298) at /home/admin/129_20200113173827294_121311408_code/rpm_workspace/include/thr_rwlock.h:101
101     /home/admin/129_20200113173827294_121311408_code/rpm_workspace/include/thr_rwlock.h: No such file or directory.
(gdb) p rwp
$13 = (native_rw_lock_t *) 0x7f5faf078298
(gdb) p *rwp
$14 = {__data = {__lock = 0, __nr_readers = 0, __readers_wakeup = 0, __writer_wakeup = 0, __nr_readers_queued = 0, __nr_writers_queued = 15, __writer = 61789, __shared = 0, __pad1 = 0, __pad2 = 0, __flags = 0},
  __size = '\000' <repeats 20 times>, "\017\000\000\000]\361", '\000' <repeats 29 times>, __align = 0}
```

- `__nr_readers`: 当前有多少个线程持有读锁
- `__nr_readers_queued`: 当前有多少个线程在等待获得读锁
- `__nr_writers_queued`: 当前有多少个线程在等待获得写锁，PS：写锁的优先级比读锁要高。即如果线程想获得读锁，当发现`__nr_writers_queued`不为`0`时，哪怕当前没有人获得写锁，也会将自己阻塞。目的是防止写锁饿死。
- `__writer`：写锁持有者的`LWP #`

如果有线程持有写锁，通过`__writer`很容易找到该线程；如果有线程持有了读锁，持有读锁的线程和位置可能有多个，则可以尝试通过下述方法进行排查：

```
$ gdb <binary> <coredump> -ex "thread apply all bt" -ex "quit" > core.bt
$ pt-pmp core.bt > pt-pmp.log
```

在`pt-pmp.log`中，排除：

1. 出现频次高于`__nr_readers`的堆栈
2. 阻塞在获取该锁的写锁的所有线程
3. 带有`poll()`、`epoll_wait`的堆栈
4. 带有`pthread_cond_wait`的堆栈持有该读锁的可能性也比较低

由于持有读锁的线程和位置可能有多个，排查读锁持有者需要根据具体情况分析。

#### 2. RW_lock in InnoDB

innodb层的读写锁，如`dict_operation_lock`、`btr_search_latches`，`checkpoint_lock`等

```
(gdb) p *dict_operation_lock
$16 = {lock_word = -2, waiters = 1, recursive = true, sx_recursive = 0, writer_is_wait_ex = false, writer_thread = 140042102085376, event = 0x7f5faf05aab8, wait_ex_event = 0x7f5faf05ab58,
  cfile_name = 0x162c6d8 "/home/admin/129_20200113173827294_121311408_code/rpm_workspace/storage/innobase/dict/dict0dict.cc",
  last_s_file_name = 0x1619240 "/home/admin/129_20200113173827294_121311408_code/rpm_workspace/storage/innobase/row/row0undo.cc",
  last_x_file_name = 0x1614968 "/home/admin/129_20200113173827294_121311408_code/rpm_workspace/storage/innobase/row/row0mysql.cc", cline = 1186, is_block_lock = 0, last_s_line = 322, last_x_line = 4290, count_os_wait = 20559,
  list = {prev = 0x7f5faea79150, next = 0x7f5faea87428}, pfs_psi = 0x0}
```

- 当`lock_word = X_LOCK_DECR`时，意味着当前锁没有被任何人持有
- 当`X_LOCK_HALF_DECR < lock_word < X_LOCK_DECR`，意味着当前有一个或多个线程持有读锁
- 当`0 < lock_word <= X_LOCK_HALF_DECR`时，意味着当前有一个线程持有`SX`锁，有0个（`lock_word = X_LOCK_HALF_DECR`）或多个线程（`lock_word < X_LOCK_HALF_DECR`）持有读锁
- 当`lock_word = 0`时表示没有线程持有读锁，下一个写锁已经加上（并已获得）
- 当`lock_word < 0`是表示有线程持有一个或多个读锁，下一个写锁已经预定（仍未获得，在等待读锁释放）

1. ***这里`SX`锁是一种介于`X`锁和`S`锁的锁，它阻塞`X`、`SX`锁，但不阻塞`S`锁，类似于 IS锁、IX锁***
2. 为了更好理解`lock_word`的含义，下面简单介绍`rw_lock_t`获取写锁的操作

```
// lock_word 的初始值，意味着最多允许0x20000000个读锁同时持有
#define X_LOCK_DECR     0x20000000
// 当上SX锁时，会尝试将lock_word减少X_LOCK_HALF_DECR
#define X_LOCK_HALF_DECR    0x10000000

rw_lock_x_lock_low(rw_lock_t*  lock, ulint pass, const char* file_name, ulint line) {

  // 如果lock_word>X_LOCK_HALF_DECR，尝试将lock_word减少X_LOCK_DECR
  // 如果成功，则至少预定自己为下一个写锁的持有者，返回true，否则返回false
  if (rw_lock_lock_word_decr(lock, X_LOCK_DECR, X_LOCK_HALF_DECR)) {
  
    // 预定自己为下一个写锁持有者，此时lock_word<=0，last_x_file_name:last_x_line 为上一个写锁持有者的上锁位置
    // 将自己的线程标识写入writer_thread，
    rw_lock_set_writer_id_and_recursion_flag(lock, !pass);)

    // 如果lock_word<0，说明有线程持有读锁，必须等待读锁释放
    // 阻塞直到 lock_word==0, 
    rw_lock_x_lock_wait(lock, pass, 0, file_name, line);

  } else {
    ......
  }
  
  // 成功获得写锁，last_x_file_name:last_x_line指向加锁的位置
  lock->last_x_file_name = file_name;
  lock->last_x_line = (unsigned int) line;

  return true;
}
```

再回到上述的例子：

- `lock_word=-2`，说明这里有两个线程持有了读锁，从`last_s_file_name` : `last_s_line` 可以看到加读锁的位置；
- 同时，下一个写锁已经预定，预定者由`writer_thread`指明；
- 但是，`last_x_file_name` : `last_x_line` 并不是预订者的位置，因为此时写锁还没有真正持有
- `writer_thread`指明了持有或即将持有写锁的线程id，将其转成16进制可以在堆栈中搜出：

![1.5.4.查看持有或即将持有写锁的线程id](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.4.%E6%9F%A5%E7%9C%8B%E6%8C%81%E6%9C%89%E6%88%96%E5%8D%B3%E5%B0%86%E6%8C%81%E6%9C%89%E5%86%99%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8Bid.png)

另外：

- ***如果拿不到锁，线程会尝试自旋一段时间，如果自旋后还是拿不到锁，则让出处理器***
- ***自旋的时间由`innodb`参数`innodb_sync_spin_loops`、`innodb_spin_wait_delay`决定***
- ***如果发现所有的拿锁的线程都处于自旋状态，则可以尝试减少`innodb_sync_spin_loops`、`innodb_spin_wait_delay`***

> 引自：
>
> 1. [互斥锁](https://blog.csdn.net/qq_39736982/article/details/82348672)
> 2. [[MYSQL中的LATCH(闩锁)详解)](https://www.cnblogs.com/data-zhang/p/6971718.html)
> 3. [阿里数据库内核月报——latch持有锁分析](http://mysql.taobao.org/monthly/2020/03/07/)

## **latch争用发生的原因**

1. 内存访问太频繁（不停地找）
2. 缓冲池太大。数据块太多（被持有的几率太大）

## **如何降低latch争用**

1. 优化sql，降低对内存读的数量——效果比较明显
2. 增加缓冲池instances的数量，分担压力
3. 适当缩小缓冲池大小，但一般不建议。

## InnoDB Buffer Pool并发控制加锁过程

> [InnoDB Buffer Pool并发控制加锁过程](http://mysql.taobao.org/monthly/2020/05/06/)

---

# Lock - 事务锁

## 与 latch 的区别

lock对象是事务，用来锁定的是数据库中的对象，如表、行、页。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。

## InnoDB中B+树的层次结构——对这些结构加事务锁

首先了解一下数据是怎么存放的，他的一个层次结构，方便理解



![1.5.8.InnoDB中B+树的层次结构](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.8.InnoDB%E4%B8%ADB%2B%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg)

## 加锁原则

二阶段加锁原则

- 加锁阶段
- 解锁阶段

加锁解锁互不相交，各司其职

![1.5.6.二阶段加锁原则.jpg](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.6.%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81%E5%8E%9F%E5%88%99.jpg)

## 锁的分类

### 表级锁

#### InnoDB什么时候对表加S锁？

5.6中在线DDL，已不再加S锁；以前的一些操作如add index、alter table等会加S锁

#### InnoDB不会对表加X锁

InnoDB不会对表加排他X锁，平常遇到的锁表，是把所有记录锁住，把所有间隙锁住，造成表锁的假象

#### 意向锁

InnoDB支持多粒度锁，允许行锁和表锁共存。

##### 分类

- **意向共享读锁 / IS锁**
  	表示事务打算对表中的各个行设置共享读锁。
    	select *** lock in share mode
- **意向排他写锁 / IX锁**
  	表示事务打算对表中的各个行设置排他写锁。
    	select *** for update

##### 意向锁协议
- 事务在获得表中某行上的共享锁之前，必须先获得表上的IS锁或更强的锁。
- 在事务可以获得表中某一行上的排他锁之前，它必须首先获得表上的IX锁。

##### 锁的兼容性

如果与现有锁兼容，则将锁授予请求事务，但如果与现有锁冲突，则不授予该事务。事务将一直等待，直到有冲突的现有锁被释放。如果一个锁请求与一个现有的锁冲突，并且不能被授予，因为这会导致死锁，那么就会发生错误。



![1.5.7.表级锁的兼容性](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.7.%E8%A1%A8%E7%BA%A7%E9%94%81%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7.png)

可以发现一些规律

- 写锁必排他
- 除写锁外，其他同类型的互相兼容
- 只要是意向锁就兼容
- 只要是读锁，就兼容

##### 怎么看加了意向锁

1. 开启Innodb监控器
2. SHOW ENGINE INNODB STATUS

```mysql
# 开启innodb监控器
mysql> SET GLOBAL innodb_status_output=ON;
1 row in set (0.01 sec)

# 开启innodb锁定监控器
mysql> SET GLOBAL innodb_status_output_locks=ON;
1 row in set (0.01 sec)

# 关闭自动提交 => 手动开启关闭事务
mysql> set autocommit = 0;
1 row in set (0.01 sec)

# 查询 user_age=11 的数据，并加写锁,其中，user_age 为单列辅助索引
mysql> select * from user2 where user_age = 11 for update;
。。。数据内容省略
2107 rows in set (0.01 sec)

mysql> show engine innodb status;
------------
TRANSACTIONS
------------
Trx id counter 1551642
Purge done for trxs n:o < 0 undo n:o < 0 state: running but idle
History list length 0
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 283571429645824, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 283571429644952, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 1551641, ACTIVE 14 sec
129 lock struct(s), heap size 24784, 4216 row lock(s)
MySQL thread id 2, OS thread handle 22756, query id 152 localhost ::1 root starting
show engine innodb status
TABLE LOCK table `testmybatis`.`user2` trx id 1551641 lock mode IX
RECORD LOCKS space id 379 page no 25 n bits 1480 index idx_user_age of table `testmybatis`.`user2` trx id 1551641 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 1; hex 8b; asc  ;;
 1: len 4; hex 800035b4; asc   5 ;;

Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 1; hex 8b; asc  ;;
 1: len 4; hex 800035b8; asc   5 ;;
```

- TABLE LOCK table `testmybatis`.`user2` trx id 1551641 lock mode IX，
  解释：`testmybatis`.`user2`被事务id为`1551641`的事务加上表锁——IX锁
- RECORD LOCKS space id 379 page no 25 n bits 1480 index idx_user_age of table `testmybatis`.`user2` trx id 1551641 lock_mode X
  解释：`testmybatis`.`user2`表中的索引 `idx_user_age`被事务id为`1551641`的事务加上记录锁——X锁。索引的space id为`379`，page no为`25`
- 此案例中，展示了 意向锁 IX，排他写锁 X，记录锁 Record lock

##### 意向锁的作用

>  mysql官网上对于意向锁的解释中有这么一句话
> “The main purpose of IX and IS locks is to show that someone is locking a row, or going to lock a row in the table.”
> 加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。
>
> 那么，意向锁的作用就是“表明”加锁的意图，可是为什么要表明这个 意图呢？
>
> 如果仅仅锁定一行仅仅需要加一个锁，那么就直接加锁就好了，这里要表明加锁意图的原因是因为要锁定一行不仅仅是要加一个锁，而是要做一系列操作吗？

> 引用其他地方的回答[意向锁的作用](https://www.zhihu.com/question/51513268)  
>
> 我最近也在看这个，我说一下我的理解
>
> 1. 在mysql中有表锁，LOCK TABLE my_tabl_name READ;  用读锁锁表，会阻塞其他事务修改表数据。LOCK TABLE my_table_name write; 用写锁锁表，会阻塞其他事务读和写。
> 2. Innodb引擎又支持行锁，行锁分为共享锁，一个事务对一行的共享只读锁。排它锁，一个事务对一行的排他读写锁。
> 3. 这两中类型的锁共存的问题考虑这个例子：
>    事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请表中全部数据的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。
>    数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。
>
> 数据库要怎么判断这个冲突呢？
>
> - step1：判断表是否已被其他事务用表锁锁表
> - step2：判断表中的每一行是否已被行锁锁住。
>
> 注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。
>
> 于是就有了意向锁。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。在意向锁存在的情况下，上面的判断可以改成
>
> - step1：不变
> - step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。
>
> 注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。
>
> 总结：为了实现多粒度锁机制（白话：为了表锁和行锁都能用）

#### 自增自动上锁 / AUTO-INC Locks

##### 作用在哪里

自增列 —— AUTO_INCREMENT

当一张表的某个字段是自增列时，innodb会在该索引的末位加一个排它锁。为了访问这个自增的数值，需要加一个表级锁，不过这个表级锁的持续时间只有当前sql，而不是整个事务，即当前sql执行完，该表级锁就释放了。其他session无法在这个表级锁持有时插入任何记录。

### 行级锁

#### 1. 共享读锁/s锁

##### 特征

- 共享锁允许持有该锁的事务读取一行。

- 多个事务可以持有同一行的s锁

- 只要有一个事务对某一行持有s锁，则其他事务不能对该行申请X锁，直到其他所有S锁释放

- 在获取S锁之前，先获取IS锁或更高级别的锁

#### 2. 排他写锁/x锁

##### 特征

- 独占(X)锁允许持有该锁的事务读取/更新或删除一行。
- 一个事务只要某一行加上了X锁，其他事务不能对该行加锁
- 当事务需要对表加X锁时，先看有没有获得IX锁，其他事务对该表有没有加IX锁
- 获取X锁之前，先获取IX锁

##### 演示

同 怎么看加了意向锁

#### 3. 记录锁/RECORD LOCK

##### 特征

- 锁住的是索引记录——可以理解为索引锁

- 在单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是**这个隐藏的聚集主键索引**。

所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加**X锁**，这个类似于表锁，但原理上和表锁应该是完全不同的。

#### 4. 间隙锁 / GAP LOCK

##### 起作用的隔离级别

RR隔离级别，意味着RC隔离级别不存在间隙锁

##### 在哪里加锁

作用于索引树，聚簇索引和非聚簇索引中，在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。

##### 加GAP锁条件

1. 非唯一索引等值查询，会在该值两侧空隙加GAP锁
2. 不论时非唯一索引 还是 唯一索引 或 主键索引。走索引，且是范围查询时，对空隙加GAP 锁

##### 细分类

- 共享间隙锁 / gap S-lock
- 独占间隙锁 / gap X-lock

两者可以共存，互相兼容。即当被加上间隙S锁后，仍然可以被加上间隙S锁。

##### 唯一作用

防止幻读——阻止特定行数据插入。

##### 开启关闭

- 回退到 RC 隔离级别
- innodb_locks_unsafe_for_binlog=1 可关闭(已被废弃)。默认为0，开启状态

#### 5. next-key 锁

##### 起作用的隔离级别

RR隔离级别，意味着RC隔离级别不存在间隙锁

##### 他是什么

GAP LOCK和RECORD LOCK的结合。例如，非唯一索引等值查询，会在该值两侧空隙加GAP锁 + 该值加record  锁

##### 唯一作用

防止幻读——阻止特定行数据插入。

#### 6. 插入意向锁

##### 概念

插入意向锁是Innodb gap锁的一种类型，这种锁表示要以这样一种方式插入:如果多个事务插入到相同的索引间隙中，如果它们不在间隙中的相同位置插入，则无需等待其他事务。比如说有索引记录4和7，有两个事务想要分别插入5，6，在获取插入行上的独占锁之前，每个锁都使用插入意图锁锁定4和7之间的间隙，但是不要互相阻塞，因为行是不冲突的，意向锁的设计是为了插入的正确和高效。

##### 特征

- 往一个空隙中插入数据，需要先获得插入意向锁
- 插入意向锁与GAP锁不兼容

#### 7. 空间索引的谓词锁（空间索引，暂不做研究）

### 页级锁

对数据页进行加锁

## ***加锁案例分析***

### 案例一：以下两条sql从各个角度分析加锁情况。

> 引自：[InnoDB锁分析](https://www.cnblogs.com/crazylqy/p/7611069.html)

```mysql
select * from t1 where id = 10;
delete from t1 where id = 10;
```

光看sql，无法确定加的什么锁，需要考虑一些条件。涉及到哪些前提条件？

- **前提一：**id列是不是主键？

- **前提二：**当前系统的隔离级别是什么？

- **前提三：**id列如果不是主键，那么id列上有索引吗？

- **前提四：**id列上如果有二级索引，那么这个索引是唯一索引吗？

- **前提五：**两个SQL的执行计划是什么？索引扫描？全表扫描？

没有这些前提，直接就给定一条SQL，然后问这个SQL会加什么锁，都是很业余的表现。而当这些问题有了明确的答案之后，给定的SQL会加什么锁，也就一目了然。下面，我将这些问题的答案进行组合，然后按照从易到难的顺序，逐个分析每种组合下，对应的SQL会加哪些锁？

**注：**下面的这些组合，我做了一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准。

- **组合一：**id列是主键，RC隔离级别
- **组合二：**id列是二级唯一索引，RC隔离级别
- **组合三：**id列是二级非唯一索引，RC隔离级别
- **组合四：**id列上没有索引，RC隔离级别
- **组合五：**id列是主键，RR隔离级别
- **组合六：**id列是二级唯一索引，RR隔离级别
- **组合七：**id列是二级非唯一索引，RR隔离级别
- **组合八：**id列上没有索引，RR隔离级别
- **组合九：**Serializable隔离级别

排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来，就让我们来逐个分析这9种组合下的SQL加锁策略。

注：在前面八种组合下，也就是RC，RR隔离级别下**，SQL1：select操作均不加锁，采用的是快照读，因此在下面的讨论中就忽略了**，主要讨论SQL2：delete操作的加锁。

#### **组合一：id主键+RC**

　　这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id = 10; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示：

![1.5.9.组合一：id主键+RC](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.9.%E7%BB%84%E5%90%88%E4%B8%80%EF%BC%9Aid%E4%B8%BB%E9%94%AE%2BRC.jpg)

**结论：id是主键时，此SQL只需要在id=10这条记录上加X锁即可。**

#### **组合二：id唯一索引+RC**

　　这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id = 10; 需要加什么锁呢？见下图：

![1.5.10.组合二：id唯一索引+RC](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.10.%E7%BB%84%E5%90%88%E4%BA%8C%EF%BC%9Aid%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%2BRC.jpg)

此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。*为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。*

**结论：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name='d',id=10]的记录。**

#### **组合三：id非唯一索引+RC**

　　**相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id = 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：**

![1.5.11.组合三：id非唯一索引+RC](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.11.%E7%BB%84%E5%90%88%E4%B8%89%EF%BC%9Aid%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%2BRC.jpg)

根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。

**结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。**

#### **组合四：id无索引+RC**

　　**相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图：**

![1.5.12.组合四：id无索引+RC](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.12.%E7%BB%84%E5%90%88%E5%9B%9B%EF%BC%9Aid%E6%97%A0%E7%B4%A2%E5%BC%95%2BRC.jpg)

*由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。*从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。

有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。

注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。

**结论：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。**

#### **组合五：id主键+RR**

　　上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。

　　组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：id主键，Read Committed一致。

 #### **组合六：id唯一索引+RR**

　　**与组合五类似，组合六的加锁，与组合二：id唯一索引+RC一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。**

 #### **组合七：id非唯一索引+RR**

　　还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，

**如何防止幻读呢？问题的答案，就在组合七中揭晓。**

组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：

![1.5.13.组合七：id非唯一索引+RR](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.13.%E7%BB%84%E5%90%88%E4%B8%83%EF%BC%9Aid%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%2BRR.jpg)

此图，相对于组合三：id非唯一索引+RC看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？

其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。

如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交为了实现这个功能，GAP锁应运而生。

如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。

Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。

有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？

首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？此问题留给大家思考。

 

**结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。**

 

 **什么时候会取得gap lock或nextkey lock 这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。**

 

#### **组合八：id无索引+RR**

　　**组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id = 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：**

![1.5.14.组合八：id无索引+RR](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.14.%E7%BB%84%E5%90%88%E5%85%AB%EF%BC%9Aid%E6%97%A0%E7%B4%A2%E5%BC%95%2BRR.jpg)

如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？

 

　　在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。

 

　　当然，跟组合四：id无索引+RC类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了[innodb_locks_unsafe_for_binlog](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html) 参数。更详细的关于semi-consistent read的介绍，可参考之前的一篇博客：[MySQL+InnoDB semi-consitent read原理及实现分析](http://hedengcheng.com/?p=220) 。

 

**结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。**

 

### **组合九：Serializable**

　　针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。

　　Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。

**结论：在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。**

### 案例二：以下sql从各个角度分析加锁情况

![1.5.15.复杂sql加锁分析](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.15.%E5%A4%8D%E6%9D%82sql%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90.jpg)

从图中可以看出，在Repeatable Read隔离级别下，由Index Key所确定的范围，被加上了GAP锁；Index Filter锁给定的条件 (userid = ‘hdc’)何时过滤，视MySQL的版本而定，在MySQL 5.6版本之前，不支持[Index Condition Pushdown](http://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html)(ICP)，因此Index Filter在MySQL Server层过滤，在5.6后支持了Index Condition Pushdown，则在index上过滤。若不支持ICP，不满足Index Filter的记录，也需要加上记录X锁，若支持ICP，则不满足Index Filter的记录，无需加记录X锁 (图中，用红色箭头标出的X锁，是否要加，视是否支持ICP而定)；而Table Filter对应的过滤条件，则在聚簇索引中读取后，在MySQL Server层面过滤，因此聚簇索引上也需要X锁。最后，选取出了一条满足条件的记录[8,hdc,d,5,good]，但是加锁的数量，要远远大于满足条件的记录数量。

 

**结论：在Repeatable Read隔离级别下，针对一个复杂的SQL，首先需要提取其where条件。Index Key确定的范围，需要加上GAP锁；Index Filter过滤条件，视MySQL版本是否支持ICP，若支持ICP，则不满足Index Filter的记录，不加X锁，否则需要X锁；Table Filter过滤条件，无论是否满足，都需要加X锁。**



### 总结：加锁机制与什么有关？

1. 隔离级别
   	RC —— RC不会出现GAP LOCK和NEXT LOCK
      	RR —— RR中会出现GAP LOCK和NEXT LOCK一定程度上解决了幻读
2. 是否主键
   	如果是主键，则只需要锁住一行即可，那一行加X锁
3. 是否二级索引?是否唯一索引
   	唯一索引只需要锁住索引值record lock + 对应的主键行X lock
      	非唯一索引会锁住索引值 + 附近的空隙 (前面两个合起来 next-key lock) + 对应的主键行X lock  
4. 对多列索引来说，版本很重要(ICP)
   	5.6之后支持ICP，在索引中过滤不满足条件的数据，省去一些行的X锁 
5. 执行计划是什么？索引扫描还是全表扫描
   	若不走索引，则全表的所有行加锁 + GAP 锁



## 死锁

1、什么是死锁：会话A持有一行数据的锁，会话B持有另一行数据的锁。
A申请获取B持有的那个锁，但是被B占用着，所以A等待。
B申请获取A持有的那个锁，但是被A占用着，所以B等待。

2、死锁的本质：两个或多个会话/线程，本身拥有一个锁，但是去互相申请对方拥有的锁，导致都在锁等待，即为死锁。索引失效会造成表锁，比死锁更严重

3、举例：在RR隔离级别下，数据库有两条数据id=1和id=10。 且id为普通索引   
两个事务，事务 1: select * from table where id=3 for update。   insert (id=3)，他会在(1,3) (3,10)之间加间隙锁，在(3)这个位置申请插入意向锁。
事务2:   select * from table where id=5 for update,  insert(id=5)。  它会在(1,5) (5,10)之间加间隙锁，由于间隙锁互相兼容，故该锁可以获取，另外在(5)这个地方申请插入意向锁。
当事务1要获取插入意向锁时，发现(3)被事务2的间隙锁锁住了，故等待事务2释放锁；
事务2要获取插入意向锁时，发现(5)被事务1的间隙锁锁住了，故等待事务1释放锁；——死锁形成

4、InnoDB的死锁检测：InnoDB内部会自动识别死锁，并回滚其中一个权重较小的事务。一般为修改量最小的，undo log最小的。

5、避免死锁：①注意sql的执行顺序，尽量让sql以相同顺序获取数据，②大事务化为小事务，减少持有锁的时间，③加快sql执行速度，优化sql，包括建立索引，④优化表结构，可一定程度上避免死锁

---

# latch 和 lock 的区别

这里要区分锁中容易令人混淆的概念lock与latch。在数据库中，lock与latch都可以成为锁，但两者有截然不同的含义

latch 一般称为闩锁(轻量级的锁) 因为其要求锁定的时间非常短，若持续时间长，则应用性能非常差，在mysql中，latch有可以分为mutex(互斥锁)和rwlock(读写锁)其目的用来保证并发线程操作临界资源的正确性，并且没有死锁检测的机制

lock的对象是事务，用来锁定的是数据库中的UI想，如表、页、行。并且一般lock对象仅在事务commit或rollback后进行释放(不同事务隔离级别释放的时间可能不同)，此外lock正如大多数数据库中一样，是有死锁机制的。表显示了lock与latch的不同

![1.5.0.latch 和 lock 的区别](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.0.latch%20%E5%92%8C%20lock%20%E7%9A%84%E5%8C%BA%E5%88%AB.jpg)

可以粗略理解为：

![1.5.5.latch和lock锁范围](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.5.5.latch%E5%92%8Clock%E9%94%81%E8%8C%83%E5%9B%B4.png)

> 注意：
>
> InnoDB缓冲池属于InnoDB级别，其中也会有数据页，索引页，对这些页加的锁，采用lock事务锁。

