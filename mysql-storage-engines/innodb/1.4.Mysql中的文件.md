# 参数文件

## 作用

告诉MySQL实例，启动时，在哪里可以找到数据库文件，并且指定哪些初始化参数，这些参数定义了某种内存结构的大小等设置，还会介绍各种参数的类型。

mysql数据库的配置文件，包含了各类系统参数

## 参数文件类型

### Windows

> |               位置                |                     描述                     |
> | :-------------------------------: | :------------------------------------------: |
> | %WINDIR%\my.ini， %WINDIR%\my.cnf |         全局选项<br />echo %WINDIR%          |
> |       C:\my.ini， C:\my.cnf       |                   全局选项                   |
> |  BASEDIR\my.ini， BASEDIR\my.cnf  |  全局选项<br />BASEDIR表示MySQL基本安装目录  |
> |        defaults-extra-file        | 用指定的文件 --defaults-extra-file（如果有） |
> |   %APPDATA%\MySQL\.mylogin.cnf    | 登录路径选项（仅客户端）<br />echo %APPDATA  |

	### Unix和类似Unix

> |        位置         |                             描述                             |
> | :-----------------: | :----------------------------------------------------------: |
> |     /etc/my.cnf     |                           全局选项                           |
> |  /etc/mysql/my.cnf  |                           全局选项                           |
> |  SYSCONFDIR/my.cnf  | SYSCONFDIR表示在构建MySQL时SYSCONFDIR 使用CMake选项指定的目录。默认情况下，这是etc位于内置安装目录下的目录 |
> | $MYSQL_HOME/my.cnf  |                 服务器特定的选项（仅服务器）                 |
> | defaults-extra-file |         用指定的文件 --defaults-extra-file（如果有）         |
> |      ~/.my.cnf      |                        用户特定的选项                        |
> |   ~/.mylogin.cnf    |             用户特定的登录路径选项（仅限客户端）             |

## 参数类型

### 动态参数(dynamic)

可以在Mysql运行实例中进行修改

### 静态参数(static)

整个运行过程中，不许修改。只读的。只能修改配置文件，并重启生效。如:开启二进制日志的 log_bin只能在 配置文件中指定

## 参数文件加载顺序

### 如何查看MySQL参数文件加载顺序

mysql --verbose --help | grep my.cnf

> 上边的两个列表中从上往下，下边的配置会覆盖上边相同的配置

---

# 日志文件

查看日志文件默认路径：

```
mysql> show variables like 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.00 sec)
```



## 错误日志

记录了mysql启动、运行、关闭过程

### 查看错误日志位置

show variables like 'log_err%';

## 慢查询日志 - slow query log

### 作用

记录执行超过指定时间值的SQL语句

### 查看慢日志是否开启 / 慢日志位置

```
mysql> show variables like '%slow%';
+---------------------------+--------------------------------------+
| Variable_name             | Value                                |
+---------------------------+--------------------------------------+
| log_slow_admin_statements | OFF                                  |
| log_slow_slave_statements | OFF                                  |
| slow_launch_time          | 2                                    |
| slow_query_log            | OFF                                  |
| slow_query_log_file       | /var/lib/mysql/4709e2f4ee4f-slow.log |
+---------------------------+--------------------------------------+
5 rows in set (0.00 sec)

mysql> set @@global.slow_query_log = ON;
Query OK, 0 rows affected (0.04 sec)

mysql> show variables like '%slow%';
+---------------------------+--------------------------------------+
| Variable_name             | Value                                |
+---------------------------+--------------------------------------+
| log_slow_admin_statements | OFF                                  |
| log_slow_slave_statements | OFF                                  |
| slow_launch_time          | 2                                    |
| slow_query_log            | ON                                   |
| slow_query_log_file       | /var/lib/mysql/4709e2f4ee4f-slow.log |
+---------------------------+--------------------------------------+
5 rows in set (0.01 sec)

```

### 满足什么条件会记录到慢查询日志中

1. 阈值：long_query_time，只有超过这个时间的sql才会被记录，等于这个值，不会被记录。
   默认为10秒。

   ```
   mysql> show variables like 'long_query_time';
   +-----------------+-----------+
   | Variable_name   | Value     |
   +-----------------+-----------+
   | long_query_time | 10.000000 |
   +-----------------+-----------+
   1 row in set (0.00 sec)
   ```

   现在改为200ms（改完之后再次查询没看到效果，退出重进之后，发现修改成功）

   ```
   mysql> set global long_query_time = 0.200000;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> show variables like 'long_query_time';
   +-----------------+-----------+
   | Variable_name   | Value     |
   +-----------------+-----------+
   | long_query_time | 10.000000 |
   +-----------------+-----------+
   1 row in set (0.00 sec)
   
   mysql> exit
   Bye
   root@4709e2f4ee4f:/# mysql -u root -proot
   Warning: Using a password on the command line interface can be insecure.
   Welcome to the MySQL monitor.  Commands end with ; or \g.
   Your MySQL connection id is 355
   Server version: 5.6.49 MySQL Community Server (GPL)
   
   Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   
   Oracle is a registered trademark of Oracle Corporation and/or its
   affiliates. Other names may be trademarks of their respective
   owners.
   
   Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
   
   mysql> show variables like 'long_query_time';
   +-----------------+----------+
   | Variable_name   | Value    |
   +-----------------+----------+
   | long_query_time | 0.200000 |
   +-----------------+----------+
   1 row in set (0.00 sec)
   ```

   

2. sql语句不走索引也会被记录到慢日志中
   需要打开 log_queries_not_using_indexes，默认为关闭状态

   ```
   mysql> show variables like 'log_queries_not_using_indexes';
   +-------------------------------+-------+
   | Variable_name                 | Value |
   +-------------------------------+-------+
   | log_queries_not_using_indexes | OFF   |
   +-------------------------------+-------+
   1 row in set (0.00 sec)
   
   mysql> set global log_queries_not_using_indexes = ON;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> show variables like 'log_queries_not_using_indexes';
   +-------------------------------+-------+
   | Variable_name                 | Value |
   +-------------------------------+-------+
   | log_queries_not_using_indexes | ON    |
   +-------------------------------+-------+
   1 row in set (0.00 sec)
   ```

   另外还有一个参数，控制每分钟不走索引被记录到慢日志的sql的数量：0为不限制

   ```
   mysql> show variables like 'log_throttle_queries_not_using_indexes';
   +----------------------------------------+-------+
   | Variable_name                          | Value |
   +----------------------------------------+-------+
   | log_throttle_queries_not_using_indexes | 0     |
   +----------------------------------------+-------+
   1 row in set (0.00 sec)
   ```

### 测试慢日志记录

> 建表语句：show create table user1;
>
> CREATE TABLE `user1` (
>   `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键id',
>   `user_name` varchar(100) DEFAULT NULL COMMENT '用户名',
>   `user_age` tinyint(3) DEFAULT NULL COMMENT '用户年龄',
>   `user_password` varchar(100) DEFAULT NULL COMMENT '用户密码',
>   `user_sex` tinyint(1) DEFAULT NULL COMMENT '性别 1-男，0-女',
>   `user_province` varchar(32) DEFAULT NULL COMMENT '用户所在省',
>   `user_city` varchar(32) DEFAULT NULL COMMENT '用户所在城市',
>   `user_area` varchar(32) DEFAULT NULL COMMENT '用户所在区',
>   `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
>   `modified_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
>   PRIMARY KEY (`user_id`),
>   KEY `idx_user_name` (`user_name`),
>   KEY `idx_user_age` (`user_age`),
>   KEY `idx_province_city_area` (`user_province`,`user_city`,`user_area`)
> ) ENGINE=InnoDB AUTO_INCREMENT=223793 DEFAULT CHARSET=utf8;

1. （Navicat中）执行一个时间长的走索引的sql

   > - 首先看执行计划，是走索引的
   >
   > mysql> explain select * from user1 where user_age < 8;
   >
   > |  id  | select_type | table | type  | possible_keys |     key      | key_len | ref  | rows  |         Extra         |
   > | :--: | :---------: | :---: | :---: | :-----------: | :----------: | :-----: | :--: | :---: | :-------------------: |
   > |  1   |   SIMPLE    | user1 | range | idx_user_age  | idx_user_age |    2    | NULL | 35042 | Using index condition |
   >
   > 1 row in set (0.04 sec)
   >
   > mysql> select * from user1 where user_age < 8;
   > (为了排版省去一部分字段展示)
   >
   > | user_id | user_name | user_age | user_sex | user_province | user_city | user_area |
   > | :-----: | :-------: | :------: | :------: | :-----------: | :-------: | :-------: |
   > |  13698  |  颜难慧   |    3     |    0     |    河南省     |  泰安市   |  南岔区   |
   > |   ...   |    ...    |   ...    |   ...    |      ...      |    ...    |    ...    |
   >
   > 16961 rows in set (38.39 sec)

   

2. （Navicat中）执行一个不走索引的sql

   > mysql> explain select * from user1 where user_password = 'aa80452e65864e56afa335c31538870c';
   >
   > |  id  | select_type | table | type | possible_keys | key  | key_len | ref  |  rows  |    Extra    |
   > | :--: | :---------: | :---: | :--: | :-----------: | :--: | :-----: | :--: | :----: | :---------: |
   > |  1   |   SIMPLE    | user1 | ALL  |     NULL      | NULL |  NULL   | NULL | 208534 | Using where |
   >
   > 1 row in set (0.19 sec)
   >
   > mysql> select * from user1 where user_password = 'aa80452e65864e56afa335c31538870c';
   > (为了排版省去一部分字段展示)
   >
   > | user_id | user_name | user_age |          user_password           | user_province | user_city | user_area |
   > | :-----: | :-------: | :------: | :------------------------------: | :-----------: | :-------: | :-------: |
   > | 223621  |  和筵颠   |    7     | aa80452e65864e56afa335c31538870c |    山西省     | 平顶山市  |  榆次区   |
   >
   > 1 row in set (0.29 sec)

   

3. （Navicat中）再执行一个sql，跟第一个sql一样

   > select * from user1 where user_age < 12;
   > (为了排版省去一部分字段展示)
   >
   > | user_id | user_name | user_age | user_sex | user_province | user_city | user_area |
   > | :-----: | :-------: | :------: | :------: | :-----------: | :-------: | :-------: |
   > |  13698  |  颜难慧   |    3     |    0     |    河南省     |  泰安市   |  南岔区   |
   > |   ...   |    ...    |   ...    |   ...    |      ...      |    ...    |    ...    |

4. 查看详细的日志文件

   ```
   root@4709e2f4ee4f:/usr/bin# cat /var/lib/mysql/4709e2f4ee4f-slow.log 
   mysqld, Version: 5.6.49 (MySQL Community Server (GPL)). started with:
   Tcp port: 3306  Unix socket: /var/run/mysqld/mysqld.sock
   Time                 Id Command    Argument
   ...
   # Time: 200921  6:05:42
   # User@Host: root[root] @  [xxx.xxx.xx.xxx]  Id:   358
   # Query_time: 11.581630  Lock_time: 0.000100 Rows_sent: 16961  Rows_examined: 16961
   SET timestamp=1600668342;
   select * from user1 where user_age < 8;
   # Time: 200921  6:24:23
   # User@Host: root[root] @  [xxx.xxx.xx.xxx]  Id:   361
   # Query_time: 0.154447  Lock_time: 0.000114 Rows_sent: 1  Rows_examined: 210102
   SET timestamp=1600669463;
   select * from user1 where user_password = 'aa80452e65864e56afa335c31538870c';
   # Time: 200921  7:23:32
   # User@Host: root[root] @  [xxx.xxx.xx.xxx]  Id:   365
   # Query_time: 20.423910  Lock_time: 0.000076 Rows_sent: 25440  Rows_examined: 210102
   SET timestamp=1600673012;
   select * from user1 where user_age < 12;
   ...
   ```

   可以看到完整的sql保存在慢日志中。

5. 使用mysqldumpslow查看慢日志
   本处使用docker里的MySQL

   ```
   root@4709e2f4ee4f:/usr/bin# mysqldumpslow /var/lib/mysql/4709e2f4ee4f-slow.log 
   
   Reading mysql slow query log from /var/lib/mysql/4709e2f4ee4f-slow.log
   Count: 2  Time=16.00s (32s)  Lock=0.00s (0s)  Rows=21200.5 (42401), root[root]@[xxx.xxx.xx.xxx]
     select * from user1 where user_age < N
   
   Count: 1  Time=0.15s (0s)  Lock=0.00s (0s)  Rows=1.0 (1), root[root]@[xxx.xxx.xx.xxx]
     select * from user1 where user_password = 'S'
   ```

   通过显示内容，可发现一些信息

   - 执行时间上不太一致。（慢日志记录的是sql真正执行时间。其他客户端看到的时间，跟网络带宽有关）
   - mysqldumpslow后边，有一个默认的参数，按照平均查询时间(向下取整)来排序，递减排序
   - 该工具把数字格式化成 N ，string格式化成 S
   - Count：该类型的sql执行了几次。由以上可知，执行了两次
   - Time=16.00s (32s) ，其中，括号左边的16代表该类sql平均执行16秒，括号里的32s代表总执行时间为32秒。
   - Lock类似Time，代表锁的时间
   - Rows类似Time，代表返回行数
   - root[root]@[xxx.xxx.xx.xxx] ，其中xxx.xxx.xx.xxx为查询sql的客户端ip，此处未切换IP测试，暂时未知
   - 下边就是查询的sql

### mysqldumpslow的高级用法

> 查看mysqldumpslow 的一些参数
> root@4709e2f4ee4f:/usr/bin# mysqldumpslow --help
> Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]
>
> Parse and summarize the MySQL slow query log. Options are
>
>   --verbose    verbose
>   --debug      debug
>   --help       write this text to standard output
>
>   -v           verbose	//verbose：adj. 冗长的;啰唆的;唠叨的
>   -d           debug
>   -s ORDER     what to sort by (al, at, ar, c, l, r, t), 'at' is default		//根据什么来排序，'at'是默认的
>                 al: average lock time														 //平均锁时间
>                 ar: average rows sent													   //平均发送的行数时间
>                 at: average query time													  //平均查询时间
>                  c: count																			//总的行数
>                  l: lock time																		//总的锁时间
>                  r: rows sent																	  //总的发送行数
>                  t: query time  																  //总的查询时间
>   -r           reverse the sort order (largest last instead of first)			//颠倒排序顺序（最大的最后一个而不是第一个）
>   -t NUM       just show the top n queries											//返回指定 数量的慢查询日志
>   -a           don't abstract all numbers to N and strings to 'S'				//不把所有的数字抽象成N，字符串抽象成S
>   -n NUM       abstract numbers with at least n digits within names	//至少格式化NUM个数字？？
>   -g PATTERN   grep: only consider stmts that include this string		//grep：只考虑包含指定字符串的慢日志
>   -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),
>                default is '*', i.e. match all														//数据库服务器上 -slow.log
>   -i NAME      name of server instance (if using mysql.server startup script)	
> 																											//服务器实例的名称（如果使用mysql.server启动脚本）
>   -l           don't subtract lock time from total time								//不要从总时间中减去锁定时间

根据操作参数，使用mysqldumpslow 的高级用法

```
1、查看包含指定字符串的慢日志
    root@4709e2f4ee4f:/usr/bin# mysqldumpslow -g 'password' /var/lib/mysql/4709e2f4ee4f-slow.log

    Reading mysql slow query log from /var/lib/mysql/4709e2f4ee4f-slow.log
    Count: 1  Time=0.15s (0s)  Lock=0.00s (0s)  Rows=1.0 (1), root[root]@[xxx.xxx.xx.xxx]
      select * from user1 where user_password = 'S'
2、查询返回的总行数最多的两条记录
	root@4709e2f4ee4f:/usr/bin# mysqldumpslow -s r -t 2 /var/lib/mysql/4709e2f4ee4f-slow.log

    Reading mysql slow query log from /var/lib/mysql/4709e2f4ee4f-slow.log
    Count: 2  Time=16.00s (32s)  Lock=0.00s (0s)  Rows=21200.5 (42401), root[root]@[xxx.xxx.xx.xxx]
      select * from user1 where user_age < N

    Count: 1  Time=0.00s (0s)  Lock=0.00s (0s)  Rows=1000.0 (1000), root[root]@[xxx.xxx.xx.xxx]
      SELECT * FROM `lgt6`.`user1` LIMIT N, N

3、根据总的发送行数排序 - Rows括号里的数值
	root@4709e2f4ee4f:/usr/bin# mysqldumpslow -s r -n 2 /var/lib/mysql/4709e2f4ee4f-slow.log
	Reading mysql slow query log from /var/lib/mysql/4709e2f4ee4f-slow.log
    Count: 2  Time=16.00s (32s)  Lock=0.00s (0s)  Rows=21200.5 (42401), root[root]@[xxx.xxx.xx.xxx]
      select * from user1 where user_age < N

    Count: 1  Time=0.00s (0s)  Lock=0.00s (0s)  Rows=1000.0 (1000), root[root]@[xxx.xxx.xx.xxx]
      SELECT * FROM `lgt6`.`user1` LIMIT N, N

    Count: 3  Time=0.01s (0s)  Lock=0.00s (0s)  Rows=95.0 (285), root[root]@[xxx.xxx.xx.xxx]
      SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, COLUMN_TYPE FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = 'S' ORDER BY TABLE_SCHEMA, TABLE_NAME

    Count: 3  Time=0.00s (0s)  Lock=0.00s (0s)  Rows=10.0 (30), root[root]@[xxx.xxx.xx.xxx]
      SELECT TABLE_SCHEMA, TABLE_NAME, TABLE_TYPE FROM information_schema.TABLES WHERE TABLE_SCHEMA = 'S' ORDER BY TABLE_SCHEMA, TABLE_TYPE

    Count: 1  Time=0.00s (0s)  Lock=0.00s (0s)  Rows=17.0 (17), root[root]@[xxx.xxx.xx.xxx]
      SELECT STATE AS `Status`, ROUND(SUM(DURATION),N) AS `Duration`, CONCAT(ROUND(SUM(DURATION)/N.N*N,N), 'S') AS `Percentage` FROM INFORMATION_SCHEMA.PROFILING WHERE QUERY_ID=N GROUP BY SEQ, STATE ORDER BY SEQ

    Count: 2  Time=0.00s (0s)  Lock=0.02s (0s)  Rows=3.0 (6), root[root]@[xxx.xxx.xx.xxx]
      SELECT COUNT(*) FROM information_schema.TABLES WHERE TABLE_SCHEMA = 'S'UNION SELECT COUNT(*) FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = 'S'UNION SELECT COUNT(*) FROM information_schema.ROUTINES WHERE ROUTINE_SCHEMA = 'S'

```

### 慢查询日志的输出方式

修改日志输出格式，默认为file

```
mysql> show variables like 'log_output';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_output    | FILE  |
+---------------+-------+
1 row in set (0.00 sec)

mysql> set global log_output = 'TABLE';
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'log_output';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_output    | TABLE |
+---------------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> select * from user1 where user_age < 8;
(Navicat中执行sql,15.359s)
```

select * from mysql.slow_log;

|     start_time      |           user_host            | query_time | lock_time | rows_sent | rows_examined |  db  | last_insert_id | insert_id | server_id |                           sql_text                           | thread_id |
| :-----------------: | :----------------------------: | :--------: | :-------: | :-------: | :-----------: | :--: | :------------: | :-------: | :-------: | :----------------------------------------------------------: | :-------: |
| 2020-09-21 08:13:26 |   root[root] @ localhost []    |  00:00:00  | 00:00:00  |     0     |       0       | lgt6 |       0        |     0     |     0     |                 select * from mysql.slow_log                 |    372    |
| 2020-09-21 08:14:11 | root[root] @  [xxx.xxx.xx.xxx] |  00:00:00  | 00:00:00  |     0     |       0       | lgt6 |       0        |     0     |     0     | SELECT TABLE_NAME, CHECK_OPTION, IS_UPDATABLE, SECURITY_TYPE, DEFINER FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_SCHEMA = 'lgt6' ORDER BY TABLE_NAME ASC |    370    |
| 2020-09-21 08:14:24 | root[root] @  [xxx.xxx.xx.xxx] |  00:00:00  | 00:00:00  |   16961   |     16961     | lgt6 |       0        |     0     |     0     |            select * from user1 where user_age < 8            |    370    |
| 2020-09-21 08:14:30 | root[root] @  [xxx.xxx.xx.xxx] |  00:00:00  | 00:00:00  |     4     |      77       | lgt6 |       0        |     0     |     0     | SELECT QUERY_ID, SUM(DURATION) AS SUM_DURATION FROM INFORMATION_SCHEMA.PROFILING GROUP BY QUERY_ID |    370    |
| 2020-09-21 08:14:30 | root[root] @  [xxx.xxx.xx.xxx] |  00:00:00  | 00:00:00  |    17     |      128      | lgt6 |       0        |     0     |     0     | SELECT STATE AS `Status`, ROUND(SUM(DURATION),7) AS `Duration`, CONCAT(ROUND(SUM(DURATION)/0.000542*100,3), '') AS `Percentage` FROM INFORMATION_SCHEMA.PROFILING WHERE QUERY_ID=2 GROUP BY SEQ, STATE ORDER BY SEQ |    370    |

## 二进制日志

> 以下内容部分引自[mysql二进制日志总结](https://blog.csdn.net/demonson/article/details/80664141)

### 简介

MySQL的二进制日志（**binary log**）是一个二进制文件，**主要用于记录修改数据或有可能引起数据变更的MySQL语句**。（特殊情况，就算DML语句没有对数据库造成修改，也会被记录）。二进制日志（binary log）中记录了对MySQL数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息，但是它不记录SELECT、SHOW等那些不修改数据的SQL语句。**二进制日志（binary log）主要用于数据库恢复和主从复制，以及审计（audit）操作。**

> 审计是对资料作出证据搜集及分析，以评估企业财务状况，然后就资料及一般公认准则之间的相关程度作出结论及报告。进行审计的人员必需有独立性及具相关专业知识。
>
> 简而言之，防止sql注入和不合业务逻辑的sql

### 参数控制

- log_bin控制二进制日志的开启、关闭
  查看系统变量log_bin，如果其值为OFF，表示没有开启二进制日志（binary log），如果需要开启二进制日志，则必须在my.cnf中[mysqld]下面添加log-bin [=DIR\[filename]] ，DIR参数指定二进制文件的存储路径；filename参数指定二级制文件的文件名。 其中filename可以任意指定，但最好有一定规范。系统变量log_bin是静态参数，不能动态修改的（因为它不是Dynamic Variable）。如下所示：

  ```
  mysql> show variables like 'log_bin';
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | log_bin       | OFF   |
  +---------------+-------+
  1 row in set, 1 warning (0.00 sec)
  
  mysql> set global log_bin = ON;
  ERROR 1238 (HY000): Variable 'log_bin' is a read only variable
  ```

  关闭MySQL服务，修改配置文件，重启MySQL

  ```
  [mysqld]
  log_bin=1
  server-id=1
  
  ---
  mysql5.7若不配置 server-id会报如下错
  ---
  [ERROR] You have enabled the binary log, but you haven’t provided the mandatory server-id. Please refer to the proper server start-up parameters documentation 
  2016-09-03T03:17:51.815890Z 0 [ERROR] Aborting
  ```

  如果在my.cnf里面只设置log_bin，但是不指定file_name，然后重启数据库。会自动生成日志文件。
  以下为查看二进制日志是否开启：

  ```
  mysql> show variables like '%log_bin%';
  +---------------------------------+------------------------+
  | Variable_name                   | Value                  |
  +---------------------------------+------------------------+
  | log_bin                         | ON                     |
  | log_bin_basename                | /var/lib/mysql/1       |
  | log_bin_index                   | /var/lib/mysql/1.index |
  | log_bin_trust_function_creators | OFF                    |
  | log_bin_use_v1_row_events       | OFF                    |
  | sql_log_bin                     | ON                     |
  +---------------------------------+------------------------+
  6 rows in set (0.00 sec)
  
  mysql> show binary logs;
  +----------+-----------+
  | Log_name | File_size |
  +----------+-----------+
  | 1.000001 |       143 |
  | 1.000002 |       120 |
  +----------+-----------+
  2 rows in set (0.00 sec)
  
  mysql> show master logs;
  +----------+-----------+
  | Log_name | File_size |
  +----------+-----------+
  | 1.000001 |       143 |
  | 1.000002 |       120 |
  +----------+-----------+
  2 rows in set (0.00 sec)
  
  mysql> show master status;
  +----------+----------+--------------+------------------+-------------------+
  | File     | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
  +----------+----------+--------------+------------------+-------------------+
  | 1.000002 |      120 |              |                  |                   |
  +----------+----------+--------------+------------------+-------------------+
  1 row in set (0.00 sec)
  ```

### 二进制日志的切换

- **flush logs**

  ```
  mysql> show master status;
  +----------+----------+--------------+------------------+-------------------+
  | File     | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
  +----------+----------+--------------+------------------+-------------------+
  | 1.000002 |      120 |              |                  |                   |
  +----------+----------+--------------+------------------+-------------------+
  1 row in set (0.00 sec)
  
  mysql> flush logs;
  Query OK, 0 rows affected (0.05 sec)
  
  mysql> show master status;
  +----------+----------+--------------+------------------+-------------------+
  | File     | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
  +----------+----------+--------------+------------------+-------------------+
  | 1.000003 |      120 |              |                  |                   |
  +----------+----------+--------------+------------------+-------------------+
  1 row in set (0.00 sec)
  ```

- **重启MySQL服务也会切换一个新的二进制文件**

  ```
  [root@liuguotai ~]# docker ps
  CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
  4709e2f4ee4f        mysql:5.6           "docker-entrypoint..."   4 weeks ago         Up 2 hours          0.0.0.0:3306->3306/tcp   mysql
  
  
  [root@liuguotai ~]# docker restart 4709e2f4ee4f
  4709e2f4ee4f
  
  ---
  重新进入MySQL，查询二进制日志
  ---
  mysql> show master status;
  +----------+----------+--------------+------------------+-------------------+
  | File     | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
  +----------+----------+--------------+------------------+-------------------+
  | 1.000004 |      120 |              |                  |                   |
  +----------+----------+--------------+------------------+-------------------+
  1 row in set (0.00 sec)
  ```

- **可以发现File 这一列的值，在递增。由一个 index 文件维护，里面记录了所有的日志文件**

  ```
  mysql> show variables like 'log_bin_index';
  +---------------+------------------------+
  | Variable_name | Value                  |
  +---------------+------------------------+
  | log_bin_index | /var/lib/mysql/1.index |
  +---------------+------------------------+
  1 row in set (0.00 sec)
  ```

  查看以下这个文件的内容：

  ```
  root@4709e2f4ee4f:/# vim /var/lib/mysql/1.index
  
  ./1.000001
  ./1.000002
  ./1.000003
  ./1.000004
  
  ---
  或者，通过命令查看目前所有的二进制文件
  ---
  mysql> show binary logs;
  +----------+-----------+
  | Log_name | File_size |
  +----------+-----------+
  | 1.000001 |       143 |
  | 1.000002 |       159 |
  | 1.000003 |       143 |
  | 1.000004 |       120 |
  +----------+-----------+
  4 rows in set (0.00 sec)
  ```

### 删除二进制日志文件

- **purge binary logs to xxx; 表示删除某个日志之前的所有二进制日志文件。这个命令会修改index中相关数据**

  ```
  mysql> show binary logs;
  +----------+-----------+
  | Log_name | File_size |
  +----------+-----------+
  | 1.000001 |       143 |
  | 1.000002 |       159 |
  | 1.000003 |       143 |
  | 1.000004 |       120 |
  +----------+-----------+
  4 rows in set (0.00 sec)
  
  mysql> purge binary logs to '1.000002';
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> show binary logs;
  +----------+-----------+
  | Log_name | File_size |
  +----------+-----------+
  | 1.000002 |       159 |
  | 1.000003 |       143 |
  | 1.000004 |       120 |
  +----------+-----------+
  3 rows in set (0.00 sec)
  ```

  然后看看日志文件的目录，发现 之前的日志已被删除

  ```
  root@4709e2f4ee4f:/# ls /var/lib/mysql
  1.000002  1.000003  1.000004  1.index  4709e2f4ee4f-slow.log  auto.cnf	ib_logfile0  ib_logfile1  ibdata1  lgt6  mysql	performance_schema
  ```

- **清除某个时间点以前的二进制日志文件**

  ```
  mysql> purge binary logs before '2017-03-10 10:10:00';
  Query OK, 0 rows affected (0.00 sec)
  ```

- **清除7天前的二进制日志文件**

  ```
  mysql> purge master logs before date_sub( now(), interval 7 day);
  Query OK, 0 rows affected (0.00 sec)
  ```

- **清除所有的二进制日志文件（当前不存在主从复制关系）**

  ```
  mysql> show binary logs;
  +----------+-----------+
  | Log_name | File_size |
  +----------+-----------+
  | 1.000002 |       159 |
  | 1.000003 |       143 |
  | 1.000004 |       120 |
  +----------+-----------+
  3 rows in set (0.00 sec)
  
  mysql> reset master;
  Query OK, 0 rows affected (0.01 sec)
  
  mysql> show binary logs;
  +----------+-----------+
  | Log_name | File_size |
  +----------+-----------+
  | 1.000001 |       120 |
  +----------+-----------+
  1 row in set (0.00 sec)
  ```

- 另外，我们也可以设置**expire_logs_days**参数，设置自动清理，其默认值为0,表示不启用过期自动删除功能，如果启用了自动清理功能，表示超出此天数的二进制日志文件将被自动删除，自动删除工作通常发生在MySQL启动时或FLUSH日志时。

  ```
  mysql> show variables like 'expire_logs_days';
  +------------------+-------+
  | Variable_name    | Value |
  +------------------+-------+
  | expire_logs_days | 7     |
  +------------------+-------+
  1 row in set (0.01 sec)
  
  mysql> set global expire_logs_days=7;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> show variables like 'expire_logs_days';
  +------------------+-------+
  | Variable_name    | Value |
  +------------------+-------+
  | expire_logs_days | 7     |
  +------------------+-------+
  1 row in set (0.01 sec)
  ```

### 相关参数

- ***log_bin_basename***
  系统变量log_bin_basename是MySQL 5.6.2开始引入的。 它表示二进制日志文件名。也不能在my.cnf中配置，否则会报错

  ```
  mysql> show variables like 'log_bin_basename';
  +------------------+------------------+
  | Variable_name    | Value            |
  +------------------+------------------+
  | log_bin_basename | /var/lib/mysql/1 |
  +------------------+------------------+
  1 row in set (0.00 sec)
  ```

- ***log_bin_index***
  

系统变量log_bin_index是MySQL 5.6.4开始引入的。 它表示二进制日志的索引文件。该参数可以在my.cnf中设置。

  ```
  mysql> show variables like 'log_bin_index';
  +---------------+------------------------+
  | Variable_name | Value                  |
  +---------------+------------------------+
  | log_bin_index | /var/lib/mysql/1.index |
  +---------------+------------------------+
  1 row in set (0.00 sec)
  ```

- **log_bin_trust_function_creators**
  系统变量log_bin_trust_function_creators，默认为OFF，这个参数开启会限制存储过程、Function、触发器的创建。

  ```
  mysql> show variables like 'log_bin_trust_function_creators';
  +---------------------------------+-------+
  | Variable_name                   | Value |
  +---------------------------------+-------+
  | log_bin_trust_function_creators | OFF   |
  +---------------------------------+-------+
  1 row in set (0.00 sec)
  ```

- **sql_log_bin**
  系统变量sql_log_bin 用于控制会话级别二进制日志功能的开启或关闭，默认为ON，表示启用二进制日志功能。

  ```
  mysql> show variables like 'sql_log_bin';
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | sql_log_bin   | ON    |
  +---------------+-------+
  1 row in set (0.00 sec)
  ```

- ***expire_logs_days***
  

自动清除二进制日志的天数

- ***binlog_cache_size*** 
  

系统变量binlog_cache_size 表示为**每个客户端**分配binlog_cache_size大小的缓存，默认值32768。**二进制日志缓存使用的前提条件是服务器端使用了支持事务的引擎以及开启了bin log功能，它是MySQL用来提高binlog的效率而设计的一个用于短时间内临时缓存binlog数据的内存区域。**一般来说，如果我们的数据库中没有什么大事务，写入也不是特别频繁，2MB～4MB是一个合适的选择。但是如果我们的数据库大事务较多或多事务语句，写入量比较大，可适当调高binlog_cache_size。同时，我们可以通过binlog_cache_use 以及 binlog_cache_disk_use来分析设置的binlog_cache_size是否足够，是否有大量的binlog_cache由于内存大小不够而使用临时文件（binlog_cache_disk_use）来缓存了。

  所有未提交的二进制日志都会记录到这个缓存中，待事务commit后，再写到磁盘的二进制文件中。

  ```
  mysql> show variables like 'binlog_cache_size';
  +-------------------+-------+
  | Variable_name     | Value |
  +-------------------+-------+
  | binlog_cache_size | 32768 |
  +-------------------+-------+
  1 row in set (0.00 sec)
  
  mysql> show status like 'binlog%';
  +----------------------------+-------+
  | Variable_name              | Value |
  +----------------------------+-------+
  | Binlog_cache_disk_use      | 0     |
  | Binlog_cache_use           | 0     |
  | Binlog_stmt_cache_disk_use | 0     |
  | Binlog_stmt_cache_use      | 0     |
+----------------------------+-------+
  4 rows in set (0.00 sec)
  ```

- ***max_binlog_cache_size*** 
  

系统变量max_binlog_cache_size 二进制日志能够使用的最大cache内存大小。当执行多语句事务时，max_binlog_cache_size 如果不够大，系统可能会报出“Multi-statement transaction required more than ‘max_binlog_cache_size’ bytes of storage”的错误。

  ```
  mysql> show variables like 'max_binlog_cache_size';
  +-----------------------+----------------------+
  | Variable_name         | Value                |
  +-----------------------+----------------------+
  | max_binlog_cache_size | 18446744073709547520 |
  +-----------------------+----------------------+
  1 row in set (0.00 sec)
  ```

- **max_binlog_stmt_cache_size**
  max_binlog_cache_size针对事务语句，max_binlog_stmt_cache_size针对非事务语句，当我们发现Binlog_cache_disk_use或者Binlog_stmt_cache_disk_use比较大时就需要考虑增大cache的大小

  ```
  mysql> show variables like 'max_binlog_stmt_cache_size';
  +----------------------------+----------------------+
  | Variable_name              | Value                |
  +----------------------------+----------------------+
  | max_binlog_stmt_cache_size | 18446744073709547520 |
  +----------------------------+----------------------+
  1 row in set (0.01 sec)
  ```

- ***max_binlog_size***
  

系统变量max_binlog_size， 表示二进制日志的最大值，一般设置为512M或1GB，但不能超过1GB。该设置并不能严格控制二进制日志的大小，尤其是二进制日志比较靠近极限而又遇到一个比较大事务时， 为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的所有SQL都记录进当前日志，直到事务结束。

另外，超过该大小后，日志文件后缀会自动+1.

  ```
  mysql> show variables like 'max_binlog_size';
  +-----------------+------------+
  | Variable_name   | Value      |
  +-----------------+------------+
  | max_binlog_size | 1073741824 |
  +-----------------+------------+
  1 row in set (0.00 sec)
  ```

- **binlog_checksum **
  系统变量binlog_checksum 用作复制的主从校检。 NONE表示不生成checksum，CRC-32表示使用这个算法做校检。

  ```
  mysql> show variables like 'binlog_checksum';
  +-----------------+-------+
  | Variable_name   | Value |
  +-----------------+-------+
  | binlog_checksum | CRC32 |
  +-----------------+-------+
  1 row in set (0.00 sec)
  ```

- ***sync_binlog***
  

这个参数对于Mysql系统来说是至关重要的，它不仅影响到二进制日志文件对MySQL所带来的性能损耗，而且还影响到MySQL中数据的完整性。

 sync_binlog=0，当事务提交后，Mysql仅仅是将binlog_cache中的数据写入binlog文件，但不执行fsync之类的磁盘同步指令通知文件系统将缓存刷新到磁盘，而是让Filesystem自行决定什么时候来做同步。MySQL中默认的设置是 sync_binlog=0，即不作任何强制性的磁盘刷新指令，这个设置性能是最好的，但风险也是最大的。一旦系统崩溃（Crash），在文件系统缓存中的所有二进制日志信息都会丢失。从而带来数据不完整问题。

 sync_binlog=n，表示每写缓冲N次，Mysql将执行一次fsync之类的磁盘同步指令，同时文件系统将Binlog文件缓存刷新到磁盘。

可以适当的调整sync_binlog， 在牺牲一定的一致性下，获取更高的并发和性能。建议设为1.

  ```
  mysql> show variables like 'sync_binlog';
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | sync_binlog   | 1     |
  +---------------+-------+
  1 row in set (0.00 sec)
  ```

- ***binlog_format***

指定二进制日志的类型。分别有STATEMENT、ROW、MIXED三种值。MySQL 5.7.6之前默认为STATEMENT模式。MySQL 5.7.7之后默认为ROW模式。这个参数主要影响主从复制。

  ```
  mysql>  show variables like 'binlog_format';
  +---------------+-----------+
  | Variable_name | Value     |
  +---------------+-----------+
  | binlog_format | STATEMENT |
  +---------------+-----------+
  1 row in set (0.00 sec)
  
  mysql>  set global binlog_format = 'STATEMENT';
  ```

复制的模式有下面几种：

  > 基于SQL语句的复制(statement-based replication, SBR)，
  >
  > 基于行的复制(row-based replication, RBR)，会占用比较大的磁盘空间。
  >
  > 混合模式复制(mixed-based replication, MBR)。
  >
  > 什么时候不得不使用 ROWS 方式？
  >
  > 1. 表的存储引擎为 NDB，这时对表的DML操作都会记录为ROW格式
  > 2. 使用了 UUID()、USER()、CURRENT_USER()等不确定函数
  > 3. 使用了INSERT DELAY语句
  > 4. 使用了用户自定义函数(UDF)
  > 5. 使用了临时表 （temporary table）

  相应地，二进制日志的格式也有三种：STATEMENT，ROW，MIXED。

- log-slave-update

  如果当前数据库是复制中的slave角色，则它不会将从master取得并执行的二进制文件写入到自己二进制日志文件中。如果需要写入，则需要设置 log-slave-update。如果需要搭建 master => slave => slave 此参数必须要。

### 查看二进制日志内容

> 本处数据库为新库，新建test库，新建user1表
>
> CREATE TABLE `user1` (
>   `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键id',
>   `user_name` varchar(100) DEFAULT NULL COMMENT '用户名',
>   `user_age` tinyint(3) DEFAULT NULL COMMENT '用户年龄',
>   `user_password` varchar(100) DEFAULT NULL COMMENT '用户密码',
>   `user_sex` tinyint(1) DEFAULT NULL COMMENT '性别 1-男，0-女',
>   `user_province` varchar(32) DEFAULT NULL COMMENT '用户所在省',
>   `user_city` varchar(32) DEFAULT NULL COMMENT '用户所在城市',
>   `user_area` varchar(32) DEFAULT NULL COMMENT '用户所在区',
>   `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
>   `modified_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
>   PRIMARY KEY (`user_id`),
>   KEY `idx_user_name` (`user_name`),
>   KEY `idx_user_age` (`user_age`),
>   KEY `idx_province_city_area` (`user_province`,`user_city`,`user_area`),
>   KEY `idx_sex` (`user_sex`)
> ) ENGINE=InnoDB AUTO_INCREMENT=223795 DEFAULT CHARSET=utf8;

- **show binlog events;**

  ```
  mysql> show binlog events;
  +----------+-----+----------------+-----------+-------------+---------------------------------------+
  | Log_name | Pos | Event_type     | Server_id | End_log_pos | Info                                  |
  +----------+-----+----------------+-----------+-------------+---------------------------------------+
  | 1.000001 |   4 | Format_desc    |         1 |         123 | Server ver: 5.7.31-log, Binlog ver: 4 |
  | 1.000001 | 123 | Previous_gtids |         1 |         154 |                                       |
  | 1.000001 | 154 | Stop           |         1 |         177 |                                       |
  +----------+-----+----------------+-----------+-------------+---------------------------------------+
  3 rows in set (0.00 sec)
  ```

  Pos:日志开始位置，End_log_pos:日志结束位置

- show binlog events in 'xxxxxxx'

  ```
  mysql> show master status;
  +----------+----------+--------------+------------------+-------------------+
  | File     | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
  +----------+----------+--------------+------------------+-------------------+
  | 1.000010 |     2612 |              |                  |                   |
  +----------+----------+--------------+------------------+-------------------+
  1 row in set (0.00 sec)
  
  mysql> INSERT INTO `user1`(`user_id`, `user_name`, `user_age`, `user_password`, `user_sex`, `user_province`, `user_city`, `user_area`, `create_time`, `modified_time`) VALUES (13717, '963', 33, '38451cbf6a8d4215a86048ed26ea5402', 1, '', '', '', '2020-08-18 15:45:08', '2020-08-18 15:45:08');
  Query OK, 1 row affected (0.02 sec)
  
  mysql> show binlog events in '1.000010';
  +----------+-----+----------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | Log_name | Pos | Event_type     | Server_id | End_log_pos | Info                                                                                                                                                                                                                                                                                                   |
  +----------+-----+----------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | 1.000010 |   4 | Format_desc    |         1 |         123 | Server ver: 5.7.31-log, Binlog ver: 4                                                                                                                                                                                                                                                                  |
  | 1.000010 | 123 | Previous_gtids |         1 |         154 |                                                                                                                                                                                                                                                                                                        |
  | 1.000010 | 154 | Anonymous_Gtid |         1 |         219 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS'                                                                                                                                                                                                                                                                   |
  | 1.000010 | 219 | Query          |         1 |         298 | BEGIN                                                                                                                                                                                                                                                                                                  |
  | 1.000010 | 298 | Query          |         1 |         654 | use `test`; INSERT INTO `user1`(`user_id`, `user_name`, `user_age`, `user_password`, `user_sex`, `user_province`, `user_city`, `user_area`, `create_time`, `modified_time`) VALUES (13717, '963', 33, '38451cbf6a8d4215a86048ed26ea5402', 1, '', '', '', '2020-08-18 15:45:08', '2020-08-18 15:45:08') |
  | 1.000010 | 654 | Xid            |         1 |         685 | COMMIT /* xid=18 */                                                                                                                                                                                                                                                                                    |
  +----------+-----+----------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  6 rows in set (0.00 sec)
  ```

- **mysqlbinlog + 二进制日志绝对路径+文件名** 

  ```
  root@890276bf3194:/# mysqlbinlog /var/lib/mysql/1.000010
  /*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
  /*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
  DELIMITER /*!*/;
  # at 4
  #200922  9:46:58 server id 1  end_log_pos 123 CRC32 0x49962389 	Start: binlog v 4, server v 5.7.31-log created 200922  9:46:58 at startup
  # Warning: this binlog is either in use or was not closed properly.
  ROLLBACK/*!*/;
  BINLOG '
  EshpXw8BAAAAdwAAAHsAAAABAAQANS43LjMxLWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
  AAAAAAAAAAAAAAAAAAASyGlfEzgNAAgAEgAEBAQEEgAAXwAEGggAAAAICAgCAAAACgoKKioAEjQA
  AYkjlkk=
  '/*!*/;
  # at 123
  #200922  9:46:58 server id 1  end_log_pos 154 CRC32 0x0806bc20 	Previous-GTIDs
  # [empty]
  # at 154
  #200922  9:50:53 server id 1  end_log_pos 219 CRC32 0xca81a888 	Anonymous_GTID	last_committed=0	sequence_number=1	rbr_only=no
  SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
  # at 219
  #200922  9:50:53 server id 1  end_log_pos 298 CRC32 0xe66a4371 	Query	thread_id=3	exec_time=0	error_code=0
  SET TIMESTAMP=1600768253/*!*/;
  SET @@session.pseudo_thread_id=3/*!*/;
  SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
  SET @@session.sql_mode=1436549152/*!*/;
  SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
  /*!\C latin1 *//*!*/;
  SET @@session.character_set_client=8,@@session.collation_connection=8,@@session.collation_server=8/*!*/;
  SET @@session.lc_time_names=0/*!*/;
  SET @@session.collation_database=DEFAULT/*!*/;
  BEGIN
  /*!*/;
  # at 298
  #200922  9:50:53 server id 1  end_log_pos 654 CRC32 0x01702e0b 	Query	thread_id=3	exec_time=0	error_code=0
  use `test`/*!*/;
  SET TIMESTAMP=1600768253/*!*/;
  INSERT INTO `user1`(`user_id`, `user_name`, `user_age`, `user_password`, `user_sex`, `user_province`, `user_city`, `user_area`, `create_time`, `modified_time`) VALUES (13717, '963', 33, '38451cbf6a8d4215a86048ed26ea5402', 1, '', '', '', '2020-08-18 15:45:08', '2020-08-18 15:45:08')
  /*!*/;
  # at 654
  #200922  9:50:53 server id 1  end_log_pos 685 CRC32 0x9b835679 	Xid = 18
  COMMIT/*!*/;
  SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
  DELIMITER ;
  # End of log file
  /*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
  /*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
  ```

- **mysqlbinlog + 二进制日志绝对路径+文件名 > test.sql**
  在哪里执行，就会在当前路径下生成sql文件

  ```
  mysqlbinlog /var/lib/mysql/1.000010 > test.sql
  
  root@890276bf3194:/# ls
  bin  boot  dev	docker-entrypoint-initdb.d  entrypoint.sh  etc	home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  test.sql  tmp  usr	var
  
  root@890276bf3194:/# mysqlbinlog /var/lib/mysql/1.000010 > test.sql
  。。。内容与上边一致，此处省略
  ```

- **如果是 ROW 格式，则使用 mysqlbinlog -vv 二进制日志绝对路径+文件名**
  （注意此处，是  - V V 不是 - W）

### **开启二进制日志影响性能吗？**

开启MySQL的二进制日志会影响服务器性能吗？答案是会有一些性能损耗，但是性能开销非常小，1%左右（slightly slower），另外，开启binlog带来的好处要远远超过带来的性能开销。官方文档的介绍如下所示：

**Running a server with binary logging enabled makes performance slightly slower. However, the benefits of the binary log in enabling you to set up replication and for restore operations generally outweigh this minor performance decrement.**

## 查询日志

> 以下部分内容引自[Mysql查询日志](https://www.cnblogs.com/ray-mr-huang/p/10466692.html)

**MySQL的查询日志记录了所有MySQL数据库请求的信息**。**无论这些请求是否得到了正确的执行**。默认文件名为hostname.log。默认情况下MySQL查询日志是关闭的。**生产环境，如果开启MySQL查询日志，对性能还是有蛮大的影响的。**另外很多时候，MySQL慢查询日志基本可以定位那些出现性能问题的SQL，所以MySQL查询日志应用的场景其实不多，有点鸡肋的感觉，它跟SQL Server中的profiler有点类似，但是这个不能跟踪某个会话、用户、客户端。它只能对整个数据库进行跟踪。MySQL查询日志本身比较简单，网上介绍的不多，官方资料也就那么短短一篇。

### 参数控制

- MySQL中的参数**general_log**用来控制开启、关闭MySQL查询日志,参数**general_log_file**用来控制查询日志的位置。所以如果你要判断MySQL数据库是否开启了查询日志，可以使用下面命令。general_log为ON表示开启查询日志，OFF表示关闭查询日志。
- **log_output**控制日志输出格式，**FILE**输出为文件，默认地址可进行查看。**TABLE**输出为表格，再**mysql.general_log**中

```
mysql> show variables like '%general_log%';
+------------------+---------------------------------+
| Variable_name    | Value                           |
+------------------+---------------------------------+
| general_log      | OFF                             |
| general_log_file | /var/lib/mysql/4709e2f4ee4f.log |
+------------------+---------------------------------+
2 rows in set, 1 warning (0.00 sec)

mysql> set global general_log = ON;
Query OK, 0 rows affected (0.01 sec)

mysql> show variables like '%general_log%';
+------------------+---------------------------------+
| Variable_name    | Value                           |
+------------------+---------------------------------+
| general_log      | ON                              |
| general_log_file | /var/lib/mysql/4709e2f4ee4f.log |
+------------------+---------------------------------+
2 rows in set, 1 warning (0.00 sec)

mysql> show variables like 'log_output';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_output    | FILE  |
+---------------+-------+
1 row in set, 1 warning (0.00 sec)
```

> 简单看看日志记录 时间采用格林尼治时间，加8个小时为北京时间
>
> C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld.exe, Version: 5.7.28-log (MySQL Community Server (GPL)). started with:
> TCP Port: 3306, Named Pipe: MySQL
> Time                 Id Command    Argument
> 2020-09-22T02:01:20.582539Z	   32 Query	show variables like '%log%'
> 2020-09-22T02:01:40.078835Z	   32 Query	select * from user1 where user_id = 135643
> 2020-09-22T02:01:59.132562Z	   33 Init DB	mysql
> 2020-09-22T02:01:59.133062Z	   33 Query	SELECT * FROM `mysql`.`general_log` LIMIT 0, 1000
> 2020-09-22T02:01:59.135145Z	   34 Init DB	mysql
> 2020-09-22T02:01:59.135483Z	   34 Query	SHOW COLUMNS FROM `mysql`.`general_log`
> 2020-09-22T02:01:59.136795Z	   33 Query	SHOW TABLE STATUS LIKE 'general_log'
> 2020-09-22T02:01:59.138354Z	   33 Query	SHOW CREATE TABLE `mysql`.`general_log`
> 2020-09-22T02:02:25.570595Z	   35 Connect	root@localhost on  using SSL/TLS
> 2020-09-22T02:02:25.571317Z	   35 Query	select @@version_comment limit 1
> 2020-09-22T02:02:38.818566Z	   35 Query	show variables like '%log%'
> 2020-09-22T02:03:07.598350Z	   35 Query	SELECT DATABASE()
> 2020-09-22T02:03:07.598705Z	   35 Init DB	testmybatis

关闭查询日志记录（性能影响太大）

```
mysql> set global general_log = OFF;
Query OK, 0 rows affected (0.01 sec)

mysql> show variables like '%general_log%';
+------------------+---------------------------------+
| Variable_name    | Value                           |
+------------------+---------------------------------+
| general_log      | OFF                             |
| general_log_file | /var/lib/mysql/4709e2f4ee4f.log |
+------------------+---------------------------------+
2 rows in set, 1 warning (0.00 sec)
```



---

# socket文件

用UNIX域本地连接MySQL时，所需要的文件

---

# pid文件

MySQL实例进程ID的文件

---

# MySQL表文件

## MYISAM的表文件

### **表定义文件：表名.frm**

### **索引文件：表名.MYI**

### **数据文件：表名.MYD**

## InnoDB的表文件

### **表定义文件：表名.frm**

### **共享表空间文件：ibdata1**

```
# 查看默认的表空间文件及一些信息

mysql> show variables like 'innodb_data_file_path';
+-----------------------+------------------------+
| Variable_name         | Value                  |
+-----------------------+------------------------+
| innodb_data_file_path | ibdata1:12M:autoextend |
+-----------------------+------------------------+
1 row in set, 1 warning (0.00 sec)
```

可以在my.cnf配置文件里配置多个表空间文件：

```
[mysqld]
innodb_data_file_path = /db/ibdata:2000M;/db2/ibdata2:2000M:autoextend
```

用两个文件组成共享表空间，若这两个文件在不同的磁盘上，	磁盘的负载将会被平均，可以提升数据库的整体性能。

autoextend：表示用完了指定的大小空间后，会自增。

### **私有表空间文件：表名.ibd**
开启参数 innodb_file_per_table 后，会为没一张表提供一个独立的表空间，用于存放**数据、索引、插入缓冲BITMAP**。默认为开启状态

```
mysql> show variables like 'innodb_file_per_table';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_file_per_table | ON    |
+-----------------------+-------+
1 row in set, 1 warning (0.00 sec)
```

### **重做日志文件（redo log file）**

每个InnoDB至少有一个重做日志组，一组中包含两个文件。即，默认只有一个组， ib_logfile0 和 ib_logfile1 。将不同的文件组放在不同的磁盘上，可以提升性能。 ib_logfile0 和 ib_logfile1 文件大小相同，以循环写入的方式运行。0写满时，会切换到1，1写满后，会切换到0。默认在InnoDB引擎的数据文件目录下

#### 作用

记录InnoDB的事务日志，当实例或介质失败时，可以用redo log恢复数据，保证数据完整性。

确保事务的持久性。

#### 参数

1. **innodb_log_file_size**
   用于指定重做日志的大小。在InnoDB1.2.x之前，重做日志大小不得大于等于4G，1.2.x之后，将该限制扩大到512G

   ```
   mysql> show variables like 'innodb_log_file_size';
   +----------------------+----------+
   | Variable_name        | Value    |
   +----------------------+----------+
   | innodb_log_file_size | 50331648 |
   +----------------------+----------+
   1 row in set, 1 warning (0.00 sec)
   ```

2. **innodb_log_files_in_group**
   一个组内重做日志的数量，默认为2

   ```
   mysql> show variables like 'innodb_log_files_in_group';
   +---------------------------+-------+
   | Variable_name             | Value |
   +---------------------------+-------+
   | innodb_log_files_in_group | 2     |
   +---------------------------+-------+
   1 row in set, 1 warning (0.00 sec)
   ```

3. **innodb_log_group_home_dir**
   日志文件组所在的路径，即MySQL data文件的路径

   ```
   mysql> show variables like 'innodb_log_group_home_dir';
   +---------------------------+-------+
   | Variable_name             | Value |
   +---------------------------+-------+
   | innodb_log_group_home_dir | .\    |
   +---------------------------+-------+
   1 row in set, 1 warning (0.00 sec)
   ```

#### 大小限制
重做日志的大小，对InnoDB的性能有很大影响。
设置的过大，恢复的时候，需要很长时间；设置的过小，一个大事务会频繁切换文件，发生asyn checkpoint，发生性能抖动。

#### 重做日志条目结构

在InnoDB 存储引擎中，对于不同的操作有不同的重做日志格式。到1.2.x为止，有51种重做日志类型。虽然类型不同，但格式一样
下表展示重做日志每个条目的格式：

> |    redo_log_type    |      space       | page_no  |                    redo_log_body                     |
> | :-----------------: | :--------------: | :------: | :--------------------------------------------------: |
> | 1字节，重做日志类型 | >4字节，表空间id | 页偏移量 | 每个重做日志的数据部分，恢复时需要调用相应的函数解析 |

#### 内容

物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。如，偏移量80，写‘ddd’操作。

#### 什么时候产生

事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。

#### 什么时候释放

当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。

#### 重做日志的写入过程

前面提到，redo log 是在事务开始之后逐步写入到磁盘的。
　　之所以说重做日志是在事务开始之后逐步写入磁盘的重做日志文件，而不一定是事务提交才写入重做日志。
　　原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M,Innodb存储引擎先将重做日志写入innodb_log_buffer中，再以一定频率刷新到磁盘。

![1.4.0.redo log的写入过程](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/redo%20Log%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.jpg)

会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘

　　1. Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。
        　　2. 每个事务提交时会将重做日志刷新到重做日志文件。受参数 innodb_flush_log_at_trx_commit 控制
            　　3. 当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件

由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。
　　因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。
　　另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：
　　即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。从重做日志缓冲往磁盘写入时，是按512字节也就是一个扇区的大小写入的。因为扇区是最小的写入单位，因此可以保证写入必定成功。因此不需要Double Write。
　　这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。

参数 innodb_flush_log_at_trx_commit 可设置为0,1,2。其中：

- 0，代表当提交事务时，并不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新。

- 1，每次事务commit时将重做日志缓冲同步写到磁盘；建议设为1.

- 2， 代表重做日志异步到磁盘，即不能完全保证commit时肯定会写入重做日志文件，只是有这个动作。



---

# 二进制日志文件 和 重做日志 之间的区别

1. 记录的范围不同
   - binlog，是基于MySQL数据库的，记录InnoDB、MYISAM等所有存储引擎的修改记录。
   - redo log，只记录跟InnoDB有关的事务日志
2. 记录的内容不同
   - binlog是逻辑日志，记录的是 ROW 或 STATEMENT ，具体的操作内容，或完整的sql。
   - redo log是物理日志，记录的是页的修改信息。例如：偏移量80，写‘ddd’操作。
3. 写入时间不同
   - binlog，只在事务提交前进行写入，不论事务多大，只写入一次
   - redo log，在事务进行过程中，不断被写入重做日志文件中
4. 日志文件本身
   - binlog：MySQL服务重启、FLUSH LOGS、超过文件大小都会切换新的日志文件。文件名会递增+1
   - redo log，默认只有一个组，组内有两个重做日志，ib_logfile0 和 id_logfile1。循环写入，不会增加
5. 释放时间不同
   - binlog：binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。默认为0，不自动删除
   - redo log：对应事务的脏页刷新到磁盘后，该事务所占的空间就可以被覆盖。可以理解为被释放。Write指针会覆盖这段空间。
6. 文件大小限制
   - binlog的最大限制不严格，假设临近最大值，来了一个大事务，此时不会截断该事务的日志。会完整的记录到二进制文件中。允许超过最大限制。
   - redo log是循环利用的，所以，一旦超过文件限定大小，便切换另一个重做日志
7. 作用不同
   - binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的
   - redo log是保证事务的持久性的，是事务层面的。
8. 恢复数据的效率不同
   - redo log是记录页的修改信息，恢复效率高于bin log

# 日志文件的其他问题

1. **关于事务提交时，redo log和binlog的写入顺序：**
   为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的，
   　　MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。
2. **redo log是事务在执行过程中不断写入的，假如我事务回滚了，undo log肯定会被删除，那redo是不是也得删除？**
3. **redo log一开始被写到缓存中，master thread每秒会刷新到磁盘，一秒内事务回滚，会删缓存吗？**
4. 