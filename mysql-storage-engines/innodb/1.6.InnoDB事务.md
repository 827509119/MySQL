# 概念

事务是数据库区别于文件系统的重要特征之一。在文件系统中，写文件写到一半，操作系统崩溃了，这个文件很有可能被破坏。所以，这正是数据库引入事务的主要目的：**事务会把数据库从一种一致性状态转换为另一种一致性状态。在数据库进行提交操作时，可以保证，要么所有所有修改都成功了，要么修改都不保存。**

事务可以由一条简单的SQL组成，也可以由一组复杂的SQL组成。要么都成功，要么都不成功。

# 分类

从事务理论的角度来看，可以把事务分为以下五种类型：

- 扁平事务(Flat Transactions)
- 带有保存点的扁平事务(Flat Transactions with Savepoints)
- 链事务(Chained Transactions)
- 嵌套事务(Nested Transactions)
- 分布式事务(Distributed Transactions)

## 1. 扁平事务

扁平事务 是事务类型中最简单的一种，但是在实际生产环境中，这可能是使用最频繁的事务，在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚，因此扁平事务是应用程序称为原子操作的的基本组成模块

下面显示了扁平事务的三种不同结果：

![1.6.0.扁平事务](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.0.%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1.jpg)

给出的扁平事务的三种情况，同时也给出了一个典型的事务处理应用中，每个结果大概占用的百分比。再次提醒，扁平事务虽然简单，但是在实际环境中使用最为频繁，也正因为其简单，使用频繁，故**每个数据库系统都实现了对扁平事务的支持**。

**扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交**。
下面给出一个扁平事务不足以支持的例子。例如用户在旅行网站上进行自己的旅行度假计划，用户设想从杭州到意大利的佛罗伦萨，这两个城市没有直达的班机，需要用户预订并转呈航班，需要或者搭火车等待。用户预订旅行度假的事务为

```
S1：预订杭州到上海的高铁

S2：上海浦东国际机场坐飞机，预订到米兰的航班

S3：在米兰转火车前往佛罗伦萨，预订去佛罗伦萨的火车
12345
```

但是当用户执行到S3时，发现由于飞机到达米兰的时间太晚，已经没有当天的火车，这时用户希望在米兰当地住一晚，第二天出发去佛罗伦萨。这时如果事务为扁平事务，需要回滚之前S1 S2 S3的三个操作，这个代价明显很大，因为当再次进行该事务是，S1 S2的执行计划是不变的，也就是说，如果支持有计划的回滚操作，那么不需要终止整个事务，因此就出现了**带有保存点的扁平事务**。

## 2. 带有保存点的扁平事务

带有保存点的扁平事务 除了支持扁平事务支持的操作外，允许在事务执行过程中回滚同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销太大，保存点用来通知事务系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。

对于扁平的事务来说，隐式的设置了一个保存点。然而整个事务中，只有这一个保存点，因此，回滚只能会滚到事务开始时的状态，保存点用SAVE WORK函数来建立，通知系统记录当前的处理状态。当出现问题时，保存点能用作内部的重启动点，根据应用逻辑，决定是回到最近一个保存点还是其他更早的保存点。图显示了事务中使用的保存点

![1.6.1.带有保存点的扁平事务](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.1.%E5%B8%A6%E6%9C%89%E4%BF%9D%E5%AD%98%E7%82%B9%E7%9A%84%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1.jpg)

显示了如何在事务中使用保存点，灰色背景部分表示由ROLLBACK WORK而导致部分回滚，实际并没有执行操作，当用BEGIN WORK开启一个事务时，隐式地包含了一个保存点，当事务通过ROLLBACK WORK：2发出部分回滚命令时，事务会滚到保存点2，接着依次执行，并再次执行到ROLLBACK WORK：7，知道最后COMMIT WORK操作，表示事务结束，除灰色阴影部分的操作外，其余操作都已经执行，并且提交。

另一个需要注意的是，保存点在事务内部是**递增**的，从图中可以看出，有人可能会想，返回保存点2以后，下一个保存点可以为3，因为之前的工作已经终止，然而新的保存点编号为5，这意味着ROLLBACKU 不影响保存点的计数，并且单调递增编号能保持事务执行的整个历史过程，包括在执行过程中想法的改变。

此外，当事务通过ROLLBACK WORK：2命令发出部分回滚命令时，要记住事务并没有完全被回滚，只是回滚到保存点2而已，这代表当前事务是活跃的，如果想要回滚事务，还需要执行ROLLBACKUP WORK。

## 3. 链事务

链事务 可视为保存点模式的一种变种，带有保存点的扁平事务，当发生系统崩溃是，所有的的保存点都将消失，因为其保存点是易失的，这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行

链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作 将合并为一个原子操作，这意味着下一个事务将看到上一个事务的结果，就好像一个事务中进行的一样，如图显示了链事务的工作方式：

![1.6.2.链事务](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.2.%E9%93%BE%E4%BA%8B%E5%8A%A1.png)

链事务与带有保存点的扁平事务不同的是，带有保存点的扁平事务能回滚到任意正确的保存点，而链事务中的回滚仅限当前事务，即只能恢复到最近的一个保存点，对于锁的处理，两者也不相同，锁事务在执行COMMIT后即释放了当前所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的锁。

## 4. 嵌套事务

嵌套事务 是一个层次结构框架，由一个顶层事务(top-level transaction)控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务，其控制每一个局部的变换，结构如下

![1.6.3.嵌套事务](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.3.%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1.png)

下面给出MOSS对嵌套事务的定义

1. 嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务也可以是扁平事务
2. 处在叶节点的事务是扁平事务，但是每个事务从根到叶节点的距离可以说是不同的
3. 位于根节点的事务称为顶层事务，其他称为自事务。事务的前驱称(predecessor)为父事务(parent)，事务的下一层称为儿子事务(child)
4. 子事务既可以提交也可以回滚。但是它的提交操作并不马上生效。除非其父事务已经提交。因此可以推论出，任何子事务都在顶层事务提交后才真正的提交
5. 树中的任意事务回滚会引起它的所有子事务一同回滚，故子事务仅保留ACI特性而不具有D特性

在Moss的理论中，实际的工作是交由叶子节点完成，即只有叶子节点的事务才能才能访问数据库、发送信息、获取其他类型的资源。而高层的事务仅负责逻辑控制。决定合适调用相关的子事务。即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务，如图

![1.6.4.嵌套事务2](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.4.%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A12.png)

如图可以发现，在恢复时采用保存点技术比嵌套查询有更大的灵活性。例如在完成Tk3这事务时，可以会滚到保存点S2的状态。而在嵌套查询的层次结构中，这是不被允许的。

但是用保存点技术来模拟嵌套事务在锁的持有方面还是与嵌套查询有些区别。当通过保存点技术来模拟嵌套事务时，用户无法选择哪些锁需要被子事务集成，哪些需要被父事务保留，这就是说，无论有多少个保存点，所有被锁住的队形都可以被得到和访问。而在嵌套查询中，不同的子事务在数据库对象上持有的锁是不同观点。例如一个父事务P1 其持有对象X和Y的排他锁，现在要开始调用子事务P11 ,那么父事务P1 可以不传递锁，也可以传递所有的锁，也可以只传递一个排他锁，如果子事务P11 中还持有对象Z的排他锁，那么通过反向继承(counter-inherited)父事务P1 将持有3个对象X Y Z的排他锁。如果这时再次调用一个子事务P12 ，那么它可以传递哪里已经持有的锁。

然而，如果系统支持嵌套事务中并行地执行的各个子事务，在这种情况下，采用保存点的扁平事务来模拟嵌套事务就不切实际了。这从另一个方面反映出，**想要实现事务间的并行性，需要真正支持的嵌套事务。**

## 5. 分布式事务

分布式事务 通常是一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。

假如一个用户在ATM机上进行银行的转账操作，例如持卡人从招商银行存储卡转账10 000 元到工商银行的存储卡。这种情况下，可以将ATM机视为节点A，招商银行的后台数据库视为节点B，工商银行的后台数据库视为C，这个转账的操作可分解为以下的步骤

```
1. 节点A发出转账命令

2. 节点B执行存储卡中的余额减去10 000

3. 节点C执行存储卡终端的余额增加10 000

4. 节点A通知用户操作完成或者节点A通知用户操作失败
```

这里需要使用到分布式事务，因为节点A不能通过一台数据库就完成任务，其需要访问网络中两个节点的数据库，而在每个节点的数据库执行的实务操作有都是扁平的，对于分布式事务，其同样需要满足ACID特性，要么都发生，要么都失败。对于上述例子，如果2 3 步中任何一个操作失败，都会导致整个分布式事务回滚，若非这样，结果非常可怕。

对于**InnoDB存储引擎**来说，其支持**扁平事务**，**带保存点的事务**，**链事务**，**分布式事务**。对于嵌套事务，其原生不支持。因此对有**并发事务需求**的用户来说,MySQL数据库或InnoDB存储引擎就显得无能为力，然而用户仍可以通过带保存点的事务来模拟串行的嵌套事务。

# 事务实现的基础

## 1.redo log

redo log叫做**重做**日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当**事务提交之后**会把所有修改信息都会存到该日志中。

在数据库的运行过程中，不需要对 redo log 进行读取。只有服务器宕机，数据丢失后才会读取。

关于 redo log 之前已经讨论过，这里不在赘述。

## 2. undo log

undo log 用来保证事务的回滚 及 MVCC 的实现。

undo log 在运行过程中会随机读取，因为 MVCC 的原因。

**undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。**

# 事务的状态

- active

  开启事务后，事务进入active状态

- prepare
  当事务完成需要提交时，为了和BINLOG做XA，InnoDB的commit被划分成了两个阶段：prepare阶段和commit阶段，本小节主要讨论下prepare阶段undo相关的逻辑。

  为了在崩溃重启时知道事务状态，需要将事务设置为Prepare，MySQL 5.7对临时表undo和普通表undo分别做了处理，前者在写undo日志时总是不需要记录redo，后者则需要记录。

  分别设置insert undo 和 update undo的状态为prepare，调用函数trx_undo_set_state_at_prepare，过程也比较简单，找到undo log slot对应的头页面(trx_undo_t::hdr_page_no)，将页面段头的TRX_UNDO_STATE设置为TRX_UNDO_PREPARED，同时修改其他对应字段，如下图所示（对于外部显式XA所产生的XID，这里不做讨论）：
  ![1.6.5.事务prepare状态](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.5.%E4%BA%8B%E5%8A%A1prepare%E7%8A%B6%E6%80%81.png)

- commit
  commit后进入commit状态

# 事务的隔离级别

# 事务的特性

**ACID:**该ACID模式是一组数据库设计原则强调的是，对于业务数据和关键任务应用重要的可靠性方面。MySQL包含诸如`InnoDB`存储引擎严格遵循ACID模型，因此数据不会损坏，结果也不会因软件崩溃和硬件故障等异常情况而失真。当您依靠符合ACID的功能时，无需重新发明一致性检查和崩溃恢复机制。如果您有其他软件保护措施，超可靠的硬件或可以容忍少量数据丢失或不一致的应用程序，则可以调整MySQL设置以牺牲一些ACID可靠性，以获得更高的性能或吞吐量。

- **原子性（atomicity）**
  每个事务是最小单位，不可再分割。只有事务中的所有操作都成功，才算成功。只要有一个失败，即为失败。数据库的状态需要回退到执行事务之前的状态。
- **一致性（consistency）**
  事务将数据库从一种一致性状态，转变为另一种一致性状态。在事务开始之前和事务结束之后，数据库的完整性约束没有遭到破坏。例如，数据库中有个姓名字段为唯一约束，不能重复。如果一个事务对该字段进行了修改，在事务提交或回滚后，表中的姓名字段重复了，这就破坏了唯一性要求。从一致性状态变为不一致性状态。
- **隔离性（isolation）**
  多个事务之间，读写互相分离，在事务提交前，对其他事务不可见。
- **持久性（durability）**
  事务一旦提交，其结果是永久性的，不管是MySQL挂了，还是服务器宕机，都不能丢失结果。

**理论上，事务有严格的要求，即ACID特性。但数据库厂商处于各种目的，并没有严格遵守。**有时候不会导致严重的后果，反而会有性能上的提升。例如，MySQL的 NDB Cluster引擎虽然支持事务，但不满足持久性的要求；Oracle的默认隔离级别为 RC 不满足 隔离性的要求。**InnoDB存储引擎完全遵守了ACID。**

# 事务的实现

前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。

- 事务的原子性主要涉及InnoDB的事务。是通过 undo log 来实现的，相关的MySQL功能
  1. 设置自动提交
  2. 声明 COMMIT
  3. 声明 ROLLBACK
  4. `INFORMATION_SCHEMA` 表中的 操作数据。
- 事务的持久性性是通过 redo log 来实现的。涉及与特定硬件配置交互的MySQL软件功能。由于取决于您的CPU，网络和存储设备的功能的可能性很多，因此为具体的准则提供最复杂的方面。（这些准则可能采取购买“ 新硬件 ”的形式 。）相关的MySQL功能包括：
  1. `InnoDB` [doublewrite buffer](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_doublewrite_buffer)，由[`innodb_doublewrite`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_doublewrite) 配置选项打开和关闭
  2. 配置选项 [`innodb_flush_log_at_trx_commit`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit)，配置提交时刷新redo log策略
  3. 配置选项 [`sync_binlog`](https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_sync_binlog)commit的时候，刷新二进制日志到磁盘策略
  4. 配置选项 [`innodb_file_per_table`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_per_table)为每个表开启独立表空间
  5. 存储设备（例如磁盘驱动器，SSD或RAID阵列）中的写缓冲区。
  6. 电池后备存储设备中的缓存。
  7. 用来运行MySQL的操作系统，特别是它对`fsync()`系统调用的支持。
  8. 不间断电源（UPS）保护运行MySQL服务器并存储MySQL数据的所有计算机服务器和存储设备的电源。
  9. 您的备份策略，例如备份的频率和类型以及备份保留期。
  10. 对于分布式或托管数据应用程序，MySQL服务器的硬件所位于的数据中心的特定特性，以及数据中心之间的网络连接。
- 事务的隔离性是通过 (读写锁+MVCC)来实现的,主要涉及`InnoDB` [事务](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_transaction)，尤其是适用于每个事务的[隔离级别](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level)。相关的MySQL功能包括：
  1. 自动提交的设置
  2.  声明`SET ISOLATION LEVEL`
  3. `InnoDB` [锁定](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking) 的底层细节。在性能调整期间，您可以通过`INFORMATION_SCHEMA`表格查看这些详细信息 
- 而事务的终极大 boss **一致性**是通过原子性，持久性，隔离性来实现的，主要涉及内部`InnoDB`处理，以防止数据崩溃！！！相关的MySQL功能
  1. `InnoDB` [doublewrite缓冲区](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_doublewrite_buffer)。
  2. `InnoDB` [崩溃恢复](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_crash_recovery)。

**原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！**

总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。

# 多版本并发控制 - MVCC

## （一）简介 - 来源官网，建议背诵全文

`InnoDB`是一个 [多版本的存储引擎](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_mvcc)：它保留有关已更改行的旧版本的信息，以支持诸如并发和[回滚之](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback)类的事务功能 。此信息以称为[回滚段](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback_segment)的数据结构存储在表空间中 （在Oracle中类似的数据结构之后）。`InnoDB` 使用回滚段中的信息来执行事务回滚中所需的撤消操作。它还使用该信息来构建行的早期版本，以实现 [一致的读取](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read)。

在内部，`InnoDB`向数据库中存储的每一行添加三个字段：

- `DB_TRX_ID`字段：6字节，指示插入或更新该行的最后一个事务的事务id。
- `DB_ROLL_PTR`字段：7字节，称为回滚指针。回滚指针指向写入回滚段的撤消日志记录。如果行已更新，则撤消日志记录将包含在更新行之前重建行内容所必需的信息。此外，删除在内部被视为更新，在该更新中，该行中的特殊位被设置为将其标记为已删除。
- `DB_ROW_ID`字段：6字节，包含一个行ID，该ID在插入新行时会单调增加。如果 `InnoDB`自动生成聚集索引，该索引包含行ID值。否则，该 `DB_ROW_ID`列不会出现在任何索引中。（不显示指定主键的时候）

***重点：只在聚簇索引，即真实数据行中。***

**回滚段中的撤消日志分为插入和更新撤消日志。插入撤消日志仅在事务回滚中才需要，并且在事务提交后可以立即将其丢弃。更新撤消日志也用于一致的读取，但是只有在不存在为其`InnoDB`分配了快照的事务（ 一致的读取可能需要更新撤消日志中的信息来构建数据库的早期版本）后，才能将其撤消行。**

定期提交您的事务，包括仅发出一致读取的交易。否则， `InnoDB`将无法丢弃更新撤消日志中的数据，并且回滚段可能会变得太大而填满表空间。

回滚段中撤消日志记录的物理大小通常小于相应的插入或更新的行。您可以使用此信息来计算回滚段所需的空间。

在`InnoDB`多版本方案中，当您使用SQL语句删除行时，并不会立即将其从数据库中物理删除。`InnoDB`仅在丢弃为删除而编写的更新撤消日志记录时，才物理删除相应的行及其索引记录。此删除操作称为[purge](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_purge)，它非常快，通常花费与执行删除操作的SQL语句相同的时间顺序。

如果您在表中以几乎相同的速度以较小的批插入和删除行，那么清除线程就会开始滞后，并且由于所有“死”行，表可能会变得越来越大，从而使所有内容都绑定到磁盘上，并且非常慢。在这种情况下，通过调优innodb_max_purge_lag系统变量来控制新的行操作，并为清除线程分配更多的资源。

## （二）MVCC对聚簇索引和二级索引的处理方式的区别

`InnoDB`多版本并发控制（MVCC）对二级索引的处理方式不同于聚簇索引。聚簇索引中的记录将**就地更新**，其隐藏的系统列指向撤消日志条目，可以从中重建记录的早期版本。与聚簇索引记录不同，辅助索引记录不包含隐藏的系统列，也不会就地更新。

更新二级索引列时，将对旧的二级索引记录进行删除标记，插入新记录，并最终清除带有删除标记的记录。当二级索引记录被删除标记或二级索引页被较新的事务更新时，`InnoDB`在聚集索引中查找数据库记录。在聚集索引中，`DB_TRX_ID`检查记录，如果在启动读取事务后修改了记录，则从撤消日志中检索记录的正确版本。

如果二级索引记录被标记为删除或二级索引页被更新的事务更新， 则不使用[覆盖索引](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_covering_index)技术。不是从索引结构中返回值，而是`InnoDB`在聚集索引中查找记录。

但是，如果启用了 [索引条件下推（ICP）](https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html)优化，并且`WHERE`仅可以使用索引中的字段来评估部分条件，则MySQL服务器仍会将`WHERE`条件的这一部分下推到存储引擎，并使用索引。如果在删除标记的记录中，找不到匹配的记录，则避免聚集索引查找(使用undo log中的旧版数据)。如果找到了匹配的记录，即使在删除标记的记录中，则在 `InnoDB`聚簇索引中查找记录。





> 引自：
>
> 1. 《MYSQL技术内幕 InnoDB存储引擎》
> 2. [MySQL中事务的五种分类](https://blog.csdn.net/qq_41333582/article/details/84196964)