# 概念

事务是数据库区别于文件系统的重要特征之一。在文件系统中，写文件写到一半，操作系统崩溃了，这个文件很有可能被破坏。所以，这正是数据库引入事务的主要目的：**事务会把数据库从一种一致性状态转换为另一种一致性状态。在数据库进行提交操作时，可以保证，要么所有所有修改都成功了，要么修改都不保存。**

事务可以由一条简单的SQL组成，也可以由一组复杂的SQL组成。要么都成功，要么都不成功。

# 分类

从事务理论的角度来看，可以把事务分为以下五种类型：

- 扁平事务(Flat Transactions)
- 带有保存点的扁平事务(Flat Transactions with Savepoints)
- 链事务(Chained Transactions)
- 嵌套事务(Nested Transactions)
- 分布式事务(Distributed Transactions)

## 1. 扁平事务

扁平事务 是事务类型中最简单的一种，但是在实际生产环境中，这可能是使用最频繁的事务，在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚，因此扁平事务是应用程序称为原子操作的的基本组成模块

下面显示了扁平事务的三种不同结果：

![1.6.0.扁平事务](../..//mysql-image/1.6.0.%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1.jpg)

给出的扁平事务的三种情况，同时也给出了一个典型的事务处理应用中，每个结果大概占用的百分比。再次提醒，扁平事务虽然简单，但是在实际环境中使用最为频繁，也正因为其简单，使用频繁，故**每个数据库系统都实现了对扁平事务的支持**。

**扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交**。
下面给出一个扁平事务不足以支持的例子。例如用户在旅行网站上进行自己的旅行度假计划，用户设想从杭州到意大利的佛罗伦萨，这两个城市没有直达的班机，需要用户预订并转呈航班，需要或者搭火车等待。用户预订旅行度假的事务为

```
S1：预订杭州到上海的高铁

S2：上海浦东国际机场坐飞机，预订到米兰的航班

S3：在米兰转火车前往佛罗伦萨，预订去佛罗伦萨的火车
12345
```

但是当用户执行到S3时，发现由于飞机到达米兰的时间太晚，已经没有当天的火车，这时用户希望在米兰当地住一晚，第二天出发去佛罗伦萨。这时如果事务为扁平事务，需要回滚之前S1 S2 S3的三个操作，这个代价明显很大，因为当再次进行该事务是，S1 S2的执行计划是不变的，也就是说，如果支持有计划的回滚操作，那么不需要终止整个事务，因此就出现了**带有保存点的扁平事务**。

## 2. 带有保存点的扁平事务

带有保存点的扁平事务 除了支持扁平事务支持的操作外，允许在事务执行过程中回滚同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销太大，保存点用来通知事务系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。

对于扁平的事务来说，隐式的设置了一个保存点。然而整个事务中，只有这一个保存点，因此，回滚只能会滚到事务开始时的状态，保存点用SAVE WORK函数来建立，通知系统记录当前的处理状态。当出现问题时，保存点能用作内部的重启动点，根据应用逻辑，决定是回到最近一个保存点还是其他更早的保存点。图显示了事务中使用的保存点

![1.6.1.带有保存点的扁平事务](../..//mysql-image/1.6.1.%E5%B8%A6%E6%9C%89%E4%BF%9D%E5%AD%98%E7%82%B9%E7%9A%84%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1.jpg)

显示了如何在事务中使用保存点，灰色背景部分表示由ROLLBACK WORK而导致部分回滚，实际并没有执行操作，当用BEGIN WORK开启一个事务时，隐式地包含了一个保存点，当事务通过ROLLBACK WORK：2发出部分回滚命令时，事务会滚到保存点2，接着依次执行，并再次执行到ROLLBACK WORK：7，知道最后COMMIT WORK操作，表示事务结束，除灰色阴影部分的操作外，其余操作都已经执行，并且提交。

另一个需要注意的是，保存点在事务内部是**递增**的，从图中可以看出，有人可能会想，返回保存点2以后，下一个保存点可以为3，因为之前的工作已经终止，然而新的保存点编号为5，这意味着ROLLBACKU 不影响保存点的计数，并且单调递增编号能保持事务执行的整个历史过程，包括在执行过程中想法的改变。

此外，当事务通过ROLLBACK WORK：2命令发出部分回滚命令时，要记住事务并没有完全被回滚，只是回滚到保存点2而已，这代表当前事务是活跃的，如果想要回滚事务，还需要执行ROLLBACKUP WORK。

## 3. 链事务

链事务 可视为保存点模式的一种变种，带有保存点的扁平事务，当发生系统崩溃是，所有的的保存点都将消失，因为其保存点是易失的，这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行

链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作 将合并为一个原子操作，这意味着下一个事务将看到上一个事务的结果，就好像一个事务中进行的一样，如图显示了链事务的工作方式：

![1.6.2.链事务](../..//mysql-image/1.6.2.%E9%93%BE%E4%BA%8B%E5%8A%A1.png)

链事务与带有保存点的扁平事务不同的是，带有保存点的扁平事务能回滚到任意正确的保存点，而链事务中的回滚仅限当前事务，即只能恢复到最近的一个保存点，对于锁的处理，两者也不相同，锁事务在执行COMMIT后即释放了当前所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的锁。

## 4. 嵌套事务

嵌套事务 是一个层次结构框架，由一个顶层事务(top-level transaction)控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务，其控制每一个局部的变换，结构如下

![1.6.3.嵌套事务](../..//mysql-image/1.6.3.%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1.png)

下面给出MOSS对嵌套事务的定义

1. 嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务也可以是扁平事务
2. 处在叶节点的事务是扁平事务，但是每个事务从根到叶节点的距离可以说是不同的
3. 位于根节点的事务称为顶层事务，其他称为自事务。事务的前驱称(predecessor)为父事务(parent)，事务的下一层称为儿子事务(child)
4. 子事务既可以提交也可以回滚。但是它的提交操作并不马上生效。除非其父事务已经提交。因此可以推论出，任何子事务都在顶层事务提交后才真正的提交
5. 树中的任意事务回滚会引起它的所有子事务一同回滚，故子事务仅保留ACI特性而不具有D特性

在Moss的理论中，实际的工作是交由叶子节点完成，即只有叶子节点的事务才能才能访问数据库、发送信息、获取其他类型的资源。而高层的事务仅负责逻辑控制。决定合适调用相关的子事务。即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务，如图

![1.6.4.嵌套事务2](../..//mysql-image/1.6.4.%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A12.png)

如图可以发现，在恢复时采用保存点技术比嵌套查询有更大的灵活性。例如在完成Tk3这事务时，可以会滚到保存点S2的状态。而在嵌套查询的层次结构中，这是不被允许的。

但是用保存点技术来模拟嵌套事务在锁的持有方面还是与嵌套查询有些区别。当通过保存点技术来模拟嵌套事务时，用户无法选择哪些锁需要被子事务集成，哪些需要被父事务保留，这就是说，无论有多少个保存点，所有被锁住的队形都可以被得到和访问。而在嵌套查询中，不同的子事务在数据库对象上持有的锁是不同观点。例如一个父事务P1 其持有对象X和Y的排他锁，现在要开始调用子事务P11 ,那么父事务P1 可以不传递锁，也可以传递所有的锁，也可以只传递一个排他锁，如果子事务P11 中还持有对象Z的排他锁，那么通过反向继承(counter-inherited)父事务P1 将持有3个对象X Y Z的排他锁。如果这时再次调用一个子事务P12 ，那么它可以传递哪里已经持有的锁。

然而，如果系统支持嵌套事务中并行地执行的各个子事务，在这种情况下，采用保存点的扁平事务来模拟嵌套事务就不切实际了。这从另一个方面反映出，**想要实现事务间的并行性，需要真正支持的嵌套事务。**

## 5. 分布式事务

分布式事务 通常是一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。

假如一个用户在ATM机上进行银行的转账操作，例如持卡人从招商银行存储卡转账10 000 元到工商银行的存储卡。这种情况下，可以将ATM机视为节点A，招商银行的后台数据库视为节点B，工商银行的后台数据库视为C，这个转账的操作可分解为以下的步骤

```
1. 节点A发出转账命令

2. 节点B执行存储卡中的余额减去10 000

3. 节点C执行存储卡终端的余额增加10 000

4. 节点A通知用户操作完成或者节点A通知用户操作失败
```

这里需要使用到分布式事务，因为节点A不能通过一台数据库就完成任务，其需要访问网络中两个节点的数据库，而在每个节点的数据库执行的实务操作有都是扁平的，对于分布式事务，其同样需要满足ACID特性，要么都发生，要么都失败。对于上述例子，如果2 3 步中任何一个操作失败，都会导致整个分布式事务回滚，若非这样，结果非常可怕。

对于**InnoDB存储引擎**来说，其支持**扁平事务**，**带保存点的事务**，**链事务**，**分布式事务**。对于嵌套事务，其原生不支持。因此对有**并发事务需求**的用户来说,MySQL数据库或InnoDB存储引擎就显得无能为力，然而用户仍可以通过带保存点的事务来模拟串行的嵌套事务。

# 一些前提知识

## （一）自动提交、提交和回滚

在InnoDB中，所有的用户活动都发生在一个事务中。如果启用了自动提交模式，则每个SQL语句各自形成一个事务。默认情况下，MySQL在启用autocommit的情况下为每个新连接启动会话，所以如果SQL语句没有返回错误，MySQL会在每个SQL语句之后执行commit。如果语句返回错误，则提交或回滚行为取决于错误。

- 启用autocommit的会话可以执行多语句事务，方法是使用显式的START事务或BEGIN语句启动事务，并用COMMIT或ROLLBACK语句结束事务。

- 如果在一个会话中，使用SET autocommit = 0禁用了自动提交模式，则该会话始终有一个打开的事务。COMMIT或ROLLBACK语句结束当前事务，并开始一个新的事务。

- 如果一个禁用了autocommit的会话在没有显式提交最终事务的情况下结束，MySQL将回滚该事务。

- 有些语句会隐式地结束事务，就像在执行语句之前执行了COMMIT一样。
- 提交意味着在当前事务中所做的更改成为永久性的，并且对其他会话可见。另一方面，ROLLBACK语句取消当前事务所做的所有修改。提交和回滚都释放了在当前事务中设置的所有InnoDB锁。

## （二）将DML操作与事务分组

默认情况下，MySQL启用autocommit模式，该模式会在您执行每条SQL语句时自动提交。如果您有使用其他数据库系统的经验，则可能不熟悉这种操作模式，在其他数据库系统中，发出一系列DML语句并提交它们或一起回滚它们是标准的做法。

要使用多语句事务，请使用SQL语句SET autocommit = 0关闭autocommit，并使用COMMIT或ROLLBACK适当地结束每个事务。要使autocommit保持开启状态，可以用`START TRANSACTION`开始每个事务，用COMMIT或ROLLBACK结束每个事务。下面的示例显示了两个事务。第一个是提交；第二个回滚。

```sql
mysql> CREATE TABLE customer (a INT, b CHAR (20), INDEX (a));
Query OK, 0 rows affected (0.00 sec)
mysql> -- Do a transaction with autocommit turned on.
mysql> START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)
mysql> INSERT INTO customer VALUES (10, 'Heikki');
Query OK, 1 row affected (0.00 sec)
mysql> COMMIT;
Query OK, 0 rows affected (0.00 sec)
mysql> -- Do another transaction with autocommit turned off.
mysql> SET autocommit=0;
Query OK, 0 rows affected (0.00 sec)
mysql> INSERT INTO customer VALUES (15, 'John');
Query OK, 1 row affected (0.00 sec)
mysql> INSERT INTO customer VALUES (20, 'Paul');
Query OK, 1 row affected (0.00 sec)
mysql> DELETE FROM customer WHERE b = 'Heikki';
Query OK, 1 row affected (0.00 sec)
mysql> -- Now we undo those last 2 inserts and the delete.
mysql> ROLLBACK;
Query OK, 0 rows affected (0.00 sec)
mysql> SELECT * FROM customer;
+------+--------+
| a    | b      |
+------+--------+
|   10 | Heikki |
+------+--------+
1 row in set (0.00 sec)
```

### 1. set autocommit = 0、start transaction、begin都能开启一个事务，有什么区别

- set autocommit = 0，关闭自动提交。当遇到需要开启事务的sql，会话本身会默认开启事务，需要commit或rollback处理事务。
- start transaction、begin，是针对 autocommit = 1来说的！！！这是最本质的区别。当然它两也可以在关闭自动提交中使用。

### 2. 客户端语言的事务

在PHP、Perl DBI、JDBC、ODBC或MySQL的标准C调用接口等api中，您可以将事务控制语句(如COMMIT)作为字符串发送到MySQL服务器，就像任何其他SQL语句(如SELECT或INSERT)一样。一些api还提供单独的特殊事务提交和回滚函数或方法。

## （三）一致性非锁定读取

一致的读取意味着InnoDB使用多版本化在某个时间点向查询提供数据库的快照。查询查看**在此时间点之前提交的事务**所做的更改，以及稍后或未提交的事务所做的更改。这条规则的例外是，查询会看到前面语句在同一事务中所做的更改。会导致以下异常:如果更新表中的某些行，SELECT会看到更新行的最新版本（RC），但也可能会看到任何行的旧版本（RR）。如果其他会话同时更新同一表，则异常意味着您可能会看到表处于数据库中从未存在的状态（RC 和 RR都会发生，修改对当前事务可见）。

RC 和 RR 创建快照的区别：

- **如果事务隔离级别是可重复读取(默认级别)，那么同一事务中的所有一致读取都会读取该事务中第一次读取所建立的快照。通过提交当前事务并在此之后发出新查询，可以为查询获得更新的快照。**

- **使用已提交读取隔离级别，事务中的每个一致读取都会设置并读取自己的新快照。**



一致读取是InnoDB在read COMMITTED和REPEATABLE read隔离级别上处理SELECT语句的默认模式。**一致的读操作不会在它访问的表上设置任何锁，因此，在对表执行一致的读操作时，其他会话可以自由地修改这些表。**



**假设您在默认的可重复读隔离级别中运行。当你发出一个一致的读取(即一个普通的SELECT语句)时，InnoDB会给你的事务一个时间点，根据这个时间点你的查询可以看到数据库。如果另一个事务删除了一行并在分配了您的时间点之后提交，您不会看到该行已被删除。插入和更新的处理方式类似。**

> 注意：
>
> 数据库状态的快照应用于事务中的SELECT语句，而不一定应用于DML语句。如果您插入或修改某些行，然后提交该事务，那么从另一个并发可重复读事务发出的DELETE或UPDATE语句可能会影响那些刚刚提交的行，即使会话不能查询它们。如果事务确实更新或删除了由不同事务提交的行，那么这些更改对当前事务是可见的。例如，您可能会遇到以下情况:
>
> ```sql
> SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc';
> -- Returns 0: no rows match.
> -- 此时，假设有另一个事务提交了 10 条‘abc’的数据，
> UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc';
> -- Affects 10 rows: 
> SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba';
> -- Returns 10: this txn can now see the rows it just updated.
> ```
>
> 其实 update 语句在开始阶段，需要查询数据库一次，把满足条件的数据页加载到缓冲池中。但 update 之前的 select是非锁定读，并没有锁住 'abc' 这条记录，导致其他事务能插入数据。

您可以通过提交事务，然后使用一致的快照执行另一个选择或启动事务来提高时间点。

**这称为多版本并发控制。**

在下面的示例中，只有当B提交了插入并且A也提交了时，会话A才看到B插入的行，因此时间点超前于B的提交。(RR)

```sql
             Session A              Session B

           SET autocommit=0;      SET autocommit=0;
time
|          SELECT * FROM t;
|          empty set
|                                 INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           empty set
                                  COMMIT;

           SELECT * FROM t;
           empty set

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------
```

如果您想查看数据库的“最新”状态，请使用READ COMMITTED隔离级别或锁定读:`SELECT * FROM t lock in share mode;` 或 `SELECT * FROM t for update;`通过当前读（加读写锁）的方式获取最新数据，而不是通过快照获取数据。

延续上边例子：

```
    Session A              Session B

           SET autocommit=0;      					SET autocommit=0;
time
|          SELECT * FROM t;
|          empty set
|                                 					INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           empty set
                                  					COMMIT;

           SELECT * FROM t lock in share mode;
           ---------------------
           |    1    |    2    |
           ---------------------

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------
```

使用 RC 隔离级别，事务中的每个一致读取都会设置并读取自己的新快照。当LOCK处于共享模式时，会发生一个锁定读取:SELECT阻塞，直到包含最新行的事务结束。

一致读取不能在某些DDL语句上工作:

- 一致性读取在删除表上不起作用，因为MySQL不能使用已经删除的表，而InnoDB会破坏表。

- 一致读取不能在ALTER TABLE操作上工作，这些操作生成原始表的临时副本，并在构建临时副本时删除原始表。当您在事务中重新发出一致的读取时，新表中的行是不可见的，因为在捕获事务的快照时这些行不存在。在这种情况下，事务返回一个错误:ER_TABLE_DEF_CHANGED，“表定义已更改，请重试事务”。

读取的类型因选择子句中的select 语句而有所不同，如INSERT INTO ... SELECT, UPDATE ... (SELECT), 和 CREATE TABLE ... SELECT，不包含 FOR UPDATE 或 LOCK IN SHARE MODE:

- 默认情况下，InnoDB在这些语句中使用更强的锁（数据行锁+间隙锁），SELECT部分类似于READ COMMITTED，每个一致的READ，即使是在同一个事务中，也会设置和读取它自己的新快照。

- 在这种情况下，要执行非锁定读操作，可以启用innodb_locks_unsafe_for_binlog选项，并设置事务的隔离级别为未提交读、已提交读或可重复读，以避免对从所选表读取的行设置锁。

## （四）锁定读

如果在同一个事务中查询数据，然后插入或更新相关数据，那么常规SELECT语句不能提供足够的保护。其他事务可以更新或删除您刚才查询的相同行。InnoDB支持两种类型的锁读取，提供了额外的安全:

- SELECT ... LOCK IN SHARE MODE
  在被读取的任何行上**设置共享模式锁**。其他会话可以读取这些行，但在事务提交之前不能修改它们。如果这些行中的任何一行被尚未提交的另一个事务更改，则查询将等待该事务结束，然后使用最新的值。
- SELECT ... FOR UPDATE
  **对于遇到的搜索索引记录，锁定行和任何关联的索引项**，就像对这些行发出UPDATE语句一样。其他事务不能更新这些行，不能做SELECT ... LOCK IN SHARE MODE，或在某些事务隔离级别中读取数据。一致性读取忽略在read view中存在的记录上设置的任何锁。(旧版本的记录不能被锁定;它们是通过在记录的内存副本上应用undo log重新构建的。)

这些子句在处理单个表或跨多个表的树结构或图结构数据时最有用。

提交或回滚事务时，将释放 由`LOCK IN SHARE MODE`和`FOR UPDATE` 设置的所有锁定。

> 注意：
>
> 只有在禁用自动提交时(通过启动事务或将自动提交设置为0来开始事务)，才可能进行锁读。

### 锁定读不会延续到子查询中

除非在子查询中也指定了锁定读子句，否则外层语句中的锁定读子句不会锁定嵌套子查询中的表行。例如，下面的语句没有锁定表t2中的行。

```sql
SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;
```

要锁定table中的行，`t2`请向子查询添加锁定的read子句：

```sql
SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;
```

### 锁定读案例

假设您希望向表的子行插入一个新行，并确保子行在表parent中有一个父行。您的应用程序代码可以确保整个操作序列的引用完整性。

首先，使用一致的读取来查询表父行，并验证父行是否存在。可以安全地将子行插入到表的子行吗?不会，因为其他一些会话可能会在您的选择和插入之间删除父行，而您不知道它。

为了避免这个潜在的问题，需要使用 LOCK IN SHARE MODE 进行读取:

```sql
SELECT * FROM parent WHERE NAME = 'Jones' LOCK IN SHARE MODE;
```

在 LOCK IN SHARE MODE 查询返回父'Jones'之后，您可以安全地将子记录添加到子表并提交事务。任何试图获取父表中对应行的排他锁的事务都会等待，直到您提交事务下，也就是说，直到所有表中的数据处于一致状态。

再举一个例子，考虑一个表中的整数计数器字段，该字段`CHILD_CODES`用于为添加到table的每个子元素分配唯一标识符 `CHILD`。不要使用一致读取或共享模式读取来读取计数器的当前值，因为数据库的两个用户可能会看到该计数器的相同值，并且如果两个事务尝试添加与`CHILD`表相同的标识符的行，则会发生重复键错误。

在这里，LOCK IN SHARE MODE 不是一个好的解决方案，因为如果两个用户同时读取计数器，至少其中一个在尝试更新计数器时死锁。

要实现读取和递增计数器，首先对使用FOR UPDATE的计数器执行锁定读取，然后递增计数器。例如:

```sql
SELECT counter_field FROM child_codes FOR UPDATE;
UPDATE child_codes SET counter_field = counter_field + 1;
```

`SELECT ... FOR UPDATE`读取最新的可用数据，并在读取的每一行上设置排他锁。因此，它设置了与`UPDATE`搜索的行上设置的锁相同的锁。

前面的描述只是`SELECT ... FOR UPDATE`工作方式的一个示例 。在MySQL中，生成唯一标识符的特定任务实际上可以仅通过单次访问表来完成：

```sql
UPDATE child_codes SET counter_field = LAST_INSERT_ID(counter_field + 1);
SELECT LAST_INSERT_ID();
```

该`SELECT`语句仅检索标识符信息（特定于当前连接）。它不访问任何表。

## （五）幻影行

当同一个查询在不同的时间产生不同的行集时，就会在事务中发生所谓的幻影问题。例如，如果SELECT执行了两次，但第二次返回第一次没有返回的行，则该行是一个“幻影”行。

假设在子表的id列上有一个索引，你想从表中读取并锁定标识符值大于100的所有行，目的是以后更新选中行的某些列:

```sql
SELECT * FROM child WHERE id > 100 FOR UPDATE;
```

查询从id大于100的第一个记录开始扫描索引。让表包含id值为90和102的行。如果在扫描范围内的索引记录上设置的锁没有锁定在间隙(在本例中是介于90和102之间的间隙)中进行的插入，则另一个会话可以向表中插入id为101的新行。如果要在同一个事务中执行相同的SELECT，您将在查询返回的结果集中看到一个id为101(一个“幻影”)的新行。如果我们将一组行视为一个数据项，那么新的幻影子元素将违反事务隔离原则，即事务应该能够运行，以便它读取的数据不会在事务期间发生变化。

为了防止幽灵行的出现，InnoDB使用了一种叫做next-key锁的算法，它结合了**索引行锁和间隙锁**。InnoDB执行行级锁的方式是，当它搜索或扫描一个表索引时，它会在遇到的索引记录上设置共享锁或排他锁。因此，行级锁实际上是索引记录锁。此外，索引记录上的next-key锁还会影响该索引记录之前的“间隙”。也就是说，**next-key锁是索引记录锁加上索引记录之前的间隙锁**。如果一个会话对索引中的记录R有共享或排他锁，则另一个会话不能在索引顺序中紧靠R之前的间隙插入新的索引记录。

**当InnoDB扫描一个索引时，它也可以锁定索引中最后一条记录之后的间隙**。正如前面的例子中所发生的那样:为了防止向id大于100的表进行任何插入，InnoDB设置的锁包括id值102后面的间隙上的一个锁。

您可以使用Next-Key锁定在应用程序中实现**唯一性检查**：如果在共享模式下读取数据时没有看到要插入的行的重复项，则可以安全地插入行，并且知道在读取过程中在行的后继项上设置的Next-Key锁可以防止任何人同时为您的行插入重复项。因此，NEXT-KEY锁定使您能够“锁定”表中不存在的内容。

间隙锁可以被禁用，如14.7.1节“InnoDB锁”所讨论的那样。这可能会导致幻像问题，因为当间隙锁被禁用时，其他会话可能会向间隙插入新行。

# 事务实现的基础

## 1.redo log

redo log叫做**重做**日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当**事务提交之后**会把所有修改信息都会存到该日志中。

在数据库的运行过程中，不需要对 redo log 进行读取。只有服务器宕机，数据丢失后才会读取。

关于 redo log 之前已经讨论过，这里不在赘述。

## 2. undo log

undo log 用来保证事务的回滚 及 MVCC 的实现。

undo log 在运行过程中会随机读取，因为 MVCC 的原因。

**undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。**

# 事务的状态

- **active**

  开启事务后，事务进入active状态

- **prepare**
  当事务完成需要提交时，为了和BINLOG做XA，InnoDB的commit被划分成了两个阶段：prepare阶段和commit阶段，本小节主要讨论下prepare阶段undo相关的逻辑。

  为了在崩溃重启时知道事务状态，需要将事务设置为Prepare，MySQL 5.7对临时表undo和普通表undo分别做了处理，前者在写undo日志时总是不需要记录redo，后者则需要记录。

  分别设置insert undo 和 update undo的状态为prepare，调用函数trx_undo_set_state_at_prepare，过程也比较简单，找到undo log slot对应的头页面(trx_undo_t::hdr_page_no)，将页面段头的TRX_UNDO_STATE设置为TRX_UNDO_PREPARED，同时修改其他对应字段，如下图所示（对于外部显式XA所产生的XID，这里不做讨论）：
  ![1.6.5.事务prepare状态](../..//mysql-image/1.6.5.%E4%BA%8B%E5%8A%A1prepare%E7%8A%B6%E6%80%81.png)

- **commit**
  commit后进入commit状态

# 事务的隔离级别

**事务隔离是数据库处理的基础之一。隔离是 ACID 中的字母I；隔离级别是在多个事务同时进行更改和执行查询时，对性能与可靠性、一致性和结果再现性之间的平衡进行微调的设置。**

1992标准所描述的所有四种事务隔离级别:**未提交读、提交读、可重复读和可序列化**。InnoDB都可以实现。InnoDB的**默认隔离级别是可重复读取**。



**用户可以使用`SET TRANSACTION`语句更改单个会话或所有后续连接的隔离级别**。若要为所有连接设置服务器的默认隔离级别，请在命令行或选项文件中使用——transaction-isolation选项。有关隔离级别和级别设置语法的详细信息，请参阅13.3.6节“设置事务语句”。



InnoDB使用不同的锁定策略支持这里描述的每个事务隔离级别。对于ACID遵从性非常重要的关键数据的操作，可以使用默认的可重复读取级别强制执行高度一致性。或者，在批量报告这样的情况下，精确的一致性和可重复的结果不如最小化锁定开销重要，您可以使用READ COMMITTED或甚至READ UNCOMMITTED来放松一致性规则。SERIALIZABLE实施了比可重复读取更严格的规则，它主要用于特殊情况，比如XA事务，以及用于对并发性和死锁问题进行故障排除。（视情况降低隔离级别）

以下详细介绍四种隔离级别：

- **READ UNCOMMITTED —— 读未提交**
  SELECT语句以非锁定方式执行，但可能会使用行的早期版本(即未提交事务中行数据的早期版本)。因此，使用这个隔离级别，这样的读取是不一致的。这也被称为脏读。这个隔离级别的其他工作方式与READ COMMITTED类似。

- **READ COMMITED ——读已提交**
  **每次一致读取(即使是在同一个事务中)都会设置和读取自己的新快照。** 就是这样导致的不可重复度。

  

  对于read (SELECT with For UPDATE或LOCK IN SHARE MODE)、UPDATE语句和DELETE语句，InnoDB只锁索引记录，而不锁它们之前的间隙，因此允许在被锁记录旁边自由插入新记录。

  

  由于禁用了间隙锁，可能会出现幻象问题，因为其他会话可能会向间隙中插入新行。

  

  **读提交隔离级别只支持基于行的二进制日志记录。如果在binlog_format=MIXED下使用READ COMMITTED，服务器会自动使用基于行的日志记录。**

  使用`READ COMMITTED`具有其他效果：

  - 对于`UPDATE`或 `DELETE`语句， `InnoDB`仅对其更新或删除的行持有锁。MySQL评估`WHERE`条件后，将释放不匹配行的记录锁 。这大大降低了死锁的可能性，但是仍然可以发生。
  - 对于`UPDATE`语句，如果某行已被锁定，则`InnoDB` 执行“半一致”读取，将最新的提交版本返回给MySQL，以便MySQL可以确定该行是否与`UPDATE`的`WHERE`条件 匹配 。如果该行匹配（必须更新），则MySQL会再次读取该行，这一次将`InnoDB`其锁定或等待对其进行锁定。

  请考虑从该表开始的以下示例：

  ```sql
  CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
  INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
  COMMIT;
  ```

  在这种情况下，表没有索引，因此搜索和索引扫描使用隐藏的聚集索引进行记录锁定，而不是使用索引列。

  假设一个会话`UPDATE`使用以下语句执行 ：

  ```sql
  # Session A
  START TRANSACTION;
  UPDATE t SET b = 5 WHERE b = 3;
  ```

  还假设第二个会话 `UPDATE`通过在第一个会话的语句之后执行以下语句来执行：

  ```sql
  # Session B
  UPDATE t SET b = 4 WHERE b = 2;
  ```

  在`InnoDB`执行`UPDATE`each每条数据时 ，它首先为其读取的每一行获取一个排他锁，然后确定是否对其进行修改。如果 `InnoDB`不修改该行，则释放该锁。否则， `InnoDB`将保留该锁直到事务结束。这会影响事务处理，如下所示。

  使用默认`REPEATABLE READ` 隔离级别时，第一个`UPDATE`将在其读取的每一行上获得一个x锁，并且不会释放其中的任何一个：

  ```sql
  x-lock(1,2); retain x-lock
  x-lock(2,3); update(2,3) to (2,5); retain x-lock
  x-lock(3,2); retain x-lock
  x-lock(4,3); update(4,3) to (4,5); retain x-lock
  x-lock(5,2); retain x-lock
  ```

  第二个`UPDATE`尝试获取任何锁定的块（因为第一次更新在所有行上都保留了锁定），并且直到第一个`UPDATE`提交或回滚时才继续进行：

  ```sql
  x-lock(1,2); block and wait for first UPDATE to commit or roll back
  ```

  `READ COMMITTED`相反，则第一个`UPDATE`一个在其读取的每一行上获取一个x锁，并释放其未修改的行的x锁：

  ```sql
  x-lock(1,2); unlock(1,2)
  x-lock(2,3); update(2,3) to (2,5); retain x-lock
  x-lock(3,2); unlock(3,2)
  x-lock(4,3); update(4,3) to (4,5); retain x-lock
  x-lock(5,2); unlock(5,2)
  ```

  对于第二个`UPDATE`， `InnoDB`执行 “半一致”读取，将它读取的每一行的最新提交版本返回给MySQL，以便MySQL可以确定该行是否符合 `UPDATE`中的 `WHERE`条件：

  ```sql
  x-lock(1,2); update(1,2) to (1,4); retain x-lock
  x-lock(2,3); unlock(2,3)
  x-lock(3,2); update(3,2) to (3,4); retain x-lock
  x-lock(4,3); unlock(4,3)
  x-lock(5,2); update(5,2) to (5,4); retain x-lock
  ```

  但是，如果`WHERE`条件包括索引列并`InnoDB`使用索引时，则在获取和保留记录锁定时仅考虑索引列。在下面的示例中，第一个`UPDATE`在b = 2的每一行上获取并保留一个x锁，第二个`UPDATE`在尝试获取同一记录上的x锁时使用第二 个锁，因为它也使用在b列上定义的索引。

  ```sql
  CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;
  INSERT INTO t VALUES (1,2,3),(2,2,4);
  COMMIT;
  
  # Session A
  START TRANSACTION;
  UPDATE t SET b = 3 WHERE b = 2 AND c = 3;
  
  # Session B
  UPDATE t SET b = 4 WHERE b = 2 AND c = 4;
  ```

  使用`READ COMMITTED` 隔离级别的效果与启用不赞成使用的 `innodb_locks_unsafe_for_binlog`（使用间隙锁）配置选项相同，但以下情况除外：

  - 启用 `innodb_locks_unsafe_for_binlog`是全局设置，会影响所有会话，而隔离级别可以针对所有会话全局设置，也可以针对每个会话单独设置。
  - `innodb_locks_unsafe_for_binlog`只能在服务器启动时设置隔离级别，而隔离级别可以在启动时设置或在运行时更改。

  `READ COMMITTED`因此提供了比`innodb_locks_unsafe_for_binlog`更好更灵活的控制 。

- **REPEATABLE READ —— 可重复读**
  这是InnoDB的默认隔离级别。**同一事务中的一致性读取会使用第一次读取所建立的快照。**这意味着，如果在同一个事务中发出几个普通(非锁定)SELECT语句，那么这些SELECT语句彼此之间也是一致的。

  

  对于读语句(SELECT with For UPDATE或LOCK IN SHARE MODE)、UPDATE和DELETE语句，锁定取决于语句是使用具有唯一搜索条件的唯一索引，还是使用范围类型搜索条件。

  

  对于具有唯一搜索条件的唯一索引，InnoDB只锁定找到的索引记录，而不是之前的间隙。

  

  对于其他搜索条件，InnoDB锁定被扫描的索引范围，使用间隙锁或next-key锁来阻止其他会话插入到范围所覆盖的间隙中。

- **SERIALIZABLE —— 可序列化 / 串行化**
  这个级别类似于可重复读取，如果自动提交被禁用，则InnoDB隐式地将所有**普通SELECT语句**转换为**SELECT ... LOCK IN SHARE MODE**。如果启用了autocommit，那么SELECT就是它自己的事务。因此，已知它是只读的，如果作为一致的(非锁定)读执行，可以序列化，不需要阻塞其他事务。(如果其他事务已经修改了所选的行，要强制禁止纯选择，请禁用autocommit。)

## RC 和 RR 的区别

1. RC 每次select的时候，获取的是最新版本的快照，因此会造成不可重复读；
   RR 依赖于第一次select 生成的快照，解决了不可重复读的问题

2. RC 中没有间隙锁；
   RR 中有间隙锁，一定程度上解决了幻读的问题

3. RC 当InnoDB返回数据给服务器后，若有些数据不满足要求，则释放掉对应行的锁
   RR 锁住之后，不会释放，直到事务提交或回滚

   

# 事务的特性

**ACID:**该ACID模式是一组数据库设计原则强调的是，对于业务数据和关键任务应用重要的可靠性方面。MySQL包含诸如`InnoDB`存储引擎严格遵循ACID模型，因此数据不会损坏，结果也不会因软件崩溃和硬件故障等异常情况而失真。当您依靠符合ACID的功能时，无需重新发明一致性检查和崩溃恢复机制。如果您有其他软件保护措施，超可靠的硬件或可以容忍少量数据丢失或不一致的应用程序，则可以调整MySQL设置以牺牲一些ACID可靠性，以获得更高的性能或吞吐量。

- **原子性（atomicity）**
  每个事务是最小单位，不可再分割。只有事务中的所有操作都成功，才算成功。只要有一个失败，即为失败。数据库的状态需要回退到执行事务之前的状态。
- **一致性（consistency）**
  事务将数据库从一种一致性状态，转变为另一种一致性状态。在事务开始之前和事务结束之后，数据库的完整性约束没有遭到破坏。例如，数据库中有个姓名字段为唯一约束，不能重复。如果一个事务对该字段进行了修改，在事务提交或回滚后，表中的姓名字段重复了，这就破坏了唯一性要求。从一致性状态变为不一致性状态。
- **隔离性（isolation）**
  多个事务之间，读写互相分离，在事务提交前，对其他事务不可见。
- **持久性（durability）**
  事务一旦提交，其结果是永久性的，不管是MySQL挂了，还是服务器宕机，都不能丢失结果。

**理论上，事务有严格的要求，即ACID特性。但数据库厂商处于各种目的，并没有严格遵守。**有时候不会导致严重的后果，反而会有性能上的提升。例如，MySQL的 NDB Cluster引擎虽然支持事务，但不满足持久性的要求；Oracle的默认隔离级别为 RC 不满足 隔离性的要求。**InnoDB存储引擎完全遵守了ACID。**

# 事务的实现

前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。

- 事务的原子性主要涉及InnoDB的事务。是通过 undo log 来实现的，相关的MySQL功能
  1. 设置自动提交
  2. 声明 COMMIT
  3. 声明 ROLLBACK
  4. `INFORMATION_SCHEMA` 表中的 操作数据。
- 事务的持久性性是通过 redo log 来实现的。涉及与特定硬件配置交互的MySQL软件功能。由于取决于您的CPU，网络和存储设备的功能的可能性很多，因此为具体的准则提供最复杂的方面。（这些准则可能采取购买“ 新硬件 ”的形式 。）相关的MySQL功能包括：
  1. `InnoDB` [doublewrite buffer](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_doublewrite_buffer)，由[`innodb_doublewrite`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_doublewrite) 配置选项打开和关闭
  2. 配置选项 [`innodb_flush_log_at_trx_commit`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit)，配置提交时刷新redo log策略
  3. 配置选项 [`sync_binlog`](https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_sync_binlog)commit的时候，刷新二进制日志到磁盘策略
  4. 配置选项 [`innodb_file_per_table`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_per_table)为每个表开启独立表空间
  5. 存储设备（例如磁盘驱动器，SSD或RAID阵列）中的写缓冲区。
  6. 电池后备存储设备中的缓存。
  7. 用来运行MySQL的操作系统，特别是它对`fsync()`系统调用的支持。
  8. 不间断电源（UPS）保护运行MySQL服务器并存储MySQL数据的所有计算机服务器和存储设备的电源。
  9. 您的备份策略，例如备份的频率和类型以及备份保留期。
  10. 对于分布式或托管数据应用程序，MySQL服务器的硬件所位于的数据中心的特定特性，以及数据中心之间的网络连接。
- 事务的隔离性是通过 (读写锁+MVCC)来实现的,主要涉及`InnoDB` [事务](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_transaction)，尤其是适用于每个事务的[隔离级别](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level)。相关的MySQL功能包括：
  1. 自动提交的设置
  2.  声明`SET ISOLATION LEVEL`
  3. `InnoDB` [锁定](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking) 的底层细节。在性能调整期间，您可以通过`INFORMATION_SCHEMA`表格查看这些详细信息 
- 而事务的终极大 boss **一致性**是通过原子性，持久性，隔离性来实现的，主要涉及内部`InnoDB`处理，以防止数据崩溃！！！相关的MySQL功能
  1. `InnoDB` [doublewrite缓冲区](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_doublewrite_buffer)。
  2. `InnoDB` [崩溃恢复](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_crash_recovery)。

**原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！**

总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。

# 多版本并发控制 - MVCC

> 以下部分内容参考自：[MVCC 和快照读当前读](https://blog.csdn.net/weixin_42030357/article/details/106877489)，因博客中图片错误容易误导，故摘抄过来并修改。

## （一）简介 - 来源官网，建议背诵全文

`InnoDB`是一个 [多版本的存储引擎](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_mvcc)：它保留有关已更改行的旧版本的信息，以支持诸如并发和[回滚之](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback)类的事务功能 。此信息以称为[回滚段](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback_segment)的数据结构存储在表空间中 （在Oracle中类似的数据结构）。`InnoDB` 使用回滚段中的信息来执行事务回滚中所需的撤消操作。它还使用该信息来构建行的早期版本，以实现 [一致的读取](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read)。

在内部，`InnoDB`向数据库中存储的每一行添加三个字段：

- `DB_TRX_ID`字段：6字节，指示插入或更新该行的最后一个事务的事务id。
- `DB_ROLL_PTR`字段：7字节，称为回滚指针。回滚指针指向写入回滚段的撤消日志记录。如果行已更新，则撤消日志记录将包含在更新行之前重建行内容所必需的信息。此外，删除在内部被视为更新，在该更新中，该行中的特殊位被设置为将其标记为已删除。
- `DB_ROW_ID`字段：6字节，包含一个行ID，该ID在插入新行时会单调增加。如果 `InnoDB`自动生成聚集索引，该索引包含行ID值。否则，该 `DB_ROW_ID`列不会出现在任何索引中。（不显示指定主键的时候）

***重点：只在聚簇索引，即真实数据行中。***

**回滚段中的撤消日志分为插入和更新撤消日志。插入撤消日志仅在事务回滚中才需要，并且在事务提交后可以立即将其丢弃。更新撤消日志也用于一致的读取，但是只有在不存在为其`InnoDB`分配了快照的事务（ 一致的读取可能需要更新撤消日志中的信息来构建数据库的早期版本）后，才能将其撤消行。**

**因此，在undo log中，会有一堆数据的历史版本。每行数据都用回滚指针指向历史版本数据，该链，称为版本链。**

定期提交您的事务，包括仅发出一致读取的交易。否则， `InnoDB`将无法丢弃更新撤消日志中的数据，并且回滚段可能会变得太大而填满表空间。

回滚段中撤消日志记录的物理大小通常小于相应的插入或更新的行。您可以使用此信息来计算回滚段所需的空间。

在`InnoDB`多版本方案中，当您使用SQL语句删除行时，并不会立即将其从数据库中物理删除。`InnoDB`仅在丢弃为删除而编写的更新撤消日志记录时，才物理删除相应的行及其索引记录。此删除操作称为[purge](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_purge)，它非常快，通常花费与执行删除操作的SQL语句相同的时间顺序。

如果您在表中以几乎相同的速度以较小的批插入和删除行，那么清除线程就会开始滞后，并且由于所有“死”行，表可能会变得越来越大，从而使所有内容都绑定到磁盘上，并且非常慢。在这种情况下，通过调优innodb_max_purge_lag系统变量来控制新的行操作，并为清除线程分配更多的资源。

## （二）snapshot - 快照 与 read view

### 1. snapshot - 快照 与 read view简介

表示在特定时间的数据，即使其他事务提交了更改，该表示也保持不变。由某些隔离级别使用，以允许一致的读取。

InnoDB支持MVCC多版本，其中RC（Read Committed）和RR（Repeatable Read）隔离级别是利用**consistent read view（一致读视图）**方式支持的。 所谓consistent read view就是在某一时刻给事务系统trx_sys打**snapshot（快照）**，把当时trx_sys状态（包括活跃读写事务数组）记下来，之后的所有读操作根据其事务ID（即trx_id）与snapshot中的trx_sys的状态作比较，以此判断read view对于事务的可见性。

- 在MySQL中，Read Committed和Repeatable Read隔离级别下的区别就是它们生成ReadView的时机不同。

- **RR隔离级别（除了Gap锁之外）和RC隔离级别的差别是创建snapshot时机不同。 RR隔离级别是在事务开始时刻，确切地说是第一个读操作创建read view的；RC隔离级别是在语句开始时刻创建read view的，即每个select会创建一个read view。**

- 创建/关闭read view需要持有trx_sys->mutex，会降低系统性能，5.7版本对此进行优化，在事务提交时session会cache只读事务的read view。
  下次创建read view，判断如果是只读事务并且系统的读写事务状态没有发生变化，即trx_sys的max_trx_id没有向前推进，而且没有新的读写事务产生，就可以重用上次的read view。

- 由于InnoDB的二级索引只保存page最后更新的trx_id，当利用二级索引进行查询的时候，如果page的trx_id小于view->up_limit_id，可以直接判断page的所有记录对于当前view是可见的，否则需要回clustered索引进行判断。
- 如果记录对于view不可见，需要通过记录的DB_ROLL_PTR指针遍历history list构造当前view可见版本数据。

### 2. 根据区间判断可见性

首先我们需要知道的一个事实是：事务id是递增分配的。ReadView的机制就是在生成ReadView时确定了以下几种信息：

- **m_ids**：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。[min_trx_id ...  max_trx_id)
- **min_trx_id**：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。
- **max_trx_id**：表示生成ReadView时系统中将要分配给下一个事务的id值。
- **creator_trx_id**：表示生成该ReadView的事务的事务id。

这样事务id就可以分成3个区间：

- **浅绿色区间(0, min_trx_id)：如果被访问版本的 trx_id 小于 m_ids 中的最小值 min_trx_id ，说明生成该版本的事务在 ReadView 生成前就已经提交了，所以该版本可以被访问**
- **蓝色区间[min_trx_id, max_trx_id - 1 ]: 如果被访问版本的 trx_id 属性值在 m_ids 列表中最大值和最小值之间，那就需要判断一下 trx_id 的值是不是在 m_ids 列表中。**
  - **如果在，说明创建 ReadView 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 DB_TRX_ID 再从头计算一次可见性。**
  - **例外：访问的事务id与当前事务id一致，代表是该事务修改的，是可见的**
- **红色区间[max_trx_id, +∞)：如果被访问版本的 trx_id 大于等于 max_trx_id，说明生成该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。需要根据 Undo Log 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性**

![1.6.11.事务id落在区间段示意图.jpg](../../mysql-image/1.6.11.事务id落在区间段示意图.jpg)

下面我们根据ReadView提供的条件信息，顺着版本链从头结点开始查找最新的可被读取的版本记录：

1. 首先判断版本记录的trx_id与ReadView中的creator_trx_id是否相等。如果相等，那就说明该版本的记录是在当前事务中生成的，自然也就能够被当前事务读取；否则进行第2步。
2. 根据版本记录的trx_id以及上述3个区间信息，判断生成该版本记录的事务是否是已提交事务，进而确定该版本记录是否可被当前事务读取。

如果某个版本记录经过以上步骤判断确定其可被当前事务读取，则查询结果返回此版本记录；否则读取下一个版本记录继续按照上述步骤进行判断，直到版本链的尾结点。如果遍历完版本链没有找到可读取的版本，则说明该记录对当前事务不可见，查询结果为空。

## （三）MVCC快照读案例

1. **版本链案例**

   首先我们创建一个表book，就三个字段，分别是主键book_id, 表名为：book。然后向表中批量插入一些数据：

   ```sql
   CREATE TABLE `book` (
     `book_id` int(100) NOT NULL AUTO_INCREMENT,
     `book_name` varchar(100) NOT NULL,
     `book_stock` int(100) NOT NULL,
     PRIMARY KEY (`book_id`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
   
   BEGIN;
   INSERT INTO book VALUES(1, '数据结构', 100);
   INSERT INTO book VALUES(2, 'C++指南', 100);
   INSERT INTO book VALUES(3, '精通Java', 100);
   COMMIT;
   # 批量插入数据时，会开启一个事务，假设事务编号为119
   ```

   此时表中有三条数据，当开启一个事务更新数据时(事务id为120)：

   ```sql
   BEGIN;
   UPDATE book SET book_stock = 200 WHERE book_id = 1;
   UPDATE book SET book_stock = 300 WHERE book_id = 1;
   ```

   此时，id = 1 的数据在undo log中的版本链为：
   ![1.6.9.版本链案例1](../../mysql-image/1.6.9.版本链案例1.png)

2. **RC 隔离级别下的 MVCC，关闭自动提交，选择手动提交事务**

   ```sql
   # session 1
   mysql> SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> set autocommit = 0;
   Query OK, 0 rows affected (0.00 sec)
   
   # 开启事务1，事务id为121
   # 由于关闭自动提交，只要不提交，就不会最终修改数据
   mysql> UPDATE book SET book_stock = 200 WHERE book_id = 2;
   Query OK, 1 row affected (0.01 sec)
   Rows matched: 1  Changed: 1  Warnings: 0
   ```

   版本链为：

   ![1.6.10.RC中MVCC版本链1](../../mysql-image/1.6.10.RC中MVCC版本链1.png)

   此时开启第二个会话，设置隔离级别为 RC，且关闭自动提交，手动开启事务。进行查询

   ```sql
   # session 2
   mysql> SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> set autocommit = 0;
   Query OK, 0 rows affected (0.00 sec)
   
   # 只读sql，不开启事务，故不分配事务id
   # 由于事务1并未提交，所以读到的数据为100
   mysql> begin;
   Query OK, 0 rows affected (0.00 sec)
   mysql> select * from book WHERE book_id = 2;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       2 | C++指南   |        100 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   ```

   分析过程：

   1. 此查询在执行时，活跃事务id只有 121 ，用中括号框起来，故 m_ids 为 [121]
   2. InnoDB内部维护的一个自增事务id，下一个修改数据的事务过来才会分配，故下一个事务id为：122
   3. 由于当前事务不修改数据，故 creator_trx_id 为 0 
   4. 最后形成的快照为  [121]122 : 0
   5. 当session2读取 book_id = 2 的数据时，来到undo log 版本链：图1.6.10，开始比较：
      第一个遇到的事务id为 121，121在生成快照中的中括号内，落在了区间[min_trx_id, max_trx_id - 1]，代表生成快照时，121为活跃事务，且 121 不等于 0，故该条数据对当前查询不可见。
   6. 顺着回滚指针，找到事务id为 119 的数据。119在快照中落在区间 (0,min_trx_id)，代表该数据在查询时已被提交，故可见，所以查到的 book_stock = 100
      ![1.6.12.根据区间判断是否可见1](../../mysql-image/1.6.12.根据区间判断是否可见1.jpg)

   返回第一个会话进行查询

   ```sql
   # session 1
   mysql> select * from book WHERE book_id = 2;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       2 | C++指南   |        200 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   ```

   分析：

   1. 发起查询时，活跃的事务id为121，故 m_ids 为 [121]
   2. 下一个事务id依旧是122
   3. 当前事务id为121，故 creator_trx_id 为 121
   4. 最后形成的快照为  [121]122 : 121
   5. 在图1.6.10中，找到第一个事务id为 121，发现落在区间 [min_trx_id, max_trx_id - 1] 内，且 正好等于当前事务id，故这个版本对当前查询可见。结果为200

   紧接着，提交session1，但session2，仍未关闭，也就是说session2手动开启的事务还未关闭。

   ```sql
   # session 1
   mysql> commit;
   Query OK, 0 rows affected (0.01 sec)
   ```

   此时去session2中查询，

   ```
   # session 2
   mysql> select * from book WHERE book_id = 2;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       2 | C++指南   |        200 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   ```

   分析：

   ​	由于session1已经提交，session2查询时，没有事务正在修改数据，undo log中无版本链，直接读取数据为200

   

   开启第三个session，同样设置隔离级别为RC ，关闭自动提交，手动开启事务，但不提交事务

   ```sql
   # session 3
   mysql> SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> set autocommit = 0;
   Query OK, 0 rows affected (0.00 sec)
   
   # 开启事务1，事务id为122
   # 由于关闭自动提交，只要不提交，就不会最终修改数据
   mysql> UPDATE book SET book_stock = 300 WHERE book_id = 2;
   Query OK, 1 row affected (0.01 sec)
   Rows matched: 1  Changed: 1  Warnings: 0
   ```

   此时，版本链为：

   ![1.6.13.RC中MVCC版本链2](../../mysql-image/1.6.13.RC中MVCC版本链2.png)

   在session2中接着查询（此处赘述，加深理解）：

   ```sql
   # session 2
   
   mysql> select * from book WHERE book_id = 2;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       2 | C++指南   |        200 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   ```

   分析：

   1. 此查询在执行时，活跃事务id只有 122 ，用中括号框起来，故 m_ids 为 [122]
   2. 下一个事务id为：123
   3. 由于当前事务不修改数据，故 creator_trx_id 为 0 
   4. 最后形成的快照为  [122]123 : 0
   5. 当session2读取 book_id = 2 的数据时，来到undo log 版本链：图1.6.13，开始比较：
      第一个遇到的事务id为 122，122在生成快照中的中括号内，落在了区间[min_trx_id, max_trx_id - 1]，代表生成快照时，122为活跃事务，且 122 不等于 0，故该条数据对当前查询不可见。
   6. 顺着回滚指针，找到事务id为 121 的数据。121在快照中落在区间 (0,min_trx_id)，代表该数据在查询时已被提交，故可见，所以查到的 book_stock = 200
      ![1.6.14.RC事务区间例子2](../../mysql-image/1.6.14.RC事务区间例子2.jpg)

   当session3提交后，session2查询时，结果变为 300 ，此处不再赘述。

   例2整体过程如下：

   | 原始数据： book_stock = 100 | session 1                                                    | session 2                                                    | session 3                                                    |
   | :-------------------------: | :----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   |                             | 设置隔离级别：RC                                             |                                                              |                                                              |
   |                             | 关闭自动提交                                                 |                                                              |                                                              |
   |                             | # 开启一个事务，事务id为121 begin;                           |                                                              |                                                              |
   |                             | UPDATE book  SET book_stock = 200  WHERE book_id = 2;        |                                                              |                                                              |
   |                             |                                                              | 设置隔离级别：RC                                             |                                                              |
   |                             |                                                              | 关闭自动提交                                                 |                                                              |
   |                             |                                                              | begin;                                                       |                                                              |
   |                             |                                                              | select * from book  WHERE book_id = 2; <br />快照：[121] 122 : 0 <br />查询结果为：100 |                                                              |
   |                             | select * from book  WHERE book_id = 2; <br />快照：[121]122 : 121 <br />查询结果：200 |                                                              |                                                              |
   |                             | commit;                                                      |                                                              |                                                              |
   |                             |                                                              | select * from book  WHERE book_id = 2; <br />无活跃事务，不需要快照 <br />查询结果为：200 |                                                              |
   |                             |                                                              |                                                              | 设置隔离级别：RC                                             |
   |                             |                                                              |                                                              | 关闭自动提交                                                 |
   |                             |                                                              |                                                              | # 开启一个事务，事务id为122 begin;                           |
   |                             |                                                              |                                                              | UPDATE book  SET book_stock = 300  WHERE book_id = 2;        |
   |                             |                                                              | select * from book  WHERE book_id = 2; <br />快照：[122] 123 : 0 <br />查询结果为：200 |                                                              |
   |                             |                                                              |                                                              | select * from book  WHERE book_id = 2; <br />快照：[122]123 : 122 <br />查询结果：300 |
   |                             |                                                              |                                                              | commit;                                                      |
   |                             |                                                              | select * from book  WHERE book_id = 2; <br />无活跃事务，不需要快照 <br />查询结果为：300 |                                                              |
   |                             |                                                              | # 虽然没啥用，但还是提交一下<br />commit;                    |                                                              |

   **重点：由该例子可见，每当有事务提交后，其他事务就能读取到该事务提交的内容。每次会生成新的快照。这就是 RC**

3. RR 隔离级别下的 MVCC
   mysql默认隔离级别就是 RR ，因此，不需要可以改变

   开启一个session A，关闭自动提交，手动开启事务，修改数据，但不提交

   ```sql
   # session A
   mysql> set autocommit = 0;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> begin;
   Query OK, 0 rows affected (0.00 sec)
   
   # 开启事务1，事务id为123
   # 由于关闭自动提交，只要不提交，就不会最终修改数据
   mysql> UPDATE book SET book_stock = 200 WHERE book_id = 3;
   Query OK, 1 row affected (0.01 sec)
   Rows matched: 1  Changed: 1  Warnings: 0
   ```

   版本链为：

   ![1.6.15.RR中MVCC版本链1](../../mysql-image/1.6.15.RR中MVCC版本链1.png)

   

   开启另一个sessionB查询，关闭在自动提交，手动开启事务：

   ```sql
   # session B
   mysql> set autocommit = 0;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> begin;
   Query OK, 0 rows affected (0.00 sec)
   
   # 只是查询，不需要开启事务，不分配事务id
   mysql> select * from book  WHERE book_id = 3;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       3 | 精通Java  |        100 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   ```

   分析：

   1. 此查询在执行时，活跃事务id只有 123 ，用中括号框起来，故 m_ids 为 [123]
   2. 下一个事务id为：124
   3. 由于当前事务不修改数据，故 creator_trx_id 为 0 
   4. 最后形成的快照为  [123]124 : 0
   5. 当sessionB读取 book_id = 3 的数据时，来到undo log 版本链：图1.6.15，开始比较：
      第一个遇到的事务id为 123，123在生成快照中的中括号内，落在了区间[min_trx_id, max_trx_id - 1]，代表生成快照时，123为活跃事务，且 123 不等于 0，故该条数据对当前查询不可见。
   6. 顺着回滚指针，找到事务id为 119 的数据。119在快照中落在区间 (0,min_trx_id)，代表该数据在查询时已被提交，故可见，所以查到的 book_stock = 100
      ![1.6.16.RR中事务id区间.jpg](../../mysql-image/1.6.16.RR中事务id区间.jpg)

   紧接着session A中查询数据

   ```sql
   # session A
   
   mysql> select * from book  WHERE book_id = 3;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       3 | 精通Java  |        200 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   ```

   分析：

   1. 此查询在执行时，活跃事务id只有 123 ，用中括号框起来，故 m_ids 为 [123]
   2. 下一个事务id为：124
   3. 由于当前事务不修改数据，故 creator_trx_id 为 123 
   4. 最后形成的快照为  [123]124 : 123
   5. 当sessionA读取 book_id = 3 的数据时，来到undo log 版本链：图1.6.15，开始比较：
      第一个遇到的事务id为 123，123在生成快照中的中括号内，落在了区间[min_trx_id, max_trx_id - 1]，代表生成快照时，123为活跃事务，且 123 = 123，故该条数据对当前查询可见。j结果为200.

   紧接着 session A 提交事务，但session B仍保持打开状态：

   ```sql
   # session A
   mysql> commit;
   Query OK, 0 rows affected (0.01 sec)
   ```

   此时，继续在session B中查询，有趣的地方来了，依旧还是100，且看下边分析：

   ```sql
   # session B
   
   mysql> select * from book  WHERE book_id = 3;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       3 | 精通Java  |        100 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   ```

   分析：

   1. 此查询在执行时，无活跃事务，但发现之前已经生成过一次快照了，直接拿过来用：  [123]124 : 0 
   2. 当sessionB读取 book_id = 3 的数据时，来到undo log 版本链：图1.6.15，开始比较：
      第一个遇到的事务id为 123，123在生成快照中的中括号内，落在了区间[min_trx_id, max_trx_id - 1]，代表生成快照时，123为活跃事务，且 123 不等于 0，故该条数据对当前查询不可见。
   3. 顺着回滚指针，找到事务id为 119 的数据。119在快照中落在区间 (0,min_trx_id)，代表该数据在查询时已被提交，故可见，所以查到的 book_stock = 100

   **注意：这便是 RR 区别于 RC 的地方，他用的同一个快照，所以能保证可重复读。**
   若此时查看 innodb 状态，可发现有一个 read view，

   ```shell
   --------------
   ROW OPERATIONS
   --------------
   0 queries inside InnoDB, 0 queries in queue
   1 read views open inside InnoDB
   Process ID=4808, Main thread ID=7040, state: sleeping
   Number of rows inserted 7010, updated 6, deleted 0, read 50422
   0.00 inserts/s, 0.04 updates/s, 0.00 deletes/s, 0.04 reads/s
   ```

   

   此时再来一个session C，同样修改数据

   ```
   # session C
   mysql> set autocommit = 0;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> begin;
   Query OK, 0 rows affected (0.00 sec)
   
   # 开启事务1，事务id为124
   # 由于关闭自动提交，只要不提交，就不会最终修改数据
   mysql> UPDATE book SET book_stock = 300 WHERE book_id = 3;
   Query OK, 1 row affected (0.01 sec)
   Rows matched: 1  Changed: 1  Warnings: 0
   ```

   此时，在session B中查询，结果依旧是 100，因为快照还是没有发生变化

   ```sql
   # session B
   
   mysql> select * from book  WHERE book_id = 3;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       3 | 精通Java  |        100 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   ```

   session C 自己查询，数据为300，可自己想版本链，事务id区间

   ```sql
   # session C
   
   mysql> select * from book  WHERE book_id = 3;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       3 | 精通Java  |        300 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   
   mysql> commit;
   Query OK, 0 rows affected (0.01 sec)
   ```

   此时 session 2中进行以下操作，并获得结果：

   ```
   # session B
   
   mysql> select * from book  WHERE book_id = 3;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       3 | 精通Java  |        100 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   
   mysql> commit;
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> show engine innodb status;
   --------------
   ROW OPERATIONS
   --------------
   0 queries inside InnoDB, 0 queries in queue
   0 read views open inside InnoDB
   Process ID=4808, Main thread ID=7040, state: sleeping
   Number of rows inserted 7010, updated 6, deleted 0, read 50424
   0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.02 reads/s
   
   mysql> select * from book  WHERE book_id = 3;
   +---------+-----------+------------+
   | book_id | book_name | book_stock |
   +---------+-----------+------------+
   |       3 | 精通Java  |        300 |
   +---------+-----------+------------+
   1 row in set (0.00 sec)
   ```

   分析：

   1. 在commit 之前，依旧还是之前的事务，用的还是同一个快照，故结果依旧是100
   2. commit之后，事务提交，此时查看innodb 状态，可以看到 read view 变为0，此时session A的undo log才被 purge清除
   3. commit之后，再次查询，结果变为300，此时，无活跃事务，无快照生成，直接读取真实数据。

   用表格来表示为：

   | 原始数据： book_stock = 100 | session A                                                    | session B                                                    | session C                                                    |
   | --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
   |                             | 关闭自动提交                                                 |                                                              |                                                              |
   |                             | # 开启一个事务，事务id为123 begin;                           |                                                              |                                                              |
   |                             | UPDATE book  SET book_stock = 200  WHERE book_id = 3;        |                                                              |                                                              |
   |                             |                                                              | 关闭自动提交                                                 |                                                              |
   |                             |                                                              | begin;                                                       |                                                              |
   |                             |                                                              | select * from book  WHERE book_id = 3; <br />快照：[123] 124 : 0 <br />查询结果为：100 |                                                              |
   |                             | select * from book  WHERE book_id = 3; <br />快照：[123]124 : 123 <br />查询结果：200 |                                                              |                                                              |
   |                             | commit;                                                      |                                                              |                                                              |
   |                             |                                                              | select * from book  WHERE book_id = 3; <br />无活跃事务，但有快照 [123] 124 : 0<br />查询结果为：100 |                                                              |
   |                             |                                                              |                                                              | 关闭自动提交                                                 |
   |                             |                                                              |                                                              | # 开启一个事务，事务id为122 begin;                           |
   |                             |                                                              |                                                              | UPDATE book  SET book_stock = 300  WHERE book_id = 3;        |
   |                             |                                                              | select * from book  WHERE book_id = 3; <br />快照：[123] 124 : 0 <br />查询结果为：100 |                                                              |
   |                             |                                                              |                                                              | select * from book  WHERE book_id = 3; <br />快照：[124]125 : 124 <br />查询结果：300 |
   |                             |                                                              |                                                              | commit;                                                      |
   |                             |                                                              | select * from book  WHERE book_id = 3; <br />无活跃事务，但有快照 [123] 124 : 0 <br />查询结果为：100 |                                                              |
   |                             |                                                              | # 提交当前事务 purge 清除undo log，删除快照 <br />commit;    |                                                              |
   |                             |                                                              | select * from book  WHERE book_id = 3; <br />无活跃事务，无快照 <br />查询结果为：300 |                                                              |

## （四）MVCC的快照读 与 当前读的例子

## （N）MVCC对聚簇索引和二级索引的处理方式的区别

`InnoDB`多版本并发控制（MVCC）对二级索引的处理方式不同于聚簇索引。聚簇索引中的记录将**就地更新**，其隐藏的系统列指向撤消日志条目，可以从中重建记录的早期版本。与聚簇索引记录不同，辅助索引记录不包含隐藏的系统列，也不会就地更新。

更新二级索引列时，将对旧的二级索引记录进行删除标记，插入新记录，并最终清除带有删除标记的记录。当二级索引记录被删除标记或二级索引页被较新的事务更新时，`InnoDB`在聚集索引中查找数据库记录。在聚集索引中，`DB_TRX_ID`检查记录，如果在启动读取事务后修改了记录，则从撤消日志中检索记录的正确版本。

如果二级索引记录被标记为删除或二级索引页被更新的事务更新， 则不使用[覆盖索引](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_covering_index)技术。不是从索引结构中返回值，而是`InnoDB`在聚集索引中查找记录。

但是，如果启用了 [索引条件下推（ICP）](https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html)优化，并且`WHERE`仅可以使用索引中的字段来评估部分条件，则MySQL服务器仍会将`WHERE`条件的这一部分下推到存储引擎，并使用索引。如果在删除标记的记录中，找不到匹配的记录，则避免聚集索引查找(使用undo log中的旧版数据)。如果找到了匹配的记录，即使在删除标记的记录中，则在 `InnoDB`聚簇索引中查找记录。

# 分布式事务解决方案

## XA

### 简介

XA是由X/Open组织提出的分布式事务的规范。 XA规范主要定义了**(全局)事务管理器(TM)和(局 部)资源管理器(RM)**之间的接口。主流的关系型 数据库产品都是实现了XA接口的。 

-  XA接口是双向的系统接口，在事务管理器 （TM）以及一个或多个资源管理器（RM）之 间形成通信桥梁。

- XA之所以需要引入事务管理器是因为，在分布 式系统中，从理论上讲两台机器理论上无法达 到一致的状态，需要引入一个单点进行协调。

- 由全局事务管理器管理和协调的事务，可以跨 越多个资源（如数据库或JMS队列）和进程。 全局事务管理器一般使用 XA 二阶段提交协议 与数据库进行交互。

![1.6.7.XA过程](../../mysql-image/1.6.7.XA过程.jpg)

### 组成部分

1. 资源管理器（resource manager）：用来管理系统资源，是通向事务资源的途径。数据库就是一种资源管理器。资源管理还应该具有管理事务提交或回滚的能力。
2. 事务管理器（transaction manager）：事务管理器是分布式事务的核心管理者。事务管理器与每个资源管理器（resource manager）进行通信，协调并完成事务的处理。事务的各个分支由唯一命名进行标识
    Xid 接口 Xid, Xid 接口是 X/Open 事务标识符 XID 结构的 Java 映射。此接口指定三个访问器方法，以检索全局事务格式 ID、全局事务 ID 和分支限定符。Xid 接口供事务管理器和资源管理器使用。此接口对应用程序不可见。

 ### XA 不能自动提交 - 分段提交

XA需要两阶段提交: prepare 和 commit. 

- 第一阶段为 准备（prepare）阶段。即所有的参与者准备执行事务并锁住需要的资源。参与者ready时，向transaction manager报告已准备就绪。 

- 第二阶段为提交阶段（commit）。当transaction manager确认所有参与者都ready后，向所有参与者发送commit命令。 

假设有两个Connection, con1, con2, 大体的过程如下 .

```java
con1 = XAResouce1.getConnection...     
con2 = XAResouce2.getConnection...   

con1 do some thing.     
con2 do some thing.     

after they finish.     

pre1 = XAResouce1.prepare();     
pre2 = XAResouce2.prepare();     

if( both pre1 and pre2 are OK）{     
	XAResouce1 and 2 commit     
}else {     
	XAResouce1 and 2 rollback     
}    
```

### 事务协调/管理者

因为XA 事务是基于两阶段提交协议的，所以需要有一个事务协调者（transaction manager）来保证所有的事务参与者都完成了准备工作(第一阶段)。如果事务协调者（transaction manager）收到所有参与者都准备好的消息，就会通知所有的事务都可以提交了（第二阶段）。MySQL 在这个XA事务中扮演的是参与者的角色，而不是事务协调者（transaction manager）。

### MySQL对XA的支持

MySQL 从5.0.3开始支持XA分布式事务，且只有InnoDB存储引擎支持。MySQL Connector/J 从5.0.0版本之后开始直接提供对XA的支持。

![1.6.8.MySQL对XA的支持.jpg](../../mysql-image/1.6.8.MySQL对XA的支持.jpg)

需要注意的是， 在DTP模型中，mysql属于资源管理器(RM)。而一个完整的分布式事务中，一般会存在多个RM，由事务管理器TM来统一进行协调。因此，这里所说的mysql对XA分布式事务的支持，一般指的是单台mysql实例如何执行自己的事务分支。

#### **MySQL XA 事务SQL语法**

>  https://dev.mysql.com/doc/refman/5.7/en/xa-statements.html

```less
XA {START|BEGIN} xid [JOIN|RESUME]   //开启XA事务，如果使用的是XA START而不是XA BEGIN，那么不支持[JOIN|RESUME]，xid是一个唯一值，表示事务分支标识符
XA END xid [SUSPEND [FOR MIGRATE]]   //结束一个XA事务，不支持[SUSPEND [FOR MIGRATE]]
XA PREPARE xid 准备提交
XA COMMIT xid [ONE PHASE] //提交，如果使用了ONE PHASE，则表示使用一阶段提交。两阶段提交协议中，如果只有一个RM参与，那么可以优化为一阶段提交
XA ROLLBACK xid  //回滚
XA RECOVER [CONVERT XID]  //列出所有处于PREPARE阶段的XA事务
```

下面是一个简单的msyql XA事务案例，演示了mysql作为全局事务中的一个事务分支，将一行记录插入到一个表中

```sql
mysql> XA START 'xatest’;  //其中'xatest’就是xid的值
Query OK, 0 rows affected (0.00 sec)
 
mysql> insert into user(name) values("tianshozuhi");
Query OK, 1 row affected (0.00 sec)
 
mysql> XA END 'xatest';
Query OK, 0 rows affected (0.00 sec)
 
mysql> XA PREPARE 'xatest';
Query OK, 0 rows affected (0.01 sec)
 
mysql> XA COMMIT 'xatest';
Query OK, 0 rows affected (0.01 sec)
```

#### Mysql XA事务状态

XA事务的状态，按照如下步骤进行展开

1. 使用XA START来启动一个XA事务，并把它置于`ACTIVE`状态。

2. 对于一个ACTIVE状态的 XA事务，我们可以执行构成事务的SQL语句，然后发布一个XA END语句。XA END把事务放入`IDLE`状态。

3. 对于一个IDLE 状态XA事务，可以执行一个XA PREPARE语句或一个XA COMMIT…ONE PHASE语句：

   - XA PREPARE把事务放入`PREPARED`状态。在此点上的XA RECOVER语句将在其输出中包括事务的xid值，因为XA RECOVER会列出处于PREPARED状态的所有XA事务。

   - XA COMMIT…ONE PHASE用于预备和提交事务。xid值将不会被XA RECOVER列出，因为事务终止。

4. 对于一个PREPARED状态的 XA事务，您可以发布一个XA COMMIT语句来提交和终止事务，或者发布XA ROLLBACK来回滚并终止事务。

  针对一个给定的客户端连接而言，XA事务和非XA事务(即本地事务)是互斥的。例如，已经执行了”XA START”命令来开启一个XA事务，则本地事务不会被启动，直到XA事务已经被提交或被 回滚为止。相反的，如果已经使用START TRANSACTION启动一个本地事务，则XA语句不能被使用，直到该事务被提交或被 回滚为止。

  最后，如果一个XA事务处于ACTIVE状态，是不能直接进行提交的，如果这样做，mysql会抛出异常：

```csharp
ERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed
when global transaction is in the ACTIVE state
```

#### **关于XID的说明**

mysql中使用xid来作为一个事务分支的标识符。事实上xid作为事务分支标识符是在XA规范中定义的，在<< Distributed Transaction Processing: The XA Specification>> 4.2 节中，规定了一个xid的结构，通过C语言进行描述，如下：

```cpp
    /∗
    ∗ Transaction branch identification: XID and NULLXID:
    ∗/

    #define XIDDATASIZE 128  /∗ size in bytes ∗/
    #define MAXGTRIDSIZE 64  /∗ maximum size in bytes of gtrid ∗/
    #define MAXBQUALSIZE 64  /∗ maximum size in bytes of bqual ∗/

    struct xid_t {
        long formatID;     /* format identifier */
        long gtrid_length; /* value 1-64 */
        long bqual_length; /* value 1-64 */
        char data[XIDDATASIZE];
        };

    /∗
    ∗ A value of -1 in formatID means that the XID is null.
    ∗/

    typedef struct xid_t XID;

    /∗
    ∗ Declarations of routines by which RMs call TMs:
    ∗/

    extern int ax_reg(int, XID ∗, long);
    extern int ax_unreg(int, long);
```

XA规范定义了一个xid有4个部分组成：

**gtrid：**

   全局事务标识符(global transaction identifier)，最大不能超过64字节

**bqual：**

   分支限定符(branch qualifier)，最大不能超过64字节

**data：**

  xid的值，其是 gtrid和bqual拼接后的内容。因为gtrid和bqual最大都是64个字节，因此data的最大长度为128。不过，在xid的结构体中，并没有gtrid和bqual，只有gtrid_length、bqual_length。由于二者的内容都存储在data中，因此我们可以根据data反推出gtrid和bqual。举例来说，假设gtrid为”g1234”(5个字节)，bqual为”b456”(4个字节)。那么在构造xid结构体时，gtrid_length=5，bqual_length=4，data=”g1234b456”，那么在反推的时候：

**从data[0]到data[gtrid_length-1]之间的部分就是gtrid的值；从data[gtrid_length]到data[gtrid_length+bqual_length-1]部分就是bqual的值。**

**formatId：**

  而formatId的作用就是记录gtrid、bqual的格式，类似于memcached中flags字段的作用。XA规范中通过一个结构体约定了xid的组成部分，但是并没有规定data中存储的gtrid、bqual内容到底应该是什么格式。你可以选择使用数字，也可以选择使用字符串，到底选择什么由开发者自行决定，只要最终能保证data中的内容是全局唯一的即可。XA规范建议使用OSI CCR风格来组织xid的内容，此时formatId应该设置为0.



在mysql官方文档中，关于xid的组成也有类似的说明：

```shell
xid: gtrid [, bqual [, formatID ]]
```

其中，bqual、formatID是可选的。解释如下：

gtrid : 是一个全局事务标识符(global transaction identifier)，

bqual:是一个分支限定符(branch qualifier)，如果没有提供bqual，那么默认值为空字符串''。

formatID：是一个数字，用于标记gtrid和bqual值的格式，这是一个无符号整数(unsigned integer)，也就是说，最小为0。如果没有提供formatID，那么其默认值为1。

 ** 特别需要注意的是，xid作为一个事务分支的标识符，理论上只要有分支限定符(bqual)就可以了，为什么要包含全局事务标识符(gtrid)？这主要是为了管理方便，通过包含进xid，我们可以很容易的判断出这个事务分支属于哪一个全局事务。 **

  例如，前面提到 XA RECOVER命令的作用是列出所有处于PREPARE阶段的XA事务，以下是一个案例：

```sql
    mysql>  XA RECOVER;
    +----------+--------------+--------------+--------------+
    | formatID | gtrid_length | bqual_length | data         |
    +----------+--------------+--------------+--------------+
    |        1 |            6 |            6 | g12345b67890 |
    +----------+--------------+--------------+--------------+
```

这里列出的是一个分支事务xid的组成信息，根据前面的介绍，我们可以推断出：

  gtrid是data[0]到data[gtrid_length-1]部分的内容，即data[0]到data[6-1=5]部分的内容，结果为g12345；

  而bqual是data[gtrid_length]到data[gtrid_length+bqual_length-1]部分的内容，即data[6]到data[6+6-1=11]部分的内容，结果b67890。

因此，根据这个信息，我们就可以判断出这个xid表示的是：全局事务(g12345)中的事务分支(b67890)。

#### 通过jdbc操作mysql xa事务**

   MySQL Connector/J 从5.0.0版本之后开始直接提供对XA的支持，也就是提供了java版本XA接口的实现。意味着我们可以直接通过java代码来执行mysql xa事务。

   需要注意的是，业务开发人员在编写代码时，不应该直接操作这些XA事务操作的接口。因为在DTP模型中，RM上的事务分支的开启、结束、准备、提交、回滚等操作，都应该是由事务管理器TM来统一管理。

  由于目前我们还没有接触到TM，那么我们不妨做一回"人肉事务管理器"，用你智慧的大脑，来控制多个mysql实例上xa事务分支的执行，提交/回滚。通过直接操作这些接口，你将对xa事务有更深刻的认识。

```java
import com.mysql.jdbc.jdbc2.optional.MysqlXAConnection;
import com.mysql.jdbc.jdbc2.optional.MysqlXid;
import javax.sql.XAConnection;
import javax.transaction.xa.XAException;
import javax.transaction.xa.XAResource;
import javax.transaction.xa.Xid;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class MysqlXAConnectionTest {
    
   public static void main(String[] args) throws SQLException {

      //true表示打印XA语句,，用于调试
      boolean logXaCommands = true;

      // 获得资源管理器操作接口实例 RM1
      Connection conn1 = DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "root", "shxx12151022");
      XAConnection xaConn1 = new MysqlXAConnection((com.mysql.jdbc.Connection) conn1, logXaCommands);

      XAResource rm1 = xaConn1.getXAResource();

      // 获得资源管理器操作接口实例 RM2
      Connection conn2 = DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "root","shxx12151022");

      XAConnection xaConn2 = new MysqlXAConnection((com.mysql.jdbc.Connection) conn2, logXaCommands);

      XAResource rm2 = xaConn2.getXAResource();

      // AP请求TM执行一个分布式事务，TM生成全局事务id
      byte[] gtrid = "g12345".getBytes();
      int formatId = 1;

      try {
         // ==============分别执行RM1和RM2上的事务分支====================
         // TM生成rm1上的事务分支id
         byte[] bqual1 = "b00001".getBytes();

         Xid xid1 = new MysqlXid(gtrid, bqual1, formatId);

         // 执行rm1上的事务分支
         rm1.start(xid1, XAResource.TMNOFLAGS);//One of TMNOFLAGS, TMJOIN, or TMRESUME.
         PreparedStatement ps1 = conn1.prepareStatement("INSERT into user(name) VALUES ('tianshouzhi')");

         ps1.execute();
         rm1.end(xid1, XAResource.TMSUCCESS);

         // TM生成rm2上的事务分支id
         byte[] bqual2 = "b00002".getBytes();
         Xid xid2 = new MysqlXid(gtrid, bqual2, formatId);

         // 执行rm2上的事务分支
         rm2.start(xid2, XAResource.TMNOFLAGS);
         PreparedStatement ps2 = conn2.prepareStatement("INSERT into user(name) VALUES ('wangxiaoxiao')");

         ps2.execute();

         rm2.end(xid2, XAResource.TMSUCCESS);

         // ===================两阶段提交================================
         // phase1：询问所有的RM 准备提交事务分支
         int rm1_prepare = rm1.prepare(xid1);
         int rm2_prepare = rm2.prepare(xid2);

         // phase2：提交所有事务分支
         boolean onePhase = false; //TM判断有2个事务分支，所以不能优化为一阶段提交

         if (rm1_prepare == XAResource.XA_OK
               && rm2_prepare == XAResource.XA_OK
               ) {//所有事务分支都prepare成功，提交所有事务分支
            rm1.commit(xid1, onePhase);
            rm2.commit(xid2, onePhase);
         } else {//如果有事务分支没有成功，则回滚
            rm1.rollback(xid1);
            rm1.rollback(xid2);
         }
      } catch (XAException e) {
         // 如果出现异常，也要进行回滚
         e.printStackTrace();
      }
   }
}
```

  在这个案例中，演示了2个RM的情况下分布式事务的工作流程。因为我们充当了"人肉事务管理器”TM，因此很多本应该由TM来处理的工作处理细节也直接体现在上述代码中，如:生成全局事务id和分支事务id、在RM上开启事务分支、两阶段提交等。虽然我们自己作为"人肉事务管理器”是很不可靠的，但是上述代码可以让我们了解一个TM内部的主要工作流程是怎样的。

  在实际开发中，代码绝不会像上表面那样复杂，因为我们通常都会使用第三方或者容器提供的TM功能，因此在操作分布式事务时，代码可以得到极大的简化。

  最后，由于我们设置了logXaCommands=true，程序在运行的时候回打印出执行的XA命令。如下所示：

```apache
    Fri Feb 02 18:09:29 CST 2018 DEBUG: Executing XA statement: XA START 0x673132333435,0x623030303031,0x1
    Fri Feb 02 18:09:29 CST 2018 DEBUG: Executing XA statement: XA END 0x673132333435,0x623030303031,0x1
    Fri Feb 02 18:09:29 CST 2018 DEBUG: Executing XA statement: XA START 0x673132333435,0x623030303032,0x1
    Fri Feb 02 18:09:29 CST 2018 DEBUG: Executing XA statement: XA END 0x673132333435,0x623030303032,0x1
    Fri Feb 02 18:09:29 CST 2018 DEBUG: Executing XA statement: XA PREPARE 0x673132333435,0x623030303031,0x1
    Fri Feb 02 18:09:29 CST 2018 DEBUG: Executing XA statement: XA PREPARE 0x673132333435,0x623030303032,0x1
    Fri Feb 02 18:09:29 CST 2018 DEBUG: Executing XA statement: XA COMMIT 0x673132333435,0x623030303031,0x1
    Fri Feb 02 18:09:29 CST 2018 DEBUG: Executing XA statement: XA COMMIT 0x673132333435,0x623030303032,0x1
```

#### MySQL Connector/J XA事务支持源码简单分析**

  最后，我们对上述源码进行一下简单的分析。在前面直接使用mysql命令操作的时候，我们通过"XA START xid”等XA命令来执行XA事务。而在上述java代码中，我们是获取了一个普通的链接Connection之后，封装成了`MysqlXAConnection`。如下：

com.mysql.jdbc.jdbc2.optional.MysqlXAConnection

```java
public class MysqlXAConnection extends MysqlPooledConnection implements XAConnection, XAResource {

  private com.mysql.jdbc.Connection underlyingConnection;
  private Log log;
  protected boolean logXaCommands;

  //构造方法
  public MysqlXAConnection(com.mysql.jdbc.Connection connection, boolean logXaCommands) throws SQLException {
    super(connection);
    this.underlyingConnection = connection;
    this.log = connection.getLog();
    this.logXaCommands = logXaCommands;
  }

}
```

可以看到，MysqlXAConnection本身就实现了`XAResource`接口，因此当调用getXAResource()方法时，返回的就是其自己

com.mysql.jdbc.jdbc2.optional.MysqlXAConnection#getXAResource

```java
public XAResource getXAResource() throws SQLException {
    return this;
}
```

之后，我们调用XAResource的start方法来开启XA事务。start方法源码如下所示：

com.mysql.jdbc.jdbc2.optional.MysqlXAConnection#start

```java
public void start(Xid xid, int flags) throws XAException {
    //1、封装XA命令
    StringBuilder commandBuf = new StringBuilder(MAX_COMMAND_LENGTH);
    commandBuf.append("XA START ");
    appendXid(commandBuf, xid);

    //2、添加flag标记
    switch (flags) {
        case TMJOIN:
            commandBuf.append(" JOIN");
            break;
        case TMRESUME:
            commandBuf.append(" RESUME");
            break;
        case TMNOFLAGS:
            // no-op
            break;
        default:
            throw new XAException(XAException.XAER_INVAL);
    }

    //执行命令
    dispatchCommand(commandBuf.toString());
    this.underlyingConnection.setInGlobalTx(true);
}
```

 可以看到，当我们调用MysqlXAConnection的start方法时，实际上就是执行了一个”XA START xid [JOIN|RESUME]”命令而已，和我们直接在命令行中的操作是一样一样的，只不过通过封装简化了我们的操作。

   对于MysqlXAConnection的end、prepare、commit、rollback等方法，也都是是类似的，不再赘述。

  最后提示， MySQL Connector/J 中提供的XA操作接口，如上面提到的XAConnection、XAResource、Xid等，实际上都遵循了JTA规范。

> 全文引自：
>
> 1. 《MYSQL技术内幕 InnoDB存储引擎》
> 2. [MySQL中事务的五种分类](https://blog.csdn.net/qq_41333582/article/details/84196964)
> 3. [分布式事务之MySQL对XA的支持](https://blog.csdn.net/l1028386804/article/details/79769043)