# 概念

事务是数据库区别于文件系统的重要特征之一。在文件系统中，写文件写到一半，操作系统崩溃了，这个文件很有可能被破坏。所以，这正是数据库引入事务的主要目的：**事务会把数据库从一种一致性状态转换为另一种一致性状态。在数据库进行提交操作时，可以保证，要么所有所有修改都成功了，要么修改都不保存。**

事务可以由一条简单的SQL组成，也可以由一组复杂的SQL组成。要么都成功，要么都不成功。

# 分类

从事务理论的角度来看，可以把事务分为以下五种类型：

- 扁平事务(Flat Transactions)
- 带有保存点的扁平事务(Flat Transactions with Savepoints)
- 链事务(Chained Transactions)
- 嵌套事务(Nested Transactions)
- 分布式事务(Distributed Transactions)

## 1. 扁平事务

扁平事务 是事务类型中最简单的一种，但是在实际生产环境中，这可能是使用最频繁的事务，在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚，因此扁平事务是应用程序称为原子操作的的基本组成模块

下面显示了扁平事务的三种不同结果：

![1.6.0.扁平事务](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.0.%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1.jpg)

给出的扁平事务的三种情况，同时也给出了一个典型的事务处理应用中，每个结果大概占用的百分比。再次提醒，扁平事务虽然简单，但是在实际环境中使用最为频繁，也正因为其简单，使用频繁，故**每个数据库系统都实现了对扁平事务的支持**。

**扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交**。
下面给出一个扁平事务不足以支持的例子。例如用户在旅行网站上进行自己的旅行度假计划，用户设想从杭州到意大利的佛罗伦萨，这两个城市没有直达的班机，需要用户预订并转呈航班，需要或者搭火车等待。用户预订旅行度假的事务为

```
S1：预订杭州到上海的高铁

S2：上海浦东国际机场坐飞机，预订到米兰的航班

S3：在米兰转火车前往佛罗伦萨，预订去佛罗伦萨的火车
12345
```

但是当用户执行到S3时，发现由于飞机到达米兰的时间太晚，已经没有当天的火车，这时用户希望在米兰当地住一晚，第二天出发去佛罗伦萨。这时如果事务为扁平事务，需要回滚之前S1 S2 S3的三个操作，这个代价明显很大，因为当再次进行该事务是，S1 S2的执行计划是不变的，也就是说，如果支持有计划的回滚操作，那么不需要终止整个事务，因此就出现了**带有保存点的扁平事务**。

## 2. 带有保存点的扁平事务

带有保存点的扁平事务 除了支持扁平事务支持的操作外，允许在事务执行过程中回滚同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销太大，保存点用来通知事务系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。

对于扁平的事务来说，隐式的设置了一个保存点。然而整个事务中，只有这一个保存点，因此，回滚只能会滚到事务开始时的状态，保存点用SAVE WORK函数来建立，通知系统记录当前的处理状态。当出现问题时，保存点能用作内部的重启动点，根据应用逻辑，决定是回到最近一个保存点还是其他更早的保存点。图显示了事务中使用的保存点

![1.6.1.带有保存点的扁平事务](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.1.%E5%B8%A6%E6%9C%89%E4%BF%9D%E5%AD%98%E7%82%B9%E7%9A%84%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1.jpg)

显示了如何在事务中使用保存点，灰色背景部分表示由ROLLBACK WORK而导致部分回滚，实际并没有执行操作，当用BEGIN WORK开启一个事务时，隐式地包含了一个保存点，当事务通过ROLLBACK WORK：2发出部分回滚命令时，事务会滚到保存点2，接着依次执行，并再次执行到ROLLBACK WORK：7，知道最后COMMIT WORK操作，表示事务结束，除灰色阴影部分的操作外，其余操作都已经执行，并且提交。

另一个需要注意的是，保存点在事务内部是**递增**的，从图中可以看出，有人可能会想，返回保存点2以后，下一个保存点可以为3，因为之前的工作已经终止，然而新的保存点编号为5，这意味着ROLLBACKU 不影响保存点的计数，并且单调递增编号能保持事务执行的整个历史过程，包括在执行过程中想法的改变。

此外，当事务通过ROLLBACK WORK：2命令发出部分回滚命令时，要记住事务并没有完全被回滚，只是回滚到保存点2而已，这代表当前事务是活跃的，如果想要回滚事务，还需要执行ROLLBACKUP WORK。

## 3. 链事务

链事务 可视为保存点模式的一种变种，带有保存点的扁平事务，当发生系统崩溃是，所有的的保存点都将消失，因为其保存点是易失的，这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行

链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作 将合并为一个原子操作，这意味着下一个事务将看到上一个事务的结果，就好像一个事务中进行的一样，如图显示了链事务的工作方式：

![1.6.2.链事务](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.2.%E9%93%BE%E4%BA%8B%E5%8A%A1.png)

链事务与带有保存点的扁平事务不同的是，带有保存点的扁平事务能回滚到任意正确的保存点，而链事务中的回滚仅限当前事务，即只能恢复到最近的一个保存点，对于锁的处理，两者也不相同，锁事务在执行COMMIT后即释放了当前所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的锁。

## 4. 嵌套事务

嵌套事务 是一个层次结构框架，由一个顶层事务(top-level transaction)控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务，其控制每一个局部的变换，结构如下

![1.6.3.嵌套事务](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.3.%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1.png)

下面给出MOSS对嵌套事务的定义

1. 嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务也可以是扁平事务
2. 处在叶节点的事务是扁平事务，但是每个事务从根到叶节点的距离可以说是不同的
3. 位于根节点的事务称为顶层事务，其他称为自事务。事务的前驱称(predecessor)为父事务(parent)，事务的下一层称为儿子事务(child)
4. 子事务既可以提交也可以回滚。但是它的提交操作并不马上生效。除非其父事务已经提交。因此可以推论出，任何子事务都在顶层事务提交后才真正的提交
5. 树中的任意事务回滚会引起它的所有子事务一同回滚，故子事务仅保留ACI特性而不具有D特性

在Moss的理论中，实际的工作是交由叶子节点完成，即只有叶子节点的事务才能才能访问数据库、发送信息、获取其他类型的资源。而高层的事务仅负责逻辑控制。决定合适调用相关的子事务。即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务，如图

![1.6.4.嵌套事务2](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.4.%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A12.png)

如图可以发现，在恢复时采用保存点技术比嵌套查询有更大的灵活性。例如在完成Tk3这事务时，可以会滚到保存点S2的状态。而在嵌套查询的层次结构中，这是不被允许的。

但是用保存点技术来模拟嵌套事务在锁的持有方面还是与嵌套查询有些区别。当通过保存点技术来模拟嵌套事务时，用户无法选择哪些锁需要被子事务集成，哪些需要被父事务保留，这就是说，无论有多少个保存点，所有被锁住的队形都可以被得到和访问。而在嵌套查询中，不同的子事务在数据库对象上持有的锁是不同观点。例如一个父事务P1 其持有对象X和Y的排他锁，现在要开始调用子事务P11 ,那么父事务P1 可以不传递锁，也可以传递所有的锁，也可以只传递一个排他锁，如果子事务P11 中还持有对象Z的排他锁，那么通过反向继承(counter-inherited)父事务P1 将持有3个对象X Y Z的排他锁。如果这时再次调用一个子事务P12 ，那么它可以传递哪里已经持有的锁。

然而，如果系统支持嵌套事务中并行地执行的各个子事务，在这种情况下，采用保存点的扁平事务来模拟嵌套事务就不切实际了。这从另一个方面反映出，**想要实现事务间的并行性，需要真正支持的嵌套事务。**

## 5. 分布式事务

分布式事务 通常是一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。

假如一个用户在ATM机上进行银行的转账操作，例如持卡人从招商银行存储卡转账10 000 元到工商银行的存储卡。这种情况下，可以将ATM机视为节点A，招商银行的后台数据库视为节点B，工商银行的后台数据库视为C，这个转账的操作可分解为以下的步骤

```
1. 节点A发出转账命令

2. 节点B执行存储卡中的余额减去10 000

3. 节点C执行存储卡终端的余额增加10 000

4. 节点A通知用户操作完成或者节点A通知用户操作失败
```

这里需要使用到分布式事务，因为节点A不能通过一台数据库就完成任务，其需要访问网络中两个节点的数据库，而在每个节点的数据库执行的实务操作有都是扁平的，对于分布式事务，其同样需要满足ACID特性，要么都发生，要么都失败。对于上述例子，如果2 3 步中任何一个操作失败，都会导致整个分布式事务回滚，若非这样，结果非常可怕。

对于**InnoDB存储引擎**来说，其支持**扁平事务**，**带保存点的事务**，**链事务**，**分布式事务**。对于嵌套事务，其原生不支持。因此对有**并发事务需求**的用户来说,MySQL数据库或InnoDB存储引擎就显得无能为力，然而用户仍可以通过带保存点的事务来模拟串行的嵌套事务。

# 一些前提知识

## （一）自动提交、提交和回滚

在InnoDB中，所有的用户活动都发生在一个事务中。如果启用了自动提交模式，则每个SQL语句各自形成一个事务。默认情况下，MySQL在启用autocommit的情况下为每个新连接启动会话，所以如果SQL语句没有返回错误，MySQL会在每个SQL语句之后执行commit。如果语句返回错误，则提交或回滚行为取决于错误。

- 启用autocommit的会话可以执行多语句事务，方法是使用显式的START事务或BEGIN语句启动事务，并用COMMIT或ROLLBACK语句结束事务。

- 如果在一个会话中，使用SET autocommit = 0禁用了自动提交模式，则该会话始终有一个打开的事务。COMMIT或ROLLBACK语句结束当前事务，并开始一个新的事务。

- 如果一个禁用了autocommit的会话在没有显式提交最终事务的情况下结束，MySQL将回滚该事务。

- 有些语句会隐式地结束事务，就像在执行语句之前执行了COMMIT一样。
- 提交意味着在当前事务中所做的更改成为永久性的，并且对其他会话可见。另一方面，ROLLBACK语句取消当前事务所做的所有修改。提交和回滚都释放了在当前事务中设置的所有InnoDB锁。

## （二）将DML操作与事务分组

默认情况下，MySQL启用autocommit模式，该模式会在您执行每条SQL语句时自动提交。如果您有使用其他数据库系统的经验，则可能不熟悉这种操作模式，在其他数据库系统中，发出一系列DML语句并提交它们或一起回滚它们是标准的做法。

要使用多语句事务，请使用SQL语句SET autocommit = 0关闭autocommit，并使用COMMIT或ROLLBACK适当地结束每个事务。要使autocommit保持开启状态，可以用`START TRANSACTION`开始每个事务，用COMMIT或ROLLBACK结束每个事务。下面的示例显示了两个事务。第一个是提交；第二个回滚。

```sql
mysql> CREATE TABLE customer (a INT, b CHAR (20), INDEX (a));
Query OK, 0 rows affected (0.00 sec)
mysql> -- Do a transaction with autocommit turned on.
mysql> START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)
mysql> INSERT INTO customer VALUES (10, 'Heikki');
Query OK, 1 row affected (0.00 sec)
mysql> COMMIT;
Query OK, 0 rows affected (0.00 sec)
mysql> -- Do another transaction with autocommit turned off.
mysql> SET autocommit=0;
Query OK, 0 rows affected (0.00 sec)
mysql> INSERT INTO customer VALUES (15, 'John');
Query OK, 1 row affected (0.00 sec)
mysql> INSERT INTO customer VALUES (20, 'Paul');
Query OK, 1 row affected (0.00 sec)
mysql> DELETE FROM customer WHERE b = 'Heikki';
Query OK, 1 row affected (0.00 sec)
mysql> -- Now we undo those last 2 inserts and the delete.
mysql> ROLLBACK;
Query OK, 0 rows affected (0.00 sec)
mysql> SELECT * FROM customer;
+------+--------+
| a    | b      |
+------+--------+
|   10 | Heikki |
+------+--------+
1 row in set (0.00 sec)
```

### 1. set autocommit = 0、start transaction、begin都能开启一个事务，有什么区别

- set autocommit = 0，关闭自动提交。当遇到需要开启事务的sql，会话本身会默认开启事务，需要commit或rollback处理事务。
- start transaction、begin，是针对 autocommit = 1来说的！！！这是最本质的区别。当然它两也可以在关闭自动提交中使用。

### 2. 客户端语言的事务

在PHP、Perl DBI、JDBC、ODBC或MySQL的标准C调用接口等api中，您可以将事务控制语句(如COMMIT)作为字符串发送到MySQL服务器，就像任何其他SQL语句(如SELECT或INSERT)一样。一些api还提供单独的特殊事务提交和回滚函数或方法。

## （三）一致性非锁定读取

一致的读取意味着InnoDB使用多版本化在某个时间点向查询提供数据库的快照。查询查看**在此时间点之前提交的事务**所做的更改，以及稍后或未提交的事务所做的更改。这条规则的例外是，查询会看到前面语句在同一事务中所做的更改。会导致以下异常:如果更新表中的某些行，SELECT会看到更新行的最新版本（RC），但也可能会看到任何行的旧版本（RR）。如果其他会话同时更新同一表，则异常意味着您可能会看到表处于数据库中从未存在的状态（RC 和 RR都会发生，修改对当前事务可见）。

RC 和 RR 创建快照的区别：

- **如果事务隔离级别是可重复读取(默认级别)，那么同一事务中的所有一致读取都会读取该事务中第一次读取所建立的快照。通过提交当前事务并在此之后发出新查询，可以为查询获得更新的快照。**

- **使用已提交读取隔离级别，事务中的每个一致读取都会设置并读取自己的新快照。**



一致读取是InnoDB在read COMMITTED和REPEATABLE read隔离级别上处理SELECT语句的默认模式。**一致的读操作不会在它访问的表上设置任何锁，因此，在对表执行一致的读操作时，其他会话可以自由地修改这些表。**



**假设您在默认的可重复读隔离级别中运行。当你发出一个一致的读取(即一个普通的SELECT语句)时，InnoDB会给你的事务一个时间点，根据这个时间点你的查询可以看到数据库。如果另一个事务删除了一行并在分配了您的时间点之后提交，您不会看到该行已被删除。插入和更新的处理方式类似。**

> 注意：
>
> 数据库状态的快照应用于事务中的SELECT语句，而不一定应用于DML语句。如果您插入或修改某些行，然后提交该事务，那么从另一个并发可重复读事务发出的DELETE或UPDATE语句可能会影响那些刚刚提交的行，即使会话不能查询它们。如果事务确实更新或删除了由不同事务提交的行，那么这些更改对当前事务是可见的。例如，您可能会遇到以下情况:
>
> ```sql
> SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc';
> -- Returns 0: no rows match.
> -- 此时，假设有另一个事务提交了 10 条‘abc’的数据，
> UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc';
> -- Affects 10 rows: 
> SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba';
> -- Returns 10: this txn can now see the rows it just updated.
> ```
>
> 其实 update 语句在开始阶段，需要查询数据库一次，把满足条件的数据页加载到缓冲池中。但 update 之前的 select是非锁定读，并没有锁住 'abc' 这条记录，导致其他事务能插入数据。

您可以通过提交事务，然后使用一致的快照执行另一个选择或启动事务来提高时间点。

**这称为多版本并发控制。**

在下面的示例中，只有当B提交了插入并且A也提交了时，会话A才看到B插入的行，因此时间点超前于B的提交。(RR)

```sql
             Session A              Session B

           SET autocommit=0;      SET autocommit=0;
time
|          SELECT * FROM t;
|          empty set
|                                 INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           empty set
                                  COMMIT;

           SELECT * FROM t;
           empty set

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------
```

如果您想查看数据库的“最新”状态，请使用READ COMMITTED隔离级别或锁定读:`SELECT * FROM t lock in share mode;` 或 `SELECT * FROM t for update;`通过当前读（加读写锁）的方式获取最新数据，而不是通过快照获取数据。

延续上边例子：

```
    Session A              Session B

           SET autocommit=0;      					SET autocommit=0;
time
|          SELECT * FROM t;
|          empty set
|                                 					INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           empty set
                                  					COMMIT;

           SELECT * FROM t lock in share mode;
           ---------------------
           |    1    |    2    |
           ---------------------

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------
```

使用 RC 隔离级别，事务中的每个一致读取都会设置并读取自己的新快照。当LOCK处于共享模式时，会发生一个锁定读取:SELECT阻塞，直到包含最新行的事务结束。

一致读取不能在某些DDL语句上工作:

- 一致性读取在删除表上不起作用，因为MySQL不能使用已经删除的表，而InnoDB会破坏表。

- 一致读取不能在ALTER TABLE操作上工作，这些操作生成原始表的临时副本，并在构建临时副本时删除原始表。当您在事务中重新发出一致的读取时，新表中的行是不可见的，因为在捕获事务的快照时这些行不存在。在这种情况下，事务返回一个错误:ER_TABLE_DEF_CHANGED，“表定义已更改，请重试事务”。

读取的类型因选择子句中的select 语句而有所不同，如INSERT INTO ... SELECT, UPDATE ... (SELECT), 和 CREATE TABLE ... SELECT，不包含 FOR UPDATE 或 LOCK IN SHARE MODE:

- 默认情况下，InnoDB在这些语句中使用更强的锁（数据行锁+间隙锁），SELECT部分类似于READ COMMITTED，每个一致的READ，即使是在同一个事务中，也会设置和读取它自己的新快照。

- 在这种情况下，要执行非锁定读操作，可以启用innodb_locks_unsafe_for_binlog选项，并设置事务的隔离级别为未提交读、已提交读或可重复读，以避免对从所选表读取的行设置锁。

## （四）锁定读

如果在同一个事务中查询数据，然后插入或更新相关数据，那么常规SELECT语句不能提供足够的保护。其他事务可以更新或删除您刚才查询的相同行。InnoDB支持两种类型的锁读取，提供了额外的安全:

- SELECT ... LOCK IN SHARE MODE
  在被读取的任何行上**设置共享模式锁**。其他会话可以读取这些行，但在事务提交之前不能修改它们。如果这些行中的任何一行被尚未提交的另一个事务更改，则查询将等待该事务结束，然后使用最新的值。
- SELECT ... FOR UPDATE
  **对于遇到的搜索索引记录，锁定行和任何关联的索引项**，就像对这些行发出UPDATE语句一样。其他事务不能更新这些行，不能做SELECT ... LOCK IN SHARE MODE，或在某些事务隔离级别中读取数据。一致性读取忽略在read view中存在的记录上设置的任何锁。(旧版本的记录不能被锁定;它们是通过在记录的内存副本上应用undo log重新构建的。)

这些子句在处理单个表或跨多个表的树结构或图结构数据时最有用。

提交或回滚事务时，将释放 由`LOCK IN SHARE MODE`和`FOR UPDATE` 设置的所有锁定。

> 注意：
>
> 只有在禁用自动提交时(通过启动事务或将自动提交设置为0来开始事务)，才可能进行锁读。

### 锁定读不会延续到子查询中

除非在子查询中也指定了锁定读子句，否则外层语句中的锁定读子句不会锁定嵌套子查询中的表行。例如，下面的语句没有锁定表t2中的行。

```sql
SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;
```

要锁定table中的行，`t2`请向子查询添加锁定的read子句：

```sql
SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;
```

### 锁定读案例

假设您希望向表的子行插入一个新行，并确保子行在表parent中有一个父行。您的应用程序代码可以确保整个操作序列的引用完整性。

首先，使用一致的读取来查询表父行，并验证父行是否存在。可以安全地将子行插入到表的子行吗?不会，因为其他一些会话可能会在您的选择和插入之间删除父行，而您不知道它。

为了避免这个潜在的问题，需要使用 LOCK IN SHARE MODE 进行读取:

```sql
SELECT * FROM parent WHERE NAME = 'Jones' LOCK IN SHARE MODE;
```

在 LOCK IN SHARE MODE 查询返回父'Jones'之后，您可以安全地将子记录添加到子表并提交事务。任何试图获取父表中对应行的排他锁的事务都会等待，直到您提交事务下，也就是说，直到所有表中的数据处于一致状态。

再举一个例子，考虑一个表中的整数计数器字段，该字段`CHILD_CODES`用于为添加到table的每个子元素分配唯一标识符 `CHILD`。不要使用一致读取或共享模式读取来读取计数器的当前值，因为数据库的两个用户可能会看到该计数器的相同值，并且如果两个事务尝试添加与`CHILD`表相同的标识符的行，则会发生重复键错误。

在这里，LOCK IN SHARE MODE 不是一个好的解决方案，因为如果两个用户同时读取计数器，至少其中一个在尝试更新计数器时死锁。

要实现读取和递增计数器，首先对使用FOR UPDATE的计数器执行锁定读取，然后递增计数器。例如:

```sql
SELECT counter_field FROM child_codes FOR UPDATE;
UPDATE child_codes SET counter_field = counter_field + 1;
```

`SELECT ... FOR UPDATE`读取最新的可用数据，并在读取的每一行上设置排他锁。因此，它设置了与`UPDATE`搜索的行上设置的锁相同的锁。

前面的描述只是`SELECT ... FOR UPDATE`工作方式的一个示例 。在MySQL中，生成唯一标识符的特定任务实际上可以仅通过单次访问表来完成：

```sql
UPDATE child_codes SET counter_field = LAST_INSERT_ID(counter_field + 1);
SELECT LAST_INSERT_ID();
```

该`SELECT`语句仅检索标识符信息（特定于当前连接）。它不访问任何表。

## （五）snapshot - 快照 与 read view

表示在特定时间的数据，即使其他事务提交了更改，该表示也保持不变。由某些隔离级别使用，以允许一致的读取。

## （六）幻影行

当同一个查询在不同的时间产生不同的行集时，就会在事务中发生所谓的幻影问题。例如，如果SELECT执行了两次，但第二次返回第一次没有返回的行，则该行是一个“幻影”行。

假设在子表的id列上有一个索引，你想从表中读取并锁定标识符值大于100的所有行，目的是以后更新选中行的某些列:

```sql
SELECT * FROM child WHERE id > 100 FOR UPDATE;
```

查询从id大于100的第一个记录开始扫描索引。让表包含id值为90和102的行。如果在扫描范围内的索引记录上设置的锁没有锁定在间隙(在本例中是介于90和102之间的间隙)中进行的插入，则另一个会话可以向表中插入id为101的新行。如果要在同一个事务中执行相同的SELECT，您将在查询返回的结果集中看到一个id为101(一个“幻影”)的新行。如果我们将一组行视为一个数据项，那么新的幻影子元素将违反事务隔离原则，即事务应该能够运行，以便它读取的数据不会在事务期间发生变化。

为了防止幽灵行的出现，InnoDB使用了一种叫做next-key锁的算法，它结合了**索引行锁和间隙锁**。InnoDB执行行级锁的方式是，当它搜索或扫描一个表索引时，它会在遇到的索引记录上设置共享锁或排他锁。因此，行级锁实际上是索引记录锁。此外，索引记录上的next-key锁还会影响该索引记录之前的“间隙”。也就是说，**next-key锁是索引记录锁加上索引记录之前的间隙锁**。如果一个会话对索引中的记录R有共享或排他锁，则另一个会话不能在索引顺序中紧靠R之前的间隙插入新的索引记录。

**当InnoDB扫描一个索引时，它也可以锁定索引中最后一条记录之后的间隙**。正如前面的例子中所发生的那样:为了防止向id大于100的表进行任何插入，InnoDB设置的锁包括id值102后面的间隙上的一个锁。

您可以使用Next-Key锁定在应用程序中实现**唯一性检查**：如果在共享模式下读取数据时没有看到要插入的行的重复项，则可以安全地插入行，并且知道在读取过程中在行的后继项上设置的Next-Key锁可以防止任何人同时为您的行插入重复项。因此，NEXT-KEY锁定使您能够“锁定”表中不存在的内容。

间隙锁可以被禁用，如14.7.1节“InnoDB锁”所讨论的那样。这可能会导致幻像问题，因为当间隙锁被禁用时，其他会话可能会向间隙插入新行。

# 事务实现的基础

## 1.redo log

redo log叫做**重做**日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当**事务提交之后**会把所有修改信息都会存到该日志中。

在数据库的运行过程中，不需要对 redo log 进行读取。只有服务器宕机，数据丢失后才会读取。

关于 redo log 之前已经讨论过，这里不在赘述。

## 2. undo log

undo log 用来保证事务的回滚 及 MVCC 的实现。

undo log 在运行过程中会随机读取，因为 MVCC 的原因。

**undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。**

# 事务的状态

- **active**

  开启事务后，事务进入active状态

- **prepare**
  当事务完成需要提交时，为了和BINLOG做XA，InnoDB的commit被划分成了两个阶段：prepare阶段和commit阶段，本小节主要讨论下prepare阶段undo相关的逻辑。

  为了在崩溃重启时知道事务状态，需要将事务设置为Prepare，MySQL 5.7对临时表undo和普通表undo分别做了处理，前者在写undo日志时总是不需要记录redo，后者则需要记录。

  分别设置insert undo 和 update undo的状态为prepare，调用函数trx_undo_set_state_at_prepare，过程也比较简单，找到undo log slot对应的头页面(trx_undo_t::hdr_page_no)，将页面段头的TRX_UNDO_STATE设置为TRX_UNDO_PREPARED，同时修改其他对应字段，如下图所示（对于外部显式XA所产生的XID，这里不做讨论）：
  ![1.6.5.事务prepare状态](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.6.5.%E4%BA%8B%E5%8A%A1prepare%E7%8A%B6%E6%80%81.png)

- **commit**
  commit后进入commit状态

# 事务的隔离级别

**事务隔离是数据库处理的基础之一。隔离是 ACID 中的字母I；隔离级别是在多个事务同时进行更改和执行查询时，对性能与可靠性、一致性和结果再现性之间的平衡进行微调的设置。**

1992标准所描述的所有四种事务隔离级别:**未提交读、提交读、可重复读和可序列化**。InnoDB都可以实现。InnoDB的**默认隔离级别是可重复读取**。



**用户可以使用`SET TRANSACTION`语句更改单个会话或所有后续连接的隔离级别**。若要为所有连接设置服务器的默认隔离级别，请在命令行或选项文件中使用——transaction-isolation选项。有关隔离级别和级别设置语法的详细信息，请参阅13.3.6节“设置事务语句”。



InnoDB使用不同的锁定策略支持这里描述的每个事务隔离级别。对于ACID遵从性非常重要的关键数据的操作，可以使用默认的可重复读取级别强制执行高度一致性。或者，在批量报告这样的情况下，精确的一致性和可重复的结果不如最小化锁定开销重要，您可以使用READ COMMITTED或甚至READ UNCOMMITTED来放松一致性规则。SERIALIZABLE实施了比可重复读取更严格的规则，它主要用于特殊情况，比如XA事务，以及用于对并发性和死锁问题进行故障排除。（视情况降低隔离级别）

以下详细介绍四种隔离级别：

- **READ UNCOMMITTED —— 读未提交**
  SELECT语句以非锁定方式执行，但可能会使用行的早期版本(即未提交事务中行数据的早期版本)。因此，使用这个隔离级别，这样的读取是不一致的。这也被称为脏读。这个隔离级别的其他工作方式与READ COMMITTED类似。

- **READ COMMITED ——读已提交**
  **每次一致读取(即使是在同一个事务中)都会设置和读取自己的新快照。** 就是这样导致的不可重复度。

  

  对于read (SELECT with For UPDATE或LOCK IN SHARE MODE)、UPDATE语句和DELETE语句，InnoDB只锁索引记录，而不锁它们之前的间隙，因此允许在被锁记录旁边自由插入新记录。

  

  由于禁用了间隙锁，可能会出现幻象问题，因为其他会话可能会向间隙中插入新行。

  

  **读提交隔离级别只支持基于行的二进制日志记录。如果在binlog_format=MIXED下使用READ COMMITTED，服务器会自动使用基于行的日志记录。**

  使用`READ COMMITTED`具有其他效果：

  - 对于`UPDATE`或 `DELETE`语句， `InnoDB`仅对其更新或删除的行持有锁。MySQL评估`WHERE`条件后，将释放不匹配行的记录锁 。这大大降低了死锁的可能性，但是仍然可以发生。
  - 对于`UPDATE`语句，如果某行已被锁定，则`InnoDB` 执行“半一致”读取，将最新的提交版本返回给MySQL，以便MySQL可以确定该行是否与`UPDATE`的`WHERE`条件 匹配 。如果该行匹配（必须更新），则MySQL会再次读取该行，这一次将`InnoDB`其锁定或等待对其进行锁定。

  请考虑从该表开始的以下示例：

  ```sql
  CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
  INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
  COMMIT;
  ```

  在这种情况下，表没有索引，因此搜索和索引扫描使用隐藏的聚集索引进行记录锁定，而不是使用索引列。

  假设一个会话`UPDATE`使用以下语句执行 ：

  ```sql
  # Session A
  START TRANSACTION;
  UPDATE t SET b = 5 WHERE b = 3;
  ```

  还假设第二个会话 `UPDATE`通过在第一个会话的语句之后执行以下语句来执行：

  ```sql
  # Session B
  UPDATE t SET b = 4 WHERE b = 2;
  ```

  在`InnoDB`执行`UPDATE`each每条数据时 ，它首先为其读取的每一行获取一个排他锁，然后确定是否对其进行修改。如果 `InnoDB`不修改该行，则释放该锁。否则， `InnoDB`将保留该锁直到事务结束。这会影响事务处理，如下所示。

  使用默认`REPEATABLE READ` 隔离级别时，第一个`UPDATE`将在其读取的每一行上获得一个x锁，并且不会释放其中的任何一个：

  ```sql
  x-lock(1,2); retain x-lock
  x-lock(2,3); update(2,3) to (2,5); retain x-lock
  x-lock(3,2); retain x-lock
  x-lock(4,3); update(4,3) to (4,5); retain x-lock
  x-lock(5,2); retain x-lock
  ```

  第二个`UPDATE`尝试获取任何锁定的块（因为第一次更新在所有行上都保留了锁定），并且直到第一个`UPDATE`提交或回滚时才继续进行：

  ```sql
  x-lock(1,2); block and wait for first UPDATE to commit or roll back
  ```

  `READ COMMITTED`相反，则第一个`UPDATE`一个在其读取的每一行上获取一个x锁，并释放其未修改的行的x锁：

  ```sql
  x-lock(1,2); unlock(1,2)
  x-lock(2,3); update(2,3) to (2,5); retain x-lock
  x-lock(3,2); unlock(3,2)
  x-lock(4,3); update(4,3) to (4,5); retain x-lock
  x-lock(5,2); unlock(5,2)
  ```

  对于第二个`UPDATE`， `InnoDB`执行 “半一致”读取，将它读取的每一行的最新提交版本返回给MySQL，以便MySQL可以确定该行是否符合 `UPDATE`中的 `WHERE`条件：

  ```sql
  x-lock(1,2); update(1,2) to (1,4); retain x-lock
  x-lock(2,3); unlock(2,3)
  x-lock(3,2); update(3,2) to (3,4); retain x-lock
  x-lock(4,3); unlock(4,3)
  x-lock(5,2); update(5,2) to (5,4); retain x-lock
  ```

  但是，如果`WHERE`条件包括索引列并`InnoDB`使用索引时，则在获取和保留记录锁定时仅考虑索引列。在下面的示例中，第一个`UPDATE`在b = 2的每一行上获取并保留一个x锁，第二个`UPDATE`在尝试获取同一记录上的x锁时使用第二 个锁，因为它也使用在b列上定义的索引。

  ```sql
  CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;
  INSERT INTO t VALUES (1,2,3),(2,2,4);
  COMMIT;
  
  # Session A
  START TRANSACTION;
  UPDATE t SET b = 3 WHERE b = 2 AND c = 3;
  
  # Session B
  UPDATE t SET b = 4 WHERE b = 2 AND c = 4;
  ```

  使用`READ COMMITTED` 隔离级别的效果与启用不赞成使用的 `innodb_locks_unsafe_for_binlog`（使用间隙锁）配置选项相同，但以下情况除外：

  - 启用 `innodb_locks_unsafe_for_binlog`是全局设置，会影响所有会话，而隔离级别可以针对所有会话全局设置，也可以针对每个会话单独设置。
  - `innodb_locks_unsafe_for_binlog`只能在服务器启动时设置隔离级别，而隔离级别可以在启动时设置或在运行时更改。

  `READ COMMITTED`因此提供了比`innodb_locks_unsafe_for_binlog`更好更灵活的控制 。

- **REPEATABLE READ —— 可重复读**
  这是InnoDB的默认隔离级别。**同一事务中的一致性读取会使用第一次读取所建立的快照。**这意味着，如果在同一个事务中发出几个普通(非锁定)SELECT语句，那么这些SELECT语句彼此之间也是一致的。

  

  对于读语句(SELECT with For UPDATE或LOCK IN SHARE MODE)、UPDATE和DELETE语句，锁定取决于语句是使用具有唯一搜索条件的唯一索引，还是使用范围类型搜索条件。

  

  对于具有唯一搜索条件的唯一索引，InnoDB只锁定找到的索引记录，而不是之前的间隙。

  

  对于其他搜索条件，InnoDB锁定被扫描的索引范围，使用间隙锁或next-key锁来阻止其他会话插入到范围所覆盖的间隙中。

- **SERIALIZABLE —— 可序列化 / 串行化**
  这个级别类似于可重复读取，如果自动提交被禁用，则InnoDB隐式地将所有**普通SELECT语句**转换为**SELECT ... LOCK IN SHARE MODE**。如果启用了autocommit，那么SELECT就是它自己的事务。因此，已知它是只读的，如果作为一致的(非锁定)读执行，可以序列化，不需要阻塞其他事务。(如果其他事务已经修改了所选的行，要强制禁止纯选择，请禁用autocommit。)

## RC 和 RR 的区别

1. RC 每次select的时候，获取的是最新版本的快照，因此会造成不可重复读；
   RR 依赖于第一次select 生成的快照，解决了不可重复读的问题

2. RC 中没有间隙锁；
   RR 中有间隙锁，一定程度上解决了幻读的问题

3. RC 当InnoDB返回数据给服务器后，若有些数据不满足要求，则释放掉对应行的锁
   RR 锁住之后，不会释放，直到事务提交或回滚

   

# 事务的特性

**ACID:**该ACID模式是一组数据库设计原则强调的是，对于业务数据和关键任务应用重要的可靠性方面。MySQL包含诸如`InnoDB`存储引擎严格遵循ACID模型，因此数据不会损坏，结果也不会因软件崩溃和硬件故障等异常情况而失真。当您依靠符合ACID的功能时，无需重新发明一致性检查和崩溃恢复机制。如果您有其他软件保护措施，超可靠的硬件或可以容忍少量数据丢失或不一致的应用程序，则可以调整MySQL设置以牺牲一些ACID可靠性，以获得更高的性能或吞吐量。

- **原子性（atomicity）**
  每个事务是最小单位，不可再分割。只有事务中的所有操作都成功，才算成功。只要有一个失败，即为失败。数据库的状态需要回退到执行事务之前的状态。
- **一致性（consistency）**
  事务将数据库从一种一致性状态，转变为另一种一致性状态。在事务开始之前和事务结束之后，数据库的完整性约束没有遭到破坏。例如，数据库中有个姓名字段为唯一约束，不能重复。如果一个事务对该字段进行了修改，在事务提交或回滚后，表中的姓名字段重复了，这就破坏了唯一性要求。从一致性状态变为不一致性状态。
- **隔离性（isolation）**
  多个事务之间，读写互相分离，在事务提交前，对其他事务不可见。
- **持久性（durability）**
  事务一旦提交，其结果是永久性的，不管是MySQL挂了，还是服务器宕机，都不能丢失结果。

**理论上，事务有严格的要求，即ACID特性。但数据库厂商处于各种目的，并没有严格遵守。**有时候不会导致严重的后果，反而会有性能上的提升。例如，MySQL的 NDB Cluster引擎虽然支持事务，但不满足持久性的要求；Oracle的默认隔离级别为 RC 不满足 隔离性的要求。**InnoDB存储引擎完全遵守了ACID。**

# 事务的实现

前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。

- 事务的原子性主要涉及InnoDB的事务。是通过 undo log 来实现的，相关的MySQL功能
  1. 设置自动提交
  2. 声明 COMMIT
  3. 声明 ROLLBACK
  4. `INFORMATION_SCHEMA` 表中的 操作数据。
- 事务的持久性性是通过 redo log 来实现的。涉及与特定硬件配置交互的MySQL软件功能。由于取决于您的CPU，网络和存储设备的功能的可能性很多，因此为具体的准则提供最复杂的方面。（这些准则可能采取购买“ 新硬件 ”的形式 。）相关的MySQL功能包括：
  1. `InnoDB` [doublewrite buffer](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_doublewrite_buffer)，由[`innodb_doublewrite`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_doublewrite) 配置选项打开和关闭
  2. 配置选项 [`innodb_flush_log_at_trx_commit`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit)，配置提交时刷新redo log策略
  3. 配置选项 [`sync_binlog`](https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_sync_binlog)commit的时候，刷新二进制日志到磁盘策略
  4. 配置选项 [`innodb_file_per_table`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_per_table)为每个表开启独立表空间
  5. 存储设备（例如磁盘驱动器，SSD或RAID阵列）中的写缓冲区。
  6. 电池后备存储设备中的缓存。
  7. 用来运行MySQL的操作系统，特别是它对`fsync()`系统调用的支持。
  8. 不间断电源（UPS）保护运行MySQL服务器并存储MySQL数据的所有计算机服务器和存储设备的电源。
  9. 您的备份策略，例如备份的频率和类型以及备份保留期。
  10. 对于分布式或托管数据应用程序，MySQL服务器的硬件所位于的数据中心的特定特性，以及数据中心之间的网络连接。
- 事务的隔离性是通过 (读写锁+MVCC)来实现的,主要涉及`InnoDB` [事务](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_transaction)，尤其是适用于每个事务的[隔离级别](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level)。相关的MySQL功能包括：
  1. 自动提交的设置
  2.  声明`SET ISOLATION LEVEL`
  3. `InnoDB` [锁定](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking) 的底层细节。在性能调整期间，您可以通过`INFORMATION_SCHEMA`表格查看这些详细信息 
- 而事务的终极大 boss **一致性**是通过原子性，持久性，隔离性来实现的，主要涉及内部`InnoDB`处理，以防止数据崩溃！！！相关的MySQL功能
  1. `InnoDB` [doublewrite缓冲区](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_doublewrite_buffer)。
  2. `InnoDB` [崩溃恢复](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_crash_recovery)。

**原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！**

总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。

# 多版本并发控制 - MVCC

## （一）简介 - 来源官网，建议背诵全文

`InnoDB`是一个 [多版本的存储引擎](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_mvcc)：它保留有关已更改行的旧版本的信息，以支持诸如并发和[回滚之](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback)类的事务功能 。此信息以称为[回滚段](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback_segment)的数据结构存储在表空间中 （在Oracle中类似的数据结构之后）。`InnoDB` 使用回滚段中的信息来执行事务回滚中所需的撤消操作。它还使用该信息来构建行的早期版本，以实现 [一致的读取](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read)。

在内部，`InnoDB`向数据库中存储的每一行添加三个字段：

- `DB_TRX_ID`字段：6字节，指示插入或更新该行的最后一个事务的事务id。
- `DB_ROLL_PTR`字段：7字节，称为回滚指针。回滚指针指向写入回滚段的撤消日志记录。如果行已更新，则撤消日志记录将包含在更新行之前重建行内容所必需的信息。此外，删除在内部被视为更新，在该更新中，该行中的特殊位被设置为将其标记为已删除。
- `DB_ROW_ID`字段：6字节，包含一个行ID，该ID在插入新行时会单调增加。如果 `InnoDB`自动生成聚集索引，该索引包含行ID值。否则，该 `DB_ROW_ID`列不会出现在任何索引中。（不显示指定主键的时候）

***重点：只在聚簇索引，即真实数据行中。***

**回滚段中的撤消日志分为插入和更新撤消日志。插入撤消日志仅在事务回滚中才需要，并且在事务提交后可以立即将其丢弃。更新撤消日志也用于一致的读取，但是只有在不存在为其`InnoDB`分配了快照的事务（ 一致的读取可能需要更新撤消日志中的信息来构建数据库的早期版本）后，才能将其撤消行。**

定期提交您的事务，包括仅发出一致读取的交易。否则， `InnoDB`将无法丢弃更新撤消日志中的数据，并且回滚段可能会变得太大而填满表空间。

回滚段中撤消日志记录的物理大小通常小于相应的插入或更新的行。您可以使用此信息来计算回滚段所需的空间。

在`InnoDB`多版本方案中，当您使用SQL语句删除行时，并不会立即将其从数据库中物理删除。`InnoDB`仅在丢弃为删除而编写的更新撤消日志记录时，才物理删除相应的行及其索引记录。此删除操作称为[purge](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_purge)，它非常快，通常花费与执行删除操作的SQL语句相同的时间顺序。

如果您在表中以几乎相同的速度以较小的批插入和删除行，那么清除线程就会开始滞后，并且由于所有“死”行，表可能会变得越来越大，从而使所有内容都绑定到磁盘上，并且非常慢。在这种情况下，通过调优innodb_max_purge_lag系统变量来控制新的行操作，并为清除线程分配更多的资源。

## （二）MVCC对聚簇索引和二级索引的处理方式的区别

`InnoDB`多版本并发控制（MVCC）对二级索引的处理方式不同于聚簇索引。聚簇索引中的记录将**就地更新**，其隐藏的系统列指向撤消日志条目，可以从中重建记录的早期版本。与聚簇索引记录不同，辅助索引记录不包含隐藏的系统列，也不会就地更新。

更新二级索引列时，将对旧的二级索引记录进行删除标记，插入新记录，并最终清除带有删除标记的记录。当二级索引记录被删除标记或二级索引页被较新的事务更新时，`InnoDB`在聚集索引中查找数据库记录。在聚集索引中，`DB_TRX_ID`检查记录，如果在启动读取事务后修改了记录，则从撤消日志中检索记录的正确版本。

如果二级索引记录被标记为删除或二级索引页被更新的事务更新， 则不使用[覆盖索引](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_covering_index)技术。不是从索引结构中返回值，而是`InnoDB`在聚集索引中查找记录。

但是，如果启用了 [索引条件下推（ICP）](https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html)优化，并且`WHERE`仅可以使用索引中的字段来评估部分条件，则MySQL服务器仍会将`WHERE`条件的这一部分下推到存储引擎，并使用索引。如果在删除标记的记录中，找不到匹配的记录，则避免聚集索引查找(使用undo log中的旧版数据)。如果找到了匹配的记录，即使在删除标记的记录中，则在 `InnoDB`聚簇索引中查找记录。





> 引自：
>
> 1. 《MYSQL技术内幕 InnoDB存储引擎》
> 2. [MySQL中事务的五种分类](https://blog.csdn.net/qq_41333582/article/details/84196964)