

# InnoDB逻辑存储结构

数据需要在一定的**数据结构和组织结构**下才能进行有效的管理。InnoDB表中的每行数据是基于B+树存储的，其中B+树中的顺序依据是主键的顺序，称为**索引组织表**。B+树存储在数据文件中，在B+树之外，InnoDB对数据文件中数据的管理和组织定义一个新的逻辑结构如下图所示：

![1.3.00.InnoDB逻辑存储结构图](../..//mysql-image/1.3.00.InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg)

- 所有的数据都被逻辑地存放在表空间中，对于整个数据库中的InnoDB表，可以共用一个表空间，也可以将表空间拆分为共享表空间和各个表私有的表空间。拆分后，私有表空间仅存储该表的**数据、索引、和插入缓冲BitMap页**，其他的数据如**回滚（undo）信息、系统事务信息**等还是存储在共享表空间里。

- **表空间**中的数据分类为各个段：数据段(Left node segment)、索引段(Non-left node segment)、回滚段(Rollback segment)等。为了 便于管理，在各个段中继续拆分为**区**，区再细化拆分为连续的页，**页是InnoDB磁盘管理的最小单位**（即InnoDB从磁盘读取和写入都是以页为单位进行的）。页中**按关系表中的行**来存储实际的关系数据。
- 每个区大小固定为 1M，区是由连续的页组成的。一个页的大小为 16 KB，所以每个区有64个连续的页。即使支持压缩页，区的大小也是固定的，页数会发生变化而已。
- 启动 innodb_file_per_table 之后，新建的表初始为 96k。原因是一开始使用32个碎片页来存放，节省空间。
- 页是Innodb存储的**最基本结构**，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在页结构里。页分为几种类型：**数据页（B-Tree Node），Undo页（Undo Log Page），系统页（System Page），事务数据页（Transaction System Page）**等；每个数据页的大小为16kb，每个页使用一个32位（一位表示的就是0或1）的int值来表示，正好对应Innodb最大64TB的存储容量(16kb * 2^32=64tib)
- ***在一般情况下，InnoDB一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。***
- InnoDB中，数据是按照行的格式来存储的。每个页存放的行数有硬性要求，为 16kb / 2 - 200行，即7992条记录。有关行格式参考：[InnoDB行记录存储结构](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483670&idx=1&sn=751d84d0ce50d64934d636014abe2023&chksm=979688e4a0e101f2a51d1f06ec75e25c56f8936321ae43badc2fe9fc1257b4dc1c24223699de&scene=21#wechat_redirect)

## 页的结构

> 引自
>
> 1. [innodb数据页结构](https://www.cnblogs.com/joeysh/archive/2019/04/16/10720192.html)

![1.3.01.InnoDB页结构图](../..//mysql-image/1.3.01.InnoDB%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

从上面的图可以看到，InnoDB的页结构分为七个部分，下面用表格说明一下各个部分对应的作用：

|        名称        |       中文名       | 占用空间大小 |                    简单描述                    |
| :----------------: | :----------------: | :----------: | :--------------------------------------------: |
|    File Header     |       文件头       |    38字节    |                  描述页的信息                  |
|    Page Header     |        页头        |    56字节    |                  页的状态信息                  |
| Infimum + SupreMum | 最小记录和最大记录 |    26字节    |         两个虚拟的行记录（后面会说明）         |
|    User Records    |      用户记录      |    不确定    |              实际存储的行记录内容              |
|     Free Space     |      空闲空间      |    不确定    |               页中尚未使用的空间               |
|   Page Directory   |       页目录       |    不确定    | 存放着数据页组，形成的slot，<br />记录相对位置 |
|    File Trailer    |      文件结尾      |    8字节     |                    结尾信息                    |

下面会详细介绍他们的作用

### 页中插入数据的过程

当我们在存储数据的时候，记录会存储到`User Records`部分 。但是在一个页新形成的时候是不存在`User Records` 这个部分的，每当我们在插入一条记录的时候，都会从Free Space中去申请一块大小符合该记录大小的空间并划分到`User Records`，当`Free Space`的部分空间全部被`User Records`部分替换掉之后，就意味着当前页使用完毕，如果还有新的记录插入，需要再去申请新的页，过程如下：

![1.3.02.记录插入页的过程](../..//mysql-image/1.3.02.%E8%AE%B0%E5%BD%95%E6%8F%92%E5%85%A5%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg)

（类似于缓冲池中，LRU list 和 Free list）

### User Records中每条记录的记录头信息

对于User Records中的每一条记录的管理，MySQL做了很多的处理，究竟做出了什么处理呢，这需要从每条记录里面的`记录的额外信息`部分中的`记录头信息` 说起。这是有关行格式的知识，关于行格式（指的就是一条记录的存储结构，有多种格式），有兴趣的可以去看一下[InnoDB记录存储结构](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483670&idx=1&sn=751d84d0ce50d64934d636014abe2023&chksm=979688e4a0e101f2a51d1f06ec75e25c56f8936321ae43badc2fe9fc1257b4dc1c24223699de&scene=21#wechat_redirect) 这篇文章。

首先，创建一个表：

```mysql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)
```

 如上所示，表中有三列，c1和c2用来存储整数的，c3用来存储字符串的。因为指定了主键为c1，所以MySQL就不会去创建那个隐藏的 row_id 列。指定了`ascii`字符集以及`Compact`的行格式，所以里面的每一条记录的行格式如下：

![1.3.03.innodb中数据的行格式](../..//mysql-image/1.3.03.InnoDB%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%8C%E6%A0%BC%E5%BC%8F.jpg)

先看一下行格式中每个属性代表的意思：

|     名称     | 大小（单位：bit） |                             描述                             |
| :----------: | :---------------: | :----------------------------------------------------------: |
|   预留位1    |         1         |                           没有使用                           |
|   预留位2    |         1         |                           没有使用                           |
| delete_mask  |         1         |                     标记该记录是否被删除                     |
| min_rec_mask |         1         |  标记该记录是否为B+树的非叶子节点中的最小记录（索引时用到）  |
|   n_owned    |         4         |                    表示当前槽管理的记录数                    |
|   heap_no    |        13         |            表示当前记录在记录堆(当前页)的位置信息            |
| record_type  |         3         | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录 |
| next_record  |        16         |                   表示下一条记录的相对位置                   |

由于这里只是描述在`User Records`中记录头的作用，所以下面只会说明一些相关的属性以及`c1`、`c2`、`c3`列的信息（其他信息没画不代表它们不存在，只是为了理解上的方便省略了～），简化后的行格式示意图就是这样：
![1.3.04.page_demo表简化行格式图](../..//mysql-image/1.3.04.page_demo%E8%A1%A8%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%9B%BE.jpg)

 我们往表中插入几条数据：

```mysql
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

 下面看看几条记录在页中的`User Records`是以何种形式进行体现的，为了方便理解，下面的图中把记录中的头信息和实际的数据都用的十进制进行的表示（其实都是二进制）：

![1.3.05.插入4条记录后User Records](../..//mysql-image/1.3.05.%E6%8F%92%E5%85%A54%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8EUser%20Records.jpg)

下面说说，记录头中的各个部分代表的含义：

#### delete_mask

 这个属性说的是当前这条记录是否被删除，当值为0的时候代表着没有被删除，为1的时候标志着被删除了。

是的，您没看错，当您执行删除一个记录的操作的时候，被删除的记录还存在页中，您对它进行了删除，它会把的

记录头中的这个属性设置为1，只是打了个标记。

> 原因
>
> 这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打个删除标记而已，而且这部分存储空间之后还可以重用，也就是说之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
>
> 如果您想彻底的从磁盘上移除这些被删除的记录，可以使用这个语句：
>
> ```mysql
> optimize table '表名';
> ```
>
> 执行这个命令后服务器会重新规划表中记录的存储方式，把被标记为删除的记录从磁盘上移除。

#### min_rec_mask

 有关索引的，记录索引的最小值，当遇到min()函数可直接获取

#### n_owned

 记录组中，记录的数量

#### heap_no

 这个属性是表示的当前记录在当前页中的位置，上面的一张图如果您仔细看了的话，会发现它们的位置分别是2、3、4、5，那么问题来了？ 0和1呢？

 这是因为在每次创建的一页里面会自动的加入两条记录，这被称为`伪记录` 或者 `虚拟记录` （因为不是我们自己插入的）;

 这两条伪记录一个代表着`最小记录`，一个代表着`最大记录` ；

 记录大小的比较是通过主键值来比较的。在上面我们插入的几条记录中的从小到大的顺序就是：1 < 2 < 3 < 4,

这标志着这4条记录的大小依次递增。

 不管我们插入了什么数据，页中的`最小记录` 和 `最大记录` 都是页生成时候的那两条伪记录。这两条伪记录的结构页相对简单，如下：

![1.3.06.伪记录的行结构](../..//mysql-image/1.3.06.%E4%BC%AA%E8%AE%B0%E5%BD%95%E7%9A%84%E8%A1%8C%E7%BB%93%E6%9E%84.jpg)

 还记得页结构组成的七部分中一个部分叫`Infimum + SupreMum` ，这个部分用来存储最小记录和最大记录的，没错，就是这两条伪记录。

> 原因：由于这两条记录不是我们自己定义的记录，所以它们并不存放在`页`的`User Records`部分，他们被单独放在一个称为`Infimum + Supremum`的部分

![1.3.07.伪记录与真实记录](../..//mysql-image/1.3.07%E4%BC%AA%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%9C%9F%E5%AE%9E%E8%AE%B0%E5%BD%95.jpg)

由上面的图可以看出，最小记录和最大记录的heap_no的值分别为0和1，也就是说它们的位置最靠前。

#### record_type

 这个属性表示当前记录的类型，一共有4种类型的记录，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的`record_type`值都是`0`，而最小记录和最大记录的`record_type`值分别为`2`和`3` ，关于1暂且不说；

#### next_record

 这个属性表示这从当前记录真实数据到下一条记录的真实数据的地址偏移量 ；

 假如有一条记录的`next_record` 的值为12，就标志着从这条记录的真实数据的地址往后找12个字节就是下一条记录的真实数据（链表）。也就是说页中的数据之间的联系是一个**根据大小**比较后从小指到大的**单向链表**。

 规定 **最小记录** 的下一条记录就本页中主键值最小的记录，而本页中主键值最大的记录的下一条记录就是 **最大记录**(最大的那条伪记录) ，为了更形象的表示一下这个`next_record`起到的作用，我们用箭头来替代一下`next_record`中的地址偏移量：

![1.3.08.伪记录与真实记录-next record](../..//mysql-image/1.3.08.%E4%BC%AA%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%9C%9F%E5%AE%9E%E8%AE%B0%E5%BD%95-next%20record.jpg)

 从上面可以看出，`最大记录` 的 `next_record` 的值为0，代表着最大记录的下一条记录是不存在的，它也是链条中的最后一个节点。

 当我们从页中删除一条数据后可以看看链表会发生那些变化：

```mysql
mysql> DELETE FROM page_demo WHERE c1 = 2;
Query OK, 1 row affected (0.02 sec)
```

 删掉第2条记录后的示意图就是：

![1.3.09.删除第二条记录后的示意图](../..//mysql-image/1.3.09.%E5%88%A0%E9%99%A4%E7%AC%AC%E4%BA%8C%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8E%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

 从上面可以看到：

> 当我们删除第二条记录后，链表中的变化最明显的就是各个节点之间的联系，它会把被删除数据的上一条记录和被删除数据的下一条数据进行关联（这条数据还是存在的，之前说的那个删除标记别忘了哦）。
>
> - 第2条记录并没有从存储空间中移除，而是把该条记录的`delete_mask`值设置为`1`。
> - 第2条记录的`next_record`值变为了0，意味着该记录没有下一条记录了。
> - 第1条记录的`next_record`指向了第3条记录。
> - 还有一点您可能忽略了，就是`最大记录`的`n_owned`值从`5`变成了`4`，关于这一点的变化我们稍后会详细说明的。
>
> 所以得到：不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。

下面我们再做一个操作，把删除的记录再次插入：

```mysql
mysql> INSERT INTO page_demo VALUES(2, 200, 'bbbb');
Query OK, 1 row affected (0.00 sec)
```

 我们来看看发生了什么变化：

![1.3.10.重新插入第2条记录](../..//mysql-image/1.3.10.%E9%87%8D%E6%96%B0%E6%8F%92%E5%85%A5%E7%AC%AC2%E6%9D%A1%E8%AE%B0%E5%BD%95.jpg)

很明显的可以看到，`InnoDB`并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。

### Page Directory

 通过上面，我们知道到了页中记录是一个按照大小从下到大连续的单向链表，现在来想想，当我们根据主键查询一条记录的时候是怎样进行的，我们来看看;

```mysql
SELECT * FROM page_demo WHERE c1 = 3;
```

 上面是一条查询语句，我们想想它的执行方式可能是：

 从最小记录开始，沿着链表一直往后找，总有一天会找到（或者找不到），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于您想要查找的主键值时，如果这个时候还没找到数据的话您就可以停止查找了（代表找不到），因为该节点后边的节点的主键值都是依次递增。

 上面的方式存在的问题就是，当页中的存储的记录数量比较少的情况用起来也没啥问题，但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的，所以这个方式很笨啊。

 我们来看看`InnoDB` 的处理方式：`InnoDB` 的处理方式相当于我们平时看书的时候，想看那一章的时候不会傻到去一页一页的找，而是通过目录去找到对应的页数，直接就定位过去了。说说`InnoDB` 这样处理的步骤吧：

 1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

 2. 每个组的最后一条记录的头信息中的`n_owned`属性表示该组内共有几条记录。

 3. 将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个`槽`（英文名：`Slot`）。这些地址偏移量都会被存储到靠近`页`的尾部的地方，页中存储地址偏移量的部分也被称为`Page Directory` 。

 比如说，现在表中有6条记录，`InnoDB`会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：

![1.3.11.page directory简单分组示意图](../..//mysql-image/1.3.11.page%20directory%E7%AE%80%E5%8D%95%E5%88%86%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

从上面的图中可以看到：

- Page Directory中有两个槽，也就是两个组，槽0的值是90，代表最小记录的地址偏移量；槽2的值是112，代表最大记录的地址偏移量；
- 注意记录中的最小记录和最大记录，他们分别是1和5：
  - 最小记录的`n_owned` 的值为1，代表着以最小记录结尾的这个分组中只有1条记录，就是最小记录本身；
  - 同理，最大记录的`n_owned` 的值为5，代表着以最大记录结尾的这个分组中只有5条记录，这5条记录包括它本身，就是说除了它本身还有其它4条记录；

 我们用图来表示一下：

![1.3.12.page directory简单分组示意图](../..//mysql-image/1.3.12.page%20directory%E7%AE%80%E5%8D%95%E5%88%86%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

上面的图中为了方便理解，暂时没管各条记录在存储设备上的排列方式了，单纯从逻辑上看一下这些记录和页目录的关系。真实的`Page Directory` 是在下面的。

 再说说，为什么最小记录的`n_owned`值为1，而最大记录的`n_owned`值为`5`呢？它们是怎么分配的？

 `InnoDB` 对每个分组中的记录条数是有规定的，对于最小记录所在的分组只能有 **1** 条记录，最大记录所在的分组拥有的记录条数只能在 **1~8** 条之间，剩下的分组中记录的条数范围只能在是 **4~8** 条之间。所以分组是按照下边的步骤进行的：

- 初始情况下一个数据页里面只有最小记录和最大记录（伪记录），它们属于不同的分组，也就是两个；
- 之后插入的每一条记录都会放到最大记录所在的组，直到最大记录所在组的记录数等于8条；
- 当最大记录所在组中的记录数等于8条的时候，如果还有记录插入的话，就会将最大记录所在组平均分裂成2个组，这个时候最大记录所在组就只剩下4条记录，这里再把这条记录再放入最大记录所在组；

 我们一口气又往表中添加了12条记录，现在就一共有16条正常的记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：

![1.3.13.page directory 详细分组示意图](../..//mysql-image/1.3.13.page%20directory%20%E8%AF%A6%E7%BB%86%E5%88%86%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

 上图中，只保留了头信息中的`n_owned`和`next_record`属性，也省略了各个记录之间的箭头，没画不等于没有！

 因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用`二分法`来进行快速查找。4个槽的编号分别是：`0`、`1`、`2`、`3`、`4`，所以初始情况下最低的槽就是`low=0`，最高的槽就是`high=4`。比方说我们想找主键值为`5`的记录，现在我们再来看看查找一条记录的步骤：

1.  首先得到中间槽的位置：`(0 + 4)/2 = 2` ,所以得到槽2，根据槽2的地址偏移量知道它的主键值是8，因为8>5，设置`high=2` ，`low`不变；

2. 再次计算中间槽的位置：`(0 + 2)/2 = 1` ,所以得到槽1，根据槽1的地址偏移量知道它的主键值是4, 因为4<5，设置`low=1` ，`high`不变；

3. 因为`high - low`的值为1，所以确定主键值为`5`的记录在槽1和槽2之间，接下来就是遍历链表的查找了；

 所以在一个数据页中查找指定主键值的记录的过程分为两步：

```
1. 通过二分法确定该记录所在的槽。

2. 通过记录的next_record属性组成的链表遍历查找该槽中的各个记录。
```

### Page Header

 设计`InnoDB`的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，`Page Directory`中存储了多少个槽等等，特意在页中定义了一个叫`Page Header`的部分，它是`页`结构的第二部分，这个部分占用固定的`56`个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：

|       名称       | 大小（单位：byte） |                                                              |
| :--------------: | :----------------: | :----------------------------------------------------------: |
| PAGE_N_DIR_SLOTS |         2          |                      在页目录中的槽数量                      |
|  PAGE_HEAP_TOP   |         2          |                       第一个记录的地址                       |
|   PAGE_N_HEAP    |         2          | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
|    PAGE_FREE     |         2          |       指向可重用空间的地址（就是标记为删除的记录地址）       |
|   PAGE_GARBAGE   |         2          |  已删除的字节数，行记录结构中`delete_flag`为1的记录大小总数  |
| PAGE_LAST_INSERT |         2          |                      最后插入记录的位置                      |
|  PAGE_DIRECTION  |         2          |                        最后插入的方向                        |
| PAGE_N_DIRECTION |         2          |                  一个方向连续插入的记录数量                  |
|   PAGE_N_RECS    |         2          | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
| PAGE_MAX_TRX_ID  |         2          |        修改当前页的最大事务ID，该值仅在二级索引中定义        |
|    PAGE_LEVEL    |         2          |                 当前页在索引树中的位置，高度                 |
|  PAGE_INDEX_ID   |         8          |                索引ID，表示当前页属于哪个索引                |
|     PAGE_BTR     |         10         |     非叶节点所在段的segment header，仅在B+树的Root页定义     |
|    PAGE_LEVEL    |         10         |       B+树所在段的segment header，仅在B+树的Root页定义       |

如果大家认真看过前边的文章，那么大致能看明白这里头前边一半左右的状态信息的意思，剩下的状态信息看不明白不要着急，饭要一口一口吃，东西要一点一点学。在这里想强调以下`PAGE_DIRECTION`和`PAGE_N_DIRECTION`的意思。

- `PAGE_DIRECTION`

  假如新插入的一条记录的主键值比上一条记录的主键值比上一条记录大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是`PAGE_DIRECTION`。

- `PAGE_N_DIRECTION`

  假设连续几次插入新记录的方向都是一致的，`InnoDB`会把沿着同一个方向插入记录的条数记下来，这个条数就用`PAGE_N_DIRECTION`这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。

### File Header

如果说`Page Header`描述的是`页`内的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀，那么`File Header`描述的就是`页`外的各种状态信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦。`File Header`是`InnoDB`页的第一部分，这个部分占用固定的`38`个字节，下边我们看看这个部分的各个字节都是代表啥意思吧：

|               名称               | 大小（单位：byte） |                             描述                             |
| :------------------------------: | :----------------: | :----------------------------------------------------------: |
|     FIL_PAGE_SPACE_OR_CHKSUM     |         4          |                   页的校验和（checksum值）                   |
|         FIL_PAGE_OFFSET          |         4          |                             页号                             |
|          FIL_PAGE_PREV           |         4          |                        上一个页的页号                        |
|          FIL_PAGE_NEXT           |         4          |                        下一个页的页号                        |
|           FIL_PAGE_LSN           |         8          |  最后被修改的日志序列位置（英文名是：Log Sequence Number）   |
|          FIL_PAGE_TYPE           |         2          | 该页的类型：B+树叶子节点、Undo log页、索引非叶子节点页、Insert Buffer空闲列表、Insert Buffer BitMap、系统页、扩展描述页、BLOB页 |
|     FIL_PAGE_FILE_FLUSH_LSN      |         8          | 仅在系统表空间的一个页中定义，代表文件至少被更新到了该LSN值，独立表空间中都是0 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID |         4          |                       页属于哪个表空间                       |

对照着这个表格，我们看几个目前比较重要的部分：

- `FIL_PAGE_SPACE_OR_CHKSUM`

  这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个值，这个值就称为`校验和`。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的（hashCode和equals），所以省去了直接比较两个比较长的字节串的时间损耗(和后面的File Trailer里面的那个相对应，看到后面您就明白了)。

- `FIL_PAGE_OFFSET`

  每一个`页`都有一个单独的页号，就跟您的身份证号码一样，`InnoDB`通过页号来可以唯一定位一个`页`。

- `FIL_PAGE_TYPE`

  这个代表当前`页`的类型，我们前边说过，`InnoDB`为了不同的目的而把页分为不同的类型，本集中介绍的其实都是存储记录的`数据页`，其实还有很多别的类型的页：

- `FIL_PAGE_PREV`和`FIL_PAGE_NEXT`

  一张表中可以有成千上万条记录，一个页只有`16KB`，所以可能需要好多页来存放数据，`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`就分别代表本页的上一个和下一个页的页号（双向链表）。

![1.3.14.数据页之间双链表示意图](../..//mysql-image/1.3.14.%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E9%97%B4%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

`Page Header` 的其它属性就不说了；

### File Trailer

 对于这个部分，我的理解比较简单，我们知道`InnoDB` 会把数据从内存刷新到磁盘，中间交互的单位是页 ，但是我们想想，假如再刷新到磁盘的时候出现了问题，这样的话怎么办呢？

 这就是`File Trailer` 作用，这个部分由`8`个字节组成，可以分成2个小部分：

- 前四个字节代表页的检验和：
  - 这个部分是和`File Header`中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为`File Header`在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的，反之意味着同步中间出了错；
- 后四个字节代表日志序列位置（LSN）
  - 这个部分也是为了校验页的完整性的，可以先不用管这个属性。

## 总结

> 1. InnoDB为了不同的目的而设计了不同类型的页，用于存放我们记录的页也叫做`数据页`。
> 2. 一个数据页可以被分为7个部分，分别是 
>    - `File Header`，表示文件头，占固定的38字节。 
>    - `Page Header`，表示页里的一些状态信息，占固定的56个字节。
>    - `Infimum + Supremum`，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的`26`个字节。
>    - `User Records`：真实存储我们插入的记录的部分，大小不固定。
>    - `Free Space`：页中尚未使用的部分，大小不确定。
>    - `Page Directory`：页中的记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。
> 3. 每个记录的头信息中都有一个`next_record`属性，从而使页中的所有记录串联成一个`单向链表`。
> 4. InnoDB会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个`槽`，存放在`Page Directory`中，所以在一个页中根据主键查找记录是非常快的，分为两步：
>    - 通过二分法确定该记录所在的槽。
>    - 通过记录的next_record属性组成的链表遍历查找该槽中的各个记录。
> 5. 每个数据页的`File Header`部分都有上一个和下一个页的编号，所以所有的数据页会组成一个`双链表`。
> 6. 为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和`LSN`值，如果首部和尾部的校验和和`LSN`值校验不成功的话，就说明同步过程出现了问题。

---

# 表

## 一些知识点

- MySQL5.5以后，创建表时，默认使用 InnoDB 存储引擎
- innodb_file_per_table 开启后，会给每个表分配独立表空间 .ibd文件，用于存放数据 和 索引
- innodb_file_per_table 未开启，则在共享表空间中存放数据 和 索引，ibdata1文件
- 每个表对应一个 .frm 文件，存放表定义信息，表的数据字典信息，编码
- 在内部，`InnoDB`将每个表的条目添加到`InnoDB`数据字典中。该条目包括数据库名称。例如，如果`t1`在`test` 数据库中创建了table ，则数据库名称的数据字典条目为 `'test/t1'`。这意味着您可以`t1`在不同的数据库中创建一个具有相同名称的表，并且该表名不会在内部冲突`InnoDB`。
- 可以在外部创建表，参考官网连接：[外部建表](https://dev.mysql.com/doc/refman/5.7/en/innodb-create-table-external.html)
- 导入 InnoDB 表，参考官网连接：[导入innodb表](https://dev.mysql.com/doc/refman/5.7/en/innodb-table-import.html)
- 移动或复制 InnoDB 表，参考官网连接：[移动或复制innodb表](https://dev.mysql.com/doc/refman/5.7/en/innodb-migration.html)
- 将 MYISAM 表转为 InnoDB 表，参考官网：[MYISAM表转为InnoDB表](https://dev.mysql.com/doc/refman/5.7/en/converting-tables-to-innodb.html)
- 每个数据页中，至少有三行数据 —— 隐藏的两行：最大值，最小值，和一条用户数据
- InnoDB中的AUTO_INCREMENT处理下边详细讲解，涉及到自增锁、事务、一些细节等。

---

# 索引

## 聚簇索引和二级索引

每个`InnoDB`表都有一个特殊的索引，称为[聚簇索引](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_clustered_index) ，用于存储行数据。通常，聚簇索引与[主键](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_primary_key)同义 。为了从查询，插入和其他数据库操作中获得最佳性能，您必须了解`InnoDB`如何使用聚簇索引为每个表优化最常见的查找和DML操作。

- 在表上定义`PRIMARY KEY` 时，`InnoDB`将其用作聚簇索引。为您创建的每个表定义一个主键。如果没有逻辑唯一且非空的列或列集，请添加一个新的 [自动递增](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_auto_increment) 列，其值将自动填充。

- 如果您没有`PRIMARY KEY`为表定义，MySQL会在所有`UNIQUE KEY NOT NULL`列所在的位置找到第一个索引，并将其用作聚集索引。

- 如果表没有索引`PRIMARY KEY`或没有合适的 `UNIQUE`索引，则在`InnoDB` 内部生成一个隐藏的聚集索引`GEN_CLUST_INDEX`，该索引在包含行ID值的合成列上命名 。这些行由`InnoDB`分配给该表中各行的ID排序 。行ID是一个6字节的字段，随着插入新行而单调增加。因此，按行ID排序的行实际上在插入顺序上。

  

### 聚集索引如何加快查询

通过聚集索引访问行是快速的，**因为索引搜索直接包含所有行数据的页面**。如果表很大，则与MYISAM相比，索引和数据不在一起，聚集索引体系结构通常可以节省磁盘I / O操作。

### 二级索引如何与聚簇索引相关

除聚集索引之外的所有索引都称为 [辅助索引](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_secondary_index)。在中`InnoDB`，辅助索引中的每个记录都包含该行的主键列以及为辅助索引指定的列。 `InnoDB`使用此主键值在聚集索引中搜索行。

如果主键较长，则辅助索引将使用更多空间，因此具有较短的主键是有利的。

## InnoDB索引的物理结构

除空间索引外，`InnoDB` 索引均为 B+ 数据结构。空间索引使用 [R树](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_r_tree)，[R树](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_r_tree)是用于索引多维数据的专用数据结构。索引记录存储在其B+树或R树数据结构的叶页中。**索引页的默认大小为16KB。**

**MySQL中B+树在添加和删除时，会通过左旋右旋，尽量保持不浪费空间。**

当将新记录插入InnoDB聚集索引时，InnoDB会尝试保留1/16的页面空间，以供将来插入和更新索引记录。如果按顺序(升序或降序)插入索引记录，则生成的索引页大约占满15/16。如果以随机顺序插入记录，页面的大小从1/2到15/16不等。（尽量保持所有数据在 一个页内，但随机插入，会导致页分裂，分裂时，会有一半的数据分裂出去——B+树分裂规则）

InnoDB在创建或重建B+树索引时执行大容量装载。这种创建索引的方法称为排序索引构建。`INNODB_FILL_FACTOR`配置选项定义在排序索引构建期间填充的每个B+树页面上的空间百分比，剩余空间保留用于将来的索引增长。空间索引不支持排序索引生成。如果InnodbFill_factor设置为100，则聚集索引页中有1/16的空间可供将来的索引增长使用。

如果InnoDB索引页的**填充因子**低于MERGE_THRESHOLD(如果未指定，则默认为50%)，InnoDB会尝试收缩索引树以释放该页。MERGE_THRESHOLD设置同时适用于B树和R树索引。有关详细信息，请参阅第14.8.12节“配置索引页的合并阈值”。

您可以在初始化MySQL实例之前设置Innodb_page_size配置选项，为MySQL实例中的所有InnoDB表空间定义页面大小。一旦定义了实例的页面大小，在不重新初始化实例的情况下就不能更改它。支持的大小为64KB、32KB、16KB(默认值)、8KB和4KB。

MySQL5.7中添加了对32KB和64KB页面大小的支持。有关详细信息，请参阅Innodb_page_size文档。

使用特定InnoDB页面大小的MySQL实例不能使用来自使用不同页面大小的实例的数据文件或日志文件。

## 排序索引的创建

**InnoDB在创建或重建索引时执行大容量装载，而不是一次插入一条索引记录。这种创建索引的方法也称为排序索引构建**。空间索引不支持排序索引生成。

### 索引构建有三个阶段。(归并排序思想)

1. 在第一阶段，扫描聚集索引，生成索引项并将其添加到排序缓冲区。当排序缓冲区变满时，条目被排序并写出到临时中间文件。这个过程也被称为“run”。
2. 在第二阶段，在将一个或多个运行写入临时中间文件的情况下，对文件中的所有条目执行合并排序。
3. 在第三个也是最后一个阶段，将排序后的条目插入到B-树中。

在引入排序索引构建之前，使用INSERT API将索引项插入到B树中，一次插入一个记录。该方法包括打开B-tree游标以查找插入位置，然后使用乐观插入将条目插入到B-tree页面中。如果由于页面已满而导致插入失败，则将执行悲观插入，这包括打开B-tree游标，并根据需要拆分和合并B-tree节点以找到条目的空间。这种“自上而下”的索引构建方法的缺点是搜索插入位置的成本以及B-tree节点的不断拆分和合并。

排序索引构建使用“自下而上”的方法构建索引。使用此方法，在B树的所有级别上都保存对最右侧叶页面的引用。分配必要B树深度的最右边的叶页，并根据条目的排序顺序插入条目。一旦叶页已满，就会将节点指针附加到父页，并为下一次插入分配一个同级叶页。此过程将继续进行，直到插入所有条目，这可能会导致最多插入到根级别。分配同级页时，将释放对先前固定的叶页的引用，并且新分配的叶页将成为最右侧的叶页和新的默认插入位置。

### 为未来的索引增长预留B树页面空间

要为将来的索引增长预留空间，可以使用Innodb_ill_factor配置选项保留一定百分比的B+树页面空间。例如，将INNODB_FILL_FACTOR设置为80将在排序索引构建期间在B+树页面中保留20%的空间。此设置既适用于B+树叶页面，也适用于非树叶页面。它不适用于用于文本或BLOB条目的外部页面。保留的空间量可能与配置的不完全相同，因为Innodb_ill_factor值被解释为提示而不是硬限制。

### 排序索引构建和全文本索引支持

全文索引支持排序索引生成。以前，SQL用于将条目插入全文索引

### 排序索引构建和压缩表

对于压缩表，前面的索引创建方法将条目同时附加到压缩页和未压缩页。当修改日志(表示压缩页上的可用空间)变满时，将重新压缩压缩页。如果由于空间不足而导致压缩失败，页面将被拆分。使用排序索引构建，条目仅追加到未压缩的页。当未压缩的页面变满时，它将被压缩。在大多数情况下，自适应填充用于确保压缩成功，但如果压缩失败，则会拆分页面并再次尝试压缩。此过程将继续，直到压缩成功。

### 排序索引构建和重做日志记录

在排序索引生成期间禁用重做日志记录。相反，有一个检查点来确保索引构建可以承受意外退出或失败。检查点强制将所有脏页写入磁盘。在排序索引生成期间，页面清理器线程会定期收到刷新脏页的信号，以确保可以快速处理检查点操作。通常，当干净页的数量低于设定的阈值时，页清理器线程会刷新脏页。对于排序索引构建，将立即刷新脏页，以减少检查点开销，并使I/O和CPU活动并行化。

### 排序索引构建和优化器统计

排序的索引构建可能会导致优化器统计信息与以前的索引创建方法生成的统计信息不同。统计数据的差异(预计不会影响工作负载性能)是由于用于填充索引的算法不同造成的。

---

# Tablespaces



## 系统表空间 - (ibdata1)

SYSTEM表空间是InnoDB数据字典、双写缓冲区、更改缓冲区和撤消日志的存储区。如果表是在SYSTEM表空间中创建的，而不是在file-per-table或常规表空间中创建的，则它还可能包含表和索引数据。

SYSTEM表空间可以有一个或多个数据文件。默认情况下，在数据目录中创建名为ibdata1的单个系统表空间数据文件。系统表空间数据文件的大小和数量由Innodb_data_file_path启动选项定义。有关配置信息，请参见系统表空间数据文件配置。



```
# 查看默认的表空间文件及一些信息

mysql> show variables like 'innodb_data_file_path';
+-----------------------+------------------------+
| Variable_name         | Value                  |
+-----------------------+------------------------+
| innodb_data_file_path | ibdata1:12M:autoextend |
+-----------------------+------------------------+
1 row in set, 1 warning (0.00 sec)
```

可以在my.cnf配置文件里配置多个表空间文件：

```
[mysqld]
innodb_data_file_path = /db/ibdata:2000M;/db2/ibdata2:2000M:autoextend
```

用两个文件组成共享表空间，若这两个文件在不同的磁盘上，	磁盘的负载将会被平均，可以提升数据库的整体性能。

autoextend：表示用完了指定的大小空间后，会自增。

### 调整系统表空间的大小

#### 增大系统表空间

增加SYSTEM表空间大小的最简单方法是将其配置为自动扩展。为此，请在Innodb_DATA_FILE_PATH设置中为最后一个数据文件指定自动扩展属性，然后重新启动服务器。例如：

```
innodb_data_file_path=ibdata1:10M:autoextend
```



指定自动扩展属性时，数据文件的大小会根据需要的空间自动增加8MB增量。INNODB_AUTOEXTEND_INCREMENT变量控制增量大小.

您还可以通过添加另一个数据文件来增加SYSTEM表空间大小。需要以下操作：

1. 停止MySQL服务器
2. 如果Innodb_DATA_FILE_PATH设置中的最后一个数据文件是使用自动扩展属性定义的，请将其删除，然后修改大小属性以反映当前数据文件的大小。要确定要指定的适当数据文件大小，请检查文件系统中的文件大小，并将该值向下舍入为最接近的MB值，其中MB等于1024 x 1024
3. 将新数据文件附加到Innodb_DATA_FILE_PATH设置，可以选择指定自动扩展属性。只能为Innodb_DATA_FILE_PATH设置中的最后一个数据文件指定自动扩展属性
4. 启动MySQL服务器

例如，此表空间具有一个自动扩展数据文件：

```shell
innodb_data_home_dir = innodb_data_file_path = /ibdata/ibdata1:10M:autoextend
```



假设数据文件随时间增长到988MB。这是[`innodb_data_file_path`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_data_file_path) 修改大小属性以反映当前数据文件大小之后，并指定新的50MB自动扩展数据文件之后的设置：

```none
innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend
```

添加新数据文件时，请勿指定现有文件名。`InnoDB`启动服务器时，将创建并初始化新的数据文件。

#### 减小系统表空间

您不能从系统表空间中删除数据文件。要减小系统表空间大小，请使用以下过程：

1. 使用[**mysqldump**](https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html)转储所有 `InnoDB`表，包括 模式中的`InnoDB`表 `mysql`。使用以下查询标识 模式中的`InnoDB`表 `mysql`：

   ```mysql
   mysql> SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='mysql' and ENGINE='InnoDB';
   +---------------------------+
   | TABLE_NAME                |
   +---------------------------+
   | engine_cost               |
   | gtid_executed             |
   | help_category             |
   | help_keyword              |
   | help_relation             |
   | help_topic                |
   | innodb_index_stats        |
   | innodb_table_stats        |
   | plugin                    |
   | server_cost               |
   | servers                   |
   | slave_master_info         |
   | slave_relay_log_info      |
   | slave_worker_info         |
   | time_zone                 |
   | time_zone_leap_second     |
   | time_zone_name            |
   | time_zone_transition      |
   | time_zone_transition_type |
   +---------------------------+
   ```

2. 停止服务器。

3. 删除所有现有的表空间文件（`*.ibd`），包括 `ibdata`和`ib_log` 文件。不要忘记删除 架构`*.ibd` 中表的文件`mysql`。

4. 删除表的所有`.frm`文件 `InnoDB`。

5. 为新系统表空间配置数据文件。请参阅 [系统表空间数据文件配置](https://dev.mysql.com/doc/refman/5.7/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration)。

6. 重新启动服务器。

7. 导入转储文件。

### 对系统表空间使用原始磁盘分区

您可以将原始磁盘分区用作`InnoDB` [系统表空间](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace)中的数据文件 。此技术可在Windows以及某些Linux和Unix系统上启用无缓冲的I / O，而不会增加文件系统的开销。在有和没有原始分区的情况下执行测试，以验证此更改是否确实提高了系统性能。

使用原始磁盘分区时，请确保运行MySQL服务器的用户ID具有该分区的读写特权。例如，如果您以`mysql`用户身份运行服务器 ，则分区必须可由读取和写入`mysql`。如果使用该[`--memlock`](https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_memlock)选项运行服务器，则该服务器必须以身份运行`root`，因此该分区必须可由读取和写入`root`。

下述步骤涉及选项文件的修改。有关更多信息，请参见[第4.2.2.2节“使用选项文件”](https://dev.mysql.com/doc/refman/5.7/en/option-files.html)。

## 每个表的文件表空间( .ibd )

每表文件表空间包含单个`InnoDB`表的数据和索引 ，并存储在文件系统中自己的数据文件中

### 每表文件表空间配置

默认情况下，InnoDB在每个表的文件表空间中创建表。此行为由INONDB_FILE_PER_TABLE变量控制。禁用Innodb_file_per_table会导致InnoDB在SYSTEM表空间中创建表。

Innodb_file_per_table设置可以在选项文件中指定，也可以在运行时使用SET GLOBAL语句进行配置。在运行时更改设置需要足够的权限来设置全局系统变量。

- 配置文件

  ```
  [mysqld]
  innodb_file_per_table=ON
  ```

- [`SET GLOBAL`](https://dev.mysql.com/doc/refman/5.7/en/set-variable.html) 

  ```sql
  mysql> SET GLOBAL innodb_file_per_table=ON;
  ```

MySQL 5.6及更高版本默认开启Innodb_file_per_table。如果需要考虑与早期版本的MySQL的向后兼容性，您可以考虑禁用它。

### 每表文件表空间数据文件

在MySQL数据目录下的模式目录中的.idb数据文件中创建每个表的文件表空间。.ibd文件根据表(table_name.ibd)命名。例如，表test.t1的数据文件创建在MySQL数据目录下的test目录下：

### 每表文件表空间的优势

```
mysql> USE test;

mysql> CREATE TABLE t1 (
   id INT PRIMARY KEY AUTO_INCREMENT,
   name VARCHAR(100)
 ) ENGINE = InnoDB;

shell> cd /path/to/mysql/data/test
shell> ls
t1.ibd
```

可以使用CREATE TABLE语句的DATA DIRECTORY子句在数据目录之外隐式创建每个表文件的表空间数据文件。有关详细信息，请参阅第14.6.1.2节“在外部创建表”。

### 每表文件表空间的优势

与共享表空间(如SYSTEM表空间或常规表空间)相比，逐表文件表空间具有以下优势。

- 截断或删除在逐表文件的表空间中创建的表后，磁盘空间将返回给操作系统。截断或删除存储在共享表空间中的表会在共享表空间数据文件中创建空闲空间，这些空间只能用于InnoDB数据。换句话说，**在表被截断或删除后，共享表空间数据文件的大小不会缩小。**

- 对驻留在共享表空间中的表执行表复制ALTER TABLE操作可能会增加表空间占用的磁盘空间量。此类操作可能需要与表中的数据加上索引一样多的额外空间。与逐表文件表空间不同，此空间不会释放回操作系统。

- 在驻留在逐表文件的表空间中的表上执行截断表时，性能会更好。

- 出于I/O优化、空间管理或备份的目的，可以在单独的存储设备上创建每个表的文件空间数据文件。请参阅第14.6.1.2节“外部创建表”。

- 您可以从另一个MySQL实例导入驻留在逐表文件表空间中的表。请参阅第14.6.1.3节“导入InnoDB表”。

- 在逐表文件的表空间中创建的表使用Barracuda文件格式。请参阅第14.10节“InnoDB文件格式管理”。Barracuda文件格式启用与动态和压缩行格式相关联的功能。请参阅第14.11节，“InnoDB行格式”。

- 当发生数据损坏、备份或二进制日志不可用或MySQL服务器实例无法重新启动时，存储在各个表空间数据文件中的表可以节省时间并提高成功恢复的机会。

- 您可以使用MySQL Enterprise Backup快速备份或恢复在逐个表的文件空间中创建的表，而不会中断其他InnoDB表的使用。这对于具有不同备份计划的表或备份频率较低的表很有用。有关详细信息，请参阅创建部分备份。

- 逐表文件表空间允许通过监视表空间数据文件的大小来监视文件系统上的表大小。

- 当Innodb_flush_method设置为O_DIRECT时，常见的Linux文件系统不允许对单个文件(如共享表空间数据文件)进行并发写入。因此，将逐表文件表空间与此设置结合使用时，可能会提高性能。

- 共享表空间中的表受64TB表空间大小限制。相比之下，每个表文件的表空间都有64TB的大小限制，这为各个表的大小增长提供了足够的空间。

### 每表文件表空间的缺点

与共享表空间(如SYSTEM表空间或常规表空间)相比，逐表文件表空间具有以下缺点。

- 对于逐表文件的表空间，每个表可能都有未使用的空间，这些空间只能由同一个表的行使用，如果管理不当，可能会导致空间浪费。

- 对每个表的多个文件数据文件执行fsync操作，而不是对单个共享表空间数据文件执行fsync操作。因为fsync操作是按文件进行的，所以不能组合多个表的写操作，这可能会导致fsync操作的总数更高。

- Mysqld必须为每个按表文件的表空间保留一个打开的文件句柄，如果在按表文件的表空间中有多个表，这可能会影响性能。

- 当每个表都有自己的数据文件时，需要更多的文件描述符。

- 可能会出现更多碎片，这可能会影响DROP TABLE和表扫描性能。但是，如果管理碎片，则每个表的文件表空间可以提高这些操作的性能。

- 当删除驻留在逐表文件的表空间中的表时，将扫描缓冲池，对于大型缓冲池，这可能需要几秒钟的时间。扫描使用较宽的内部锁执行，这可能会延迟其他操作。

- INONDB_AUTOEXTEND_INCREMENT变量定义自动扩展共享表空间文件变满时用于扩展其大小的增量大小，该变量不适用于每个表文件的文件，无论INONDB_AUTO EXTEND_INCREMENT设置如何，这些文件都会自动扩展。最初的每个表的文件空间扩展是少量的，之后以4MB为增量进行扩展。

## 通用表空间

通用表空间功能提供以下功能：

- 类似于系统表空间，通用表空间是共享表空间，可以存储多个表的数据。
- 通用表空间比[每表文件](https://dev.mysql.com/doc/refman/5.7/en/innodb-file-per-table-tablespaces.html)表空间具有潜在的内存优势 。服务器在表空间的生存期内将表空间元数据保留在内存中。与单独的每表文件表空间中的相同数量的表相比，较少的通用表空间中的多个表为表空间元数据消耗的内存更少。
- 通用表空间数据文件可以放置在相对于MySQL数据目录或独立于MySQL数据目录的目录中，该目录为您提供了许多数据文件和[每表文件表空间的](https://dev.mysql.com/doc/refman/5.7/en/innodb-file-per-table-tablespaces.html)存储管理功能 。与每表文件表空间一样，将数据文件放置在MySQL数据目录之外的功能使您可以分别管理关键表的性能，为特定表设置RAID或DRBD或将表绑定到特定磁盘。
- 通用表空间支持Antelope和Barracuda文件格式，因此支持所有表行格式和相关功能。支持两种文件格式，通用表空间不依赖 [`innodb_file_format`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_format)或 [`innodb_file_per_table`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_per_table) 设置，这些变量也不影响通用表空间。
- 该`TABLESPACE`选项可用于 [`CREATE TABLE`](https://dev.mysql.com/doc/refman/5.7/en/create-table.html)在通用表空间，每表文件表空间或系统表空间中创建表。
- 该`TABLESPACE`选项可用于 [`ALTER TABLE`](https://dev.mysql.com/doc/refman/5.7/en/alter-table.html)在通用表空间，每表文件表空间和系统表空间之间移动表。以前，不可能将表从每个表文件表空间移至系统表空间。使用通用表空间功能，您现在可以这样做。

## 创建通用表空间

常规表空间是使用[`CREATE TABLESPACE`](https://dev.mysql.com/doc/refman/5.7/en/create-tablespace.html)语法创建的 。

```sql
CREATE TABLESPACE tablespace_name
    ADD DATAFILE 'file_name'
    [FILE_BLOCK_SIZE = value]
        [ENGINE [=] engine_name]
```

## 撤销表空间

Undo表空间包含Undo日志，它们是Undo日志记录的集合，其中包含关于如何通过事务撤销对聚集索引记录的最新更改的信息。撤消日志存在于撤消日志段中，而撤消日志段包含在回滚段中。innodb_rollback_segments变量定义了分配给每个undo表空间的回滚段的数量。

[撤消日志](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_log)可以存储在一个或多个[撤消表空间中，](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_tablespace)而不是 [系统表空间中](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace)。此布局与默认配置不同，在默认配置中，撤消日志位于[系统表空间中](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace)。撤消日志的I / O模式使撤消表空间成为[SSD](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_ssd)存储的理想候选者 ，同时将系统表空间保留在硬盘存储上。

## 临时表空间



>参考自：
>
>1. 《MySQL技术内幕 InnoDB存储引擎》
>2. [InnoDB引擎--存储结构与文件](https://blog.csdn.net/john_lw/article/details/80306122)
>3. [官方文档](https://dev.mysql.com/doc/refman/5.7/en/innodb-on-disk-structures.html)
>4. [MySQL中InnoDB引擎中页的概念](https://www.jianshu.com/p/e5e3f8a823c3)